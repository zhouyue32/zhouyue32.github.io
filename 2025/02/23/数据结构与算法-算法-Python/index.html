<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>数据结构与算法-算法-Python |  zhouyue&#39;s blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-数据结构与算法-算法-Python"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据结构与算法-算法-Python
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-Python/" class="article-date">
  <time datetime="2025-02-23T04:53:23.000Z" itemprop="datePublished">2025-02-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">3.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">13 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="数据结构与算法——算法-Python"><a href="#数据结构与算法——算法-Python" class="headerlink" title="数据结构与算法——算法(Python)"></a>数据结构与算法——算法(Python)</h1><h2 id="一-时间复杂度与空间复杂度"><a href="#一-时间复杂度与空间复杂度" class="headerlink" title="一.时间复杂度与空间复杂度"></a>一.时间复杂度与空间复杂度</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h3><p>​	时间复杂度表示程序运行的<strong>“估算的”</strong>单位时长，可以理解为是一个时间单位，它并不与程序在某一台机器上运行的实际时长挂钩。</p>
<p>​	时间复杂度使用O()来表示，一般来说，时间复杂度根据问群体规模来确定n，并根据算法确定具体的复杂度。</p>
<h3 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2.空间复杂度"></a>2.空间复杂度</h3><p>​	同样地，空间复杂度则表示<strong>“估算的“</strong>内存用量，同样可以理解为一个空间单位，并不是某一种语言在某一个机器下的内存占用。</p>
<p>​	同样，空间复杂度也使用O()来表示，空间复杂度则根据数据类型来确定：</p>
<ul>
<li>仅使用变量：O(1)</li>
<li>使用长度为n的列表：O(n)</li>
<li>使用边长为n的二维列表：O(n<sup>2</sup>)</li>
</ul>
<p>由于内存造价比较便宜，相比较之下，时间比空间更为重要。</p>
<h2 id="二-递归"><a href="#二-递归" class="headerlink" title="二.递归"></a>二.递归</h2><ul>
<li><p>递归的特点：</p>
<ul>
<li>调用自身</li>
<li>结束条件</li>
</ul>
</li>
<li><p>汉诺塔问题</p>
</li>
</ul>
<p>​	事实上，汉诺塔(Hannoi Tower)问题就是很典型的递归,要设法将n(n&gt;2)个盘子按规定的方式从a柱移动到b柱，当n过于庞大时，是没有办法一次性求解出的，但是，我们通过推理发现移动n个盘子和移动n-1个盘子之间存在联系：</p>
<ol>
<li>将n-1个盘子通过b移动到c</li>
<li>将第n个盘子移动到b</li>
<li>将n-1个盘子从c通过a移动到b</li>
</ol>
<p>当我们将前n-1个盘子打包看作一个整体时，有以上移动方法，同样的n-1个盘子也一样，以此类推，一直到n&#x3D;2时，这样就实现了复杂问题的<strong>简单子问题</strong>化。</p>
<h2 id="三-查找"><a href="#三-查找" class="headerlink" title="三.查找"></a>三.查找</h2><p>​	查找是指在一批次数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程。</p>
<h3 id="1-顺序查找-线性查找"><a href="#1-顺序查找-线性查找" class="headerlink" title="1.顺序查找(线性查找)"></a>1.顺序查找(线性查找)</h3><p>​	从列表第一个元素开始，顺序进行搜索，直到找到元素或者搜索完列表为止。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search</span>(<span class="params">data_set, value</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data_set)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> data_set[i] == value:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<h3 id="2-折半查找-二分查找"><a href="#2-折半查找-二分查找" class="headerlink" title="2.折半查找(二分查找)"></a>2.折半查找(二分查找)</h3><p>​	二分查找要求列表是有序的。(以下是一个从小到大排序的数据容器data_set)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">data_set, value</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(data_set)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> data_set[mid] == value:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> data_set[mid] &gt; value:</span><br><span class="line">           	right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">   	<span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<h2 id="三-排序"><a href="#三-排序" class="headerlink" title="三.排序"></a>三.排序</h2><p>​	排序即将一组“无序”的记录序列调整为“有序”的记录序列。</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>​	以升序为例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">data_set</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data_set)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data_set)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data_set[j] &gt; data_set[j+<span class="number">1</span>]:</span><br><span class="line">                data_set[j], data_set[j+<span class="number">1</span>] = data_set[j+<span class="number">1</span>], data_set[j]</span><br></pre></td></tr></table></figure>



<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p>​	遍历列表，每遍历一次得到最小数据并排入新列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">data_set</span>):</span><br><span class="line">    set_new = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data_set)):</span><br><span class="line">        min_val = <span class="built_in">min</span>(data_set)</span><br><span class="line">        set_new.append(min_val)</span><br><span class="line">        data_set.remove(min_val)</span><br><span class="line">    <span class="keyword">return</span> set_new</span><br></pre></td></tr></table></figure>

<p>这种排序方式并不好，需要建立一个新的数据容器，会重新申请内存空间，并且remove方法也会增加程序的时间复杂度。遵循原地排序且时间复杂度更低的原则，对其做出以下优化：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">data_set</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data_set) - <span class="number">1</span>):</span><br><span class="line">        min_loc = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(data_set)):</span><br><span class="line">            <span class="keyword">if</span> data_set[j] &lt; data_set[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">      	data_set[i], data_set[min_loc] = data_set[min_loc], data_set[i]</span><br></pre></td></tr></table></figure>



<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p> 在无序空间中划出一块有序空间，再基于有序空间从无序空间中拿取数据并排列。形似斗地主中的抓牌洗牌</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">data_set</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(data_set)): <span class="comment">#i表示无序区的牌的下标</span></span><br><span class="line">        tmp = data_set[i]</span><br><span class="line">        j = i-<span class="number">1</span> <span class="comment">#j表示手里摸到的牌的下标</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> data_set[j]&gt;tmp:</span><br><span class="line">            data_set[j+<span class="number">1</span>] = data_set[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">   		data_set[j+<span class="number">1</span>] = tmp </span><br></pre></td></tr></table></figure>



<h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p>​	选定第一个元素，将比它大的排到它右边，比它小的排到左边，再重复这个工作，最终就能得到有序的列表。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">data_set,left,right</span>):</span><br><span class="line">    tmp = data_set[left] <span class="comment">#临时变量保存第一个数据</span></span><br><span class="line">	<span class="keyword">while</span> left &lt; right:	<span class="comment">#保证当left==right时退出循环</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span>  data_set[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">       	data_set[left] = data_set[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> data_set[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">       	data_set[right] = data_set[left]</span><br><span class="line">   	data_set[left] = tmp</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">data_set,left,right</span>):</span><br><span class="line">    <span class="keyword">if</span> left&lt;right:</span><br><span class="line">    	mid = partition(data_set,left,right)</span><br><span class="line">    	quick_sort(data_set,left,mid-<span class="number">1</span>)</span><br><span class="line">    	quick_sort(data_set,mid+<span class="number">1</span>,right)</span><br></pre></td></tr></table></figure>



<h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><h4 id="1-堆排序前置知识"><a href="#1-堆排序前置知识" class="headerlink" title="1.堆排序前置知识"></a>1.堆排序前置知识</h4><h5 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h5><ul>
<li><p>树是一种数据结构，比如计算机目录结构</p>
</li>
<li><p>树是一种可以定义递归的结构</p>
</li>
<li><p>树是由n个节点组成的集合</p>
<ul>
<li>如果n&#x3D;0，是空树</li>
<li>如果n&gt;0，那存在一个节点作为树的根节点，其他节点可以分为m个集合，而每个集合本身又是一棵树</li>
</ul>
</li>
<li><p>树的度：最大分叉数</p>
</li>
<li><p>树的深度：分叉层数</p>
</li>
<li><p>叶节点：度为0的节点</p>
</li>
<li><p>二叉树：度不超过2的树</p>
</li>
<li><p>满二叉树：每一层节点都达到最大值的二叉树</p>
</li>
<li><p>完全二叉树：叶节点只出现在最下层和次下层，且最下层节点都集中在该层最左边的若干位置的二叉树</p>
</li>
</ul>
<h5 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h5><ul>
<li>链式存储方式(之后数据结构中讲)</li>
<li><span style= "color: red">顺序存储方式</span></li>
</ul>
<p>如果将一个二叉树的结构以列表的形式从根节点从左往右顺序表示，那么父子节点间关系如下：</p>
<ol>
<li>左子节点下标 &#x3D; 2*父节点下标+1</li>
<li>右子节点下标 &#x3D; 2*父节点下标+2</li>
</ol>
<h5 id="堆-特殊的完全二叉树"><a href="#堆-特殊的完全二叉树" class="headerlink" title="堆(特殊的完全二叉树)"></a>堆(特殊的完全二叉树)</h5><ul>
<li><span style="color: red">大根堆</span>：父节点总是大于子节点</li>
<li>小根堆：父节点总是小于子节点</li>
</ul>
<p><strong>堆的向下调整</strong>：</p>
<p> 当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变换成一个堆</p>
<h4 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2.堆排序"></a>2.堆排序</h4><p>堆排序大致上分为两步：</p>
<ul>
<li>建立堆(“农村包围城市”)</li>
<li>从根节点拿数</li>
<li>向下调整</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向下调整函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sift_big</span>(<span class="params">data_set,low,high</span>):	<span class="comment">#low指向根节点，high指堆的最后一个元素</span></span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    tmp = data_set[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt;= high <span class="keyword">and</span> data_set[j+<span class="number">1</span>] &gt; data_set[j]:</span><br><span class="line">            j += <span class="number">1</span> </span><br><span class="line">       	<span class="keyword">if</span> data_set[j] &gt; tmp:</span><br><span class="line">        	data_set[i] = data_set[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data_set[i] = tmp</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">   	<span class="keyword">else</span>:</span><br><span class="line">    	data_set[i] = tmp</span><br><span class="line">        </span><br><span class="line"><span class="comment">#堆排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">data_set</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(data_set)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment">#i表示建堆的时候调整的部分的根的下标</span></span><br><span class="line">        sift_big(data_set,i,n-<span class="number">1</span>)  <span class="comment">#至此，建堆完成</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment">#i指向当前堆的最后一个元素</span></span><br><span class="line">        data_set[<span class="number">0</span>], data_set[i] = data_set[i], data_set[<span class="number">0</span>]</span><br><span class="line">        sift_big(data_set,<span class="number">0</span>,i-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="heapq-基本操作"><a href="#heapq-基本操作" class="headerlink" title="heapq 基本操作"></a><strong>heapq 基本操作</strong></h3><h4 id="1-创建最小堆"><a href="#1-创建最小堆" class="headerlink" title="1. 创建最小堆"></a><strong>1. 创建最小堆</strong></h4><p><code>heapq</code> 直接在 Python <strong>列表</strong> 上操作，并不会创建新的数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python复制编辑import heapq</span><br><span class="line"></span><br><span class="line"># 定义一个列表</span><br><span class="line">nums = [5, 3, 8, 1, 2]</span><br><span class="line"></span><br><span class="line"># 转换为最小堆</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line">print(nums)  # 输出：[1, 2, 8, 3, 5]  （堆的内部结构，不是完全排序）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>heapify()</code> 只保证堆的特性：<strong>最小元素在索引 0</strong>，但不是完整排序的列表。</p>
</blockquote>
<hr>
<h4 id="2-插入元素"><a href="#2-插入元素" class="headerlink" title="2. 插入元素"></a><strong>2. 插入元素</strong></h4><p><code>heapq.heappush(heap, item)</code>：插入新元素，保持最小堆特性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python复制编辑heapq.heappush(nums, 4)</span><br><span class="line">print(nums)  # 输出：[1, 2, 4, 3, 5, 8]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-弹出最小元素"><a href="#3-弹出最小元素" class="headerlink" title="3. 弹出最小元素"></a><strong>3. 弹出最小元素</strong></h4><p><code>heapq.heappop(heap)</code>：删除并返回最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python复制编辑min_value = heapq.heappop(nums)</span><br><span class="line">print(min_value)  # 输出：1</span><br><span class="line">print(nums)  # 输出：[2, 3, 4, 5, 8]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-替换堆顶"><a href="#4-替换堆顶" class="headerlink" title="4. 替换堆顶"></a><strong>4. 替换堆顶</strong></h4><p><code>heapq.heapreplace(heap, item)</code>：<strong>删除堆顶元素</strong>，并插入 <code>item</code>，保证堆的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python复制编辑heapq.heapreplace(nums, 6)</span><br><span class="line">print(nums)  # 输出：[2, 3, 4, 6, 8]</span><br></pre></td></tr></table></figure>

<p>⚠️ <strong>与 <code>heappop + heappush</code> 的区别</strong>：</p>
<ul>
<li><code>heapreplace()</code> 是<strong>一步完成</strong>的，效率更高 <code>O(log n)</code></li>
<li><code>heappop() + heappush()</code> 是<strong>两步</strong>，需要 <code>2 * O(log n)</code></li>
</ul>
<hr>
<h4 id="5-获取最小的-K-个元素"><a href="#5-获取最小的-K-个元素" class="headerlink" title="5. 获取最小的 K 个元素"></a><strong>5. 获取最小的 K 个元素</strong></h4><p><code>heapq.nsmallest(k, iterable)</code>：返回 <strong>前 k 小</strong> 的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python复制编辑nums = [5, 3, 8, 1, 2]</span><br><span class="line">smallest_3 = heapq.nsmallest(3, nums)</span><br><span class="line">print(smallest_3)  # 输出：[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>类似的： <code>heapq.nlargest(k, iterable)</code>：返回 <strong>前 k 大</strong> 的元素。</p>
<h3 id="topk问题"><a href="#topk问题" class="headerlink" title="topk问题"></a>topk问题</h3><p>topk问题，指在n个数中，设计算法得到前k大的数(k&lt;n)</p>
<p>解决思路：</p>
<ul>
<li>排序后切片	O(nlogn)</li>
<li>LowB三人组      O(nk)</li>
<li><span style="color: red">堆排序</span>		O(nlogk)</li>
</ul>
<p>		</p>
<p>堆排序解决思路:</p>
<ul>
<li>选取前k个元素建立小根堆，根节点元素就是这个小根堆第k大的元素</li>
<li>从第k-1个元素开始，依次与根节点元素比较，小的略过，大的代替，并向下调整</li>
<li>重复第二步操作直到列表最后一个元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift_small</span>(<span class="params">data_set,low,high</span>):	<span class="comment">#low指向根节点，high指堆的最后一个元素</span></span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    tmp = data_set[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt;= high <span class="keyword">and</span> data_set[j+<span class="number">1</span>] &lt; data_set[j]:</span><br><span class="line">            j += <span class="number">1</span> </span><br><span class="line">       	<span class="keyword">if</span> data_set[j] &lt; tmp:</span><br><span class="line">        	data_set[i] = data_set[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data_set[i] = tmp</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">   	<span class="keyword">else</span>:</span><br><span class="line">    	data_set[i] = tmp</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">topk</span>(<span class="params">data_set,k</span>):</span><br><span class="line">    heap = data_set[<span class="number">0</span>:k]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift_small(heap,i,k-<span class="number">1</span>)</span><br><span class="line">   	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(data_set)):</span><br><span class="line">        <span class="keyword">if</span> data_set[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>] = data_set[i]</span><br><span class="line">            sift_small(heap,<span class="number">0</span>,k-<span class="number">1</span>)</span><br><span class="line">  	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</span><br><span class="line">        sift_small(heap,<span class="number">0</span>,i-<span class="number">1</span>)</span><br><span class="line"> 	<span class="keyword">return</span> heap       </span><br></pre></td></tr></table></figure>



<h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><p>假设列表分两段有序，将其合为一个有序列表的操作成为一次归并</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">data_set,low,mid,high</span>):</span><br><span class="line">  	i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    ltmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> data_set[i] &lt; data_set[j]:</span><br><span class="line">            ltmp.append(data_set[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ltmp.append(data_set[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"> 	<span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        ltmp.append(data_set[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"> 	<span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        ltmp.append(data_set[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">  	data_set[low:high+<span class="number">1</span>] = ltmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">data_set,low,high</span>):</span><br><span class="line">    <span class="keyword">if</span> low &lt; high: <span class="comment">#保证data_set至少两个元素</span></span><br><span class="line">        mid = (low + high)//<span class="number">2</span></span><br><span class="line">        merge_sort(data_set,low,mid)</span><br><span class="line">        merge_sort(data_set,mid+<span class="number">1</span>,high)</span><br><span class="line">        merge(data_set,low,mid,high)	</span><br><span class="line">        <span class="comment">#当列表仅有两个元素时第一次执行merge函数，这样一来，mid左右一定是有序的 </span></span><br></pre></td></tr></table></figure>

<h3 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7.希尔排序"></a>7.希尔排序</h3><p>希尔排序本质上是分组插入排序，每次分组之后，列表会接近于有序的状态，最后一次分组结束会完全有序</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort_gap</span>(<span class="params">data_set,gap</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,<span class="built_in">len</span>(data_set)): <span class="comment">#i表示无序区的牌的下标</span></span><br><span class="line">        tmp = data_set[i]</span><br><span class="line">        j = i-gap <span class="comment">#j表示手里摸到的牌的下标</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> data_set[j]&gt;tmp:</span><br><span class="line">            data_set[j+gap] = data_set[j]</span><br><span class="line">            j -= gap</span><br><span class="line">   		data_set[j+gap] = tmp</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">data_set</span>):</span><br><span class="line">    d = <span class="built_in">len</span>(data_set)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> d &gt;= <span class="number">1</span>:</span><br><span class="line">        insert_sort_gap(data_set,d)</span><br><span class="line">        d //= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，希尔排序的时间复杂度取决于gap的取值方式，详见<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p>
<h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h3><p>非比较排序，需要知道列表元素的上界和下界，适用于大量且密集的数据集合</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">data_set,low,high</span>):</span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(low,high+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> data_set:</span><br><span class="line">        count[val] += <span class="number">1</span></span><br><span class="line">  	data_set.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low,high+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> count[i] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(count[i]):</span><br><span class="line">                data_set.append(i)	<span class="comment">#这是循环操作，大部分语言通用</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">data_set,low,high</span>):</span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(low,high+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> data_set:</span><br><span class="line">        count[val] += <span class="number">1</span></span><br><span class="line">   	<span class="keyword">for</span> index, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(count):		</span><br><span class="line">        <span class="comment">#运用python内置函数enumerate，通过for循环截取count列表的下标和值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(val):</span><br><span class="line">            data_set.append(index)</span><br></pre></td></tr></table></figure>



<h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h3><p>桶排序，指的是知道上界与下界的情况下，以上下界为基准均分为若干个“桶”，每个“桶”的上下界也知道，进而在桶里使用计数排序或其他排序</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">data_set,n,low,high</span>):  <span class="comment">#n表示桶的个数</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> data_set:</span><br><span class="line">        i = <span class="built_in">min</span>((var-low)//((high-low)//n),n-<span class="number">1</span>)  <span class="comment">#防止var==high的情况</span></span><br><span class="line">        buckets[i].append(var)</span><br><span class="line">        <span class="comment">#分桶完成</span></span><br><span class="line"> 	<span class="comment">#以下可以等完全分完桶后对每一个buckets[i]进行计数排序或者其他排序，也可以边分桶边排序：</span></span><br><span class="line">    	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets[i])-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):  <span class="comment">#j表示buckets[i]中无序区最后一个元素的下标</span></span><br><span class="line">            <span class="keyword">if</span> buckets[i][j] &lt;buckets[i][j-<span class="number">1</span>]:</span><br><span class="line">                buckets[i][j], buckets[i][j-<span class="number">1</span>] = buckets[i][j-<span class="number">1</span>], buckets[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">   	sorted_data_set = []</span><br><span class="line">    <span class="keyword">for</span> buc <span class="keyword">in</span> buckets:</span><br><span class="line">        sorted_data_set.extend(buc)</span><br><span class="line">   	<span class="keyword">return</span> sorted_data_set</span><br></pre></td></tr></table></figure>

<p>桶排序的时间复杂度取决于数据的分布情况</p>
<h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><p>本质上是多关键词排序，实现方法用到分桶</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">data_set</span>):</span><br><span class="line">    max_num = <span class="built_in">max</span>(data_set)</span><br><span class="line">    it = <span class="number">0</span> <span class="comment"># it表示迭代轮数</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">10</span> ** it &lt;= max_num:</span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment">#0~9分十个桶</span></span><br><span class="line">        <span class="keyword">for</span> var <span class="keyword">in</span> data_set:</span><br><span class="line">            digit = (var // <span class="number">10</span> ** it) % <span class="number">10</span></span><br><span class="line">            buckets[digit].append(var)</span><br><span class="line">            <span class="comment">#分桶完成</span></span><br><span class="line">            data_set.clear()</span><br><span class="line">            <span class="keyword">for</span> buc <span class="keyword">in</span> buckets:</span><br><span class="line">                data_set.extend(buc)</span><br><span class="line">           	<span class="comment">#数据写回data_set</span></span><br><span class="line">            it += <span class="number">1</span></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2025/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-Python/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2025/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-python/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">数据结构与算法-数据结构-python</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2025
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="zhouyue&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>