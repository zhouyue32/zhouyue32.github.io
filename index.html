<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> zhouyue&#39;s blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">zhouyue&#39;s blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['会当凌绝顶，一览众山小', '且放白鹿青崖间，须行即骑访名山', '不畏浮云遮望眼，自缘身在最高层'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-[HNCTF 2022 WEEK2]e@sy_flower"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/25/%5BHNCTF%202022%20WEEK2%5De@sy_flower/"
    >[HNCTF 2022 WEEK2]e@sy_flower</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/25/%5BHNCTF%202022%20WEEK2%5De@sy_flower/" class="article-date">
  <time datetime="2024-12-25T08:05:45.000Z" itemprop="datePublished">2024-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AEwp-%E9%80%86%E5%90%91/">题目wp-逆向</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="HNCTF-2022-WEEK2-e-sy-flower"><a href="#HNCTF-2022-WEEK2-e-sy-flower" class="headerlink" title="[HNCTF 2022 WEEK2]e@sy_flower"></a>[HNCTF 2022 WEEK2]e@sy_flower</h1><p>​	打开附件，查壳32位无壳，直接进ida，发现很明显的花指令特征，修改为nop，F5反编译，<img src="/...%5Cimgs%5Cimage-20241127185828456.png" alt="image-20241127185828456"></p>
<p>很简单的加密逻辑，写出解密代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">&quot;c~scvdzKCEoDEZ[^roDICUMC&quot;</span></span><br><span class="line">cipher1 = <span class="built_in">list</span>(cipher)</span><br><span class="line">cipher2 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher1)):</span><br><span class="line">    cipher2 += <span class="built_in">chr</span>(<span class="built_in">ord</span>(cipher1[i]) ^ <span class="number">0x30</span>)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(cipher2),<span class="number">2</span>):</span><br><span class="line">    flag += cipher2[j+<span class="number">1</span>]</span><br><span class="line">    flag += cipher2[j]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>运行得到结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSSCTF&#123;Just_junk_Bytess&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/" rel="tag">花指令</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-[NSSRound#3 Team]jump_by_jump"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/25/%5BNSSRound#3%20Team%5Djump_by_jump/"
    >[NSSRound#3 Team]jump_by_jump</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/25/%5BNSSRound#3%20Team%5Djump_by_jump/" class="article-date">
  <time datetime="2024-12-25T08:05:45.000Z" itemprop="datePublished">2024-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AEwp-%E9%80%86%E5%90%91/">题目wp-逆向</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="NSSRound-3-Team-jump-by-jump"><a href="#NSSRound-3-Team-jump-by-jump" class="headerlink" title="[NSSRound#3 Team]jump_by_jump"></a>[NSSRound#3 Team]jump_by_jump</h1><p>​	打开附件，查壳32位无壳，进ida，找到主函数入口，发现有花指令导致无法被ida检测为函数：<img src="/...%5Cimgs%5Cimage-20241128162350102.png" alt="image-20241128162350102"></p>
<p>很典型的互补跳转跳过call指令导致ida没有识别出来junkcode。确定了E8call指令是junkcode将其nop，再反编译即可：<img src="/...%5Cimgs%5Cimage-20241128163111704.png" alt="image-20241128163111704"></p>
<p>注意：这里将E8nop掉之后后面的代码并不会被判断为指令，这是因为下文的汇编代码已经确定，ida无法判断从什么地方开始的汇编代码需要刷新，这里就需要自己判断main函数的范围并将其刷新。</p>
<p>另外，养成没事先“shift+F12”的习惯，有惊喜<img src="/...%5Cimgs%5Cimage-20241128163211139.png" alt="image-20241128163211139"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/" rel="tag">花指令</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-[HZNUCTF 2023 final]虽然他送了我玫瑰花"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/25/%5BHZNUCTF%202023%20final%5D%E8%99%BD%E7%84%B6%E4%BB%96%E9%80%81%E4%BA%86%E6%88%91%E7%8E%AB%E7%91%B0%E8%8A%B1/"
    >[HZNUCTF 2023 final]虽然他送了我玫瑰花</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/25/%5BHZNUCTF%202023%20final%5D%E8%99%BD%E7%84%B6%E4%BB%96%E9%80%81%E4%BA%86%E6%88%91%E7%8E%AB%E7%91%B0%E8%8A%B1/" class="article-date">
  <time datetime="2024-12-25T08:05:45.000Z" itemprop="datePublished">2024-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AEwp-%E9%80%86%E5%90%91/">题目wp-逆向</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="HZNUCTF-2023-final-虽然他送了我玫瑰花"><a href="#HZNUCTF-2023-final-虽然他送了我玫瑰花" class="headerlink" title="[HZNUCTF 2023 final]虽然他送了我玫瑰花"></a>[HZNUCTF 2023 final]虽然他送了我玫瑰花</h1><p>​	很有收获的一道题。</p>
<p>​	打开附件，查壳发现一个并不是PE文件而是ZIP归档的文件，将其拖到WinRAR</p>
<p>中解压缩出一个可执行PE文件，查壳发现32位无壳，进ida，发现是很典型的永真导致的花指令，NOP掉反编译如下：</p>
<p><img src="/...%5Cimgs%5Cimage-20241203200100321.png" alt="image-20241203200100321"></p>
<p>函数就不分析了，很简单的加密逻辑，唯二需要注意的两点是：</p>
<ul>
<li>位运算的优先级~&gt;&amp;&gt;^</li>
<li>xmmword定义的字符串并没有29个字单元，凡是这种隐藏起来的一律先用动调试一试，动调过程中需要查询的不是xmmword，而是v9，因为v9才是最直接的密文。</li>
</ul>
<p>写出解密代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cipher = [<span class="number">0x7F</span>, <span class="number">0x7E</span>, <span class="number">0x51</span>, <span class="number">0xCE</span>, <span class="number">0xFB</span>, <span class="number">0x4E</span>, <span class="number">0x7A</span>, <span class="number">0x24</span>, <span class="number">0xE8</span>, <span class="number">0xDF</span>,</span><br><span class="line">  <span class="number">0x59</span>, <span class="number">0x71</span>, <span class="number">0x26</span>, <span class="number">0xCA</span>, <span class="number">0xE1</span>, <span class="number">0x6C</span>, <span class="number">0x86</span>, <span class="number">0x21</span>, <span class="number">0xCC</span>, <span class="number">0xF5</span>,</span><br><span class="line">  <span class="number">0x28</span>, <span class="number">0x71</span>, <span class="number">0x14</span>, <span class="number">0xD8</span>, <span class="number">0xEF</span>, <span class="number">0x6E</span>, <span class="number">0x77</span>, <span class="number">0x62</span>, <span class="number">0xFA</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">    a = i % <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(cipher[i] ^ <span class="number">0x19</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> a == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(cipher[i]-<span class="number">18</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> a == <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(cipher[i]+<span class="number">16</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> a == <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>((cipher[i] &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0xff</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> a == <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(cipher[i] ^ <span class="number">0x80</span>),end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/" rel="tag">花指令</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-[GFCTF 2021]wordy"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/25/%5BGFCTF%202021%5Dwordy/"
    >[GFCTF 2021]wordy</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/25/%5BGFCTF%202021%5Dwordy/" class="article-date">
  <time datetime="2024-12-25T08:05:45.000Z" itemprop="datePublished">2024-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AEwp-%E9%80%86%E5%90%91/">题目wp-逆向</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="GFCTF-2021-wordy"><a href="#GFCTF-2021-wordy" class="headerlink" title="[GFCTF 2021]wordy"></a>[GFCTF 2021]wordy</h1><p>​	打开附件，进ida，发现有显著的花指令特征，</p>
<p><img src="/...%5Cimgs%5Cimage-20241127215043351.png" alt="image-20241127215043351"></p>
<p>将其改为nop，反编译，不对，再看下面一大串，这么多的数据不可能只是定义一串不知所谓的字符，可以猜测是否是代码未被ida识别，尝试”C“指令换为代码，错误，仔细看，发现<img src="/...%5Cimgs%5Cimage-20241127215345825.png" alt="image-20241127215345825"></p>
<p>大量存在花指令，怪不得无法编译，使用idapython编写脚本将它们换掉：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start=<span class="number">0x1135</span></span><br><span class="line">end=<span class="number">0x3100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,end):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i)==<span class="number">0xEB</span>:</span><br><span class="line">        <span class="keyword">if</span> get_wide_byte(i+<span class="number">1</span>)==<span class="number">0XFF</span>:</span><br><span class="line">            patch_byte(i,<span class="number">0x90</span>)</span><br></pre></td></tr></table></figure>

<p>换完如下：</p>
<p><img src="/...%5Cimgs%5Cimage-20241127215809584.png" alt="image-20241127215809584"></p>
<p>先别急着反编译，观察发现下面的结构大同小异，全是putchar函数，可以猜测是输出一些提示信息，不妨写脚本将提示信息提取出来：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start=<span class="number">0x1135</span></span><br><span class="line">end=<span class="number">0x3100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,end):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i)==<span class="number">0xC0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(idaapi.get_byte(i+<span class="number">2</span>)),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>有：</p>
<p><img src="/...%5Cimgs%5Cimage-20241127220008628.png" alt="image-20241127220008628"></p>
<p>提交flag发现正确</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/" rel="tag">花指令</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-[NSSRound#3 Team]jump_by_jump_revenge"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/25/%5BNSSRound#3%20Team%5Djump_by_jump_revenge/"
    >[NSSRound#3 Team]jump_by_jump_revenge</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/25/%5BNSSRound#3%20Team%5Djump_by_jump_revenge/" class="article-date">
  <time datetime="2024-12-25T08:05:45.000Z" itemprop="datePublished">2024-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AEwp-%E9%80%86%E5%90%91/">题目wp-逆向</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="NSSRound-3-Team-jump-by-jump-revenge"><a href="#NSSRound-3-Team-jump-by-jump-revenge" class="headerlink" title="[NSSRound#3 Team]jump_by_jump_revenge"></a>[NSSRound#3 Team]jump_by_jump_revenge</h1><p>​	打开附件，进ida，是花指令，没什么特别的，看看加密逻辑：</p>
<p><img src="/...%5Cimgs%5Cimage-20241128182312187.png" alt="image-20241128182312187"></p>
<p>分析如下：</p>
<ol>
<li>如果我们从最后一位向前推导，只要 i 大于 (i * i + 123) % 21 那么下标 (i * i + 123) % 21 对应的字符一定是已经经过变换的字符，我们可以直接从 “<del>4G</del>M:&#x3D;WV7iX,zlViGmu4?hJ0H-Q*” 中找到</li>
<li>如果我们从最后一位向前推导，当 i 小于 (i * i + 123) % 21 时，那么下标 (i * i + 123) % 21 对应的字符一定是我们已经在推导过程中得到的，如果我们将已经推导出的字符存在字符串 flag 中，那么我们可以直接从 flag 中找到</li>
<li>至于对 96 取模，我们可以以ASCII码值在合理范围内（33-125）为判断条件，通过少量的爆破得到正确的倍数</li>
</ol>
<p>写出解密代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">&quot;~4G~M:=WV7iX,zlViGmu4?hJ0H-Q*&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; (i * i + <span class="number">123</span>) % <span class="number">21</span>:</span><br><span class="line">            ascii_num = <span class="built_in">ord</span>(cipher[i]) - <span class="number">32</span> + j * <span class="number">96</span> - <span class="built_in">ord</span>(cipher[(i * i + <span class="number">123</span>) % <span class="number">21</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">32</span>&lt;= ascii_num &lt;=<span class="number">125</span>:</span><br><span class="line">                flag += <span class="built_in">chr</span>(ascii_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ascii_num = <span class="built_in">ord</span>(cipher[i]) - <span class="number">32</span> + j * <span class="number">96</span> - <span class="built_in">ord</span>(flag[<span class="built_in">len</span>(cipher)-<span class="number">1</span>-((i * i + <span class="number">123</span>) % <span class="number">21</span>)])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">32</span> &lt;= ascii_num &lt;= <span class="number">125</span>:</span><br><span class="line">                flag += <span class="built_in">chr</span>(ascii_num)</span><br><span class="line"><span class="built_in">print</span>(flag[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSSCTF&#123;Jump_b9_jump!_r3V3n9e&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/" rel="tag">花指令</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-[SWPUCTF 2023 秋季新生赛]Junk Code"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/25/%5BSWPUCTF%202023%20%E7%A7%8B%E5%AD%A3%E6%96%B0%E7%94%9F%E8%B5%9B%5DJunk%20Code/"
    >[SWPUCTF 2023 秋季新生赛]Junk Code</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/25/%5BSWPUCTF%202023%20%E7%A7%8B%E5%AD%A3%E6%96%B0%E7%94%9F%E8%B5%9B%5DJunk%20Code/" class="article-date">
  <time datetime="2024-12-25T08:05:45.000Z" itemprop="datePublished">2024-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A2%98%E7%9B%AEwp-%E9%80%86%E5%90%91/">题目wp-逆向</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="SWPUCTF-2023-秋季新生赛-Junk-Code"><a href="#SWPUCTF-2023-秋季新生赛-Junk-Code" class="headerlink" title="[SWPUCTF 2023 秋季新生赛]Junk Code"></a>[SWPUCTF 2023 秋季新生赛]Junk Code</h1><p>​	打开附件，junkcode，从名字都能听出来是花指令，查壳64位无壳，进ida，果不其然是花指令的显著特征：</p>
<p><img src="/...%5Cimgs%5Cimage-20241127154048548.png" alt="image-20241127154048548"></p>
<p>将jmp指令删除即可，最后反编译得到：</p>
<p><img src="/...%5Cimgs%5Cimage-20241127154134688.png" alt="image-20241127154134688"></p>
<p>很简单的加密，写出解密代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="built_in">list</span>(<span class="string">&quot;NRQ@PC&#125;Vdn4tHV4Yi9cd#\\&#125;jsXz3LMuaaY0&#125;nj]`4a5&amp;WoB4glB7~u&quot;</span>)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(cipher[i]) ^ (i % <span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSSCTF&#123;Qln5vKR1_n1ce!_you_r3MOved_7unk_c0d3!_oC6dhG1y&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/" rel="tag">花指令</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-加密与解密——解密篇2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%872/"
    >加密与解密——解密篇2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%872/" class="article-date">
  <time datetime="2024-12-21T10:11:19.000Z" itemprop="datePublished">2024-12-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="1-单向散列算法"><a href="#1-单向散列算法" class="headerlink" title="1.单向散列算法"></a>1.单向散列算法</h2><h2 id="2-对称加密算法"><a href="#2-对称加密算法" class="headerlink" title="2.对称加密算法"></a>2.对称加密算法</h2><h3 id="1-RC4流密码"><a href="#1-RC4流密码" class="headerlink" title="1.RC4流密码"></a>1.RC4流密码</h3><ul>
<li><p>算法原理：RC4生成一种称为密钥流的伪随机流，它与明文通过异或操作混合，从而达到加密的效果。解密时与密文进行异或操作。其密钥流由两部分组成，分别是KSR和PRGA。</p>
</li>
<li><p>KSA（the Key-Scheduling Algorithm）</p>
<ul>
<li><p>初始化256字节的数组S</p>
<ul>
<li>将S线性填充</li>
<li>用种子密钥对另一表K进行填充</li>
<li>用K表对S表进行初始置换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span>:</span><br><span class="line">       S[i] = i</span><br><span class="line">    </span><br><span class="line">   j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span>:</span><br><span class="line">       j = (j + S[i] + K[i]) mod <span class="number">256</span></span><br><span class="line">       swap(S[i], S[j])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PRGA</p>
<ul>
<li><p>密钥流的生成</p>
<ul>
<li>从S表中随机获取值组成密钥流与明文异或</li>
<li>伪随机数的生成</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> r=<span class="number">0</span> to len <span class="keyword">do</span></span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    swap(S[i],S[j])</span><br><span class="line">    t=(S[i]+S[j])%<span class="number">256</span></span><br><span class="line">    k[r]=S[t]</span><br></pre></td></tr></table></figure>

<p>注：一旦密钥流生成，种子密钥就失去作用。</p>
<p>(Python实现见PythonProject&#x2F;RC4.py)</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-分组加密"><a href="#2-分组加密" class="headerlink" title="2.分组加密"></a>2.分组加密</h3><h4 id="1-电码本模式（ECB）"><a href="#1-电码本模式（ECB）" class="headerlink" title="1.电码本模式（ECB）"></a>1.电码本模式（ECB）</h4><p><img src="/./../imgs/image-20241112150004848.png" alt="image-20241112150004848"></p>
<p>电码本模式的重点在于，使用<strong>相同的</strong>密钥对进行分组的<strong>等长</strong>的明文<strong>单独加密</strong>。</p>
<ul>
<li><p>优点：每个数据块<strong>独立</strong>加密，可<strong>并行</strong>加密，实现简单。</p>
</li>
<li><p>缺点：相同明文会产生相同的密文，不具备数据完整保护性。也就是说，它并不具备混淆和扩散的能力，攻击者可以通过相同的密文块推断明文的一些信息。</p>
</li>
<li><p>适用场景：短消息的加密传输，比如对加密密钥的传输。</p>
</li>
</ul>
<h4 id="2-密文分组链接模式（CBC）"><a href="#2-密文分组链接模式（CBC）" class="headerlink" title="2.密文分组链接模式（CBC）"></a>2.密文分组链接模式（CBC）</h4><p><img src="/./../imgs/image-20241112151241702.png" alt="image-20241112151241702"></p>
<p>密文分组链接模式的重点在于：</p>
<ul>
<li>将前一个密文块与当前明文块进行异或运算<strong>之后</strong>再加密。</li>
<li>初始向量用于第一个块的加密。</li>
<li>加密算法的输入是上一个密文分组和当前明文分组的<strong>异或结果</strong>。</li>
</ul>
<p><img src="/./../imgs/image-20241112151738547.png" alt="image-20241112151738547"></p>
<p>优缺点及适用场景：  </p>
<ul>
<li>优点：每个密文块的加密依赖前一个密文块，具备数据完整保护性。</li>
<li>缺点：传输过程中的错误会传播下去，不适合并行处理。 </li>
<li>适用场景：适用于常规文件加密，非实时加密等场景。</li>
</ul>
<h4 id="3-密文反馈模式-CFB"><a href="#3-密文反馈模式-CFB" class="headerlink" title="3.密文反馈模式(CFB)"></a>3.密文反馈模式(CFB)</h4><p><img src="/./../imgs/image-20241112152305771.png" alt="image-20241112152305771"></p>
<p>密文反馈模式的重点在于：</p>
<ul>
<li><p>将<strong>前一个密文块</strong>作为<strong>加密算法的输入</strong>。</p>
</li>
<li><p>加密算法生成一个<strong>密钥流</strong>，再与当前的明文块进行<strong>异或</strong>得到密文块。</p>
</li>
<li><p>明文本身并<strong>不在</strong>加密算法中。</p>
</li>
</ul>
<p>优缺点及适用场景：  </p>
<ul>
<li>优点：可以处理<strong>任意长度</strong>的数据，<strong>实时</strong>加密解密，可以<strong>部分解密</strong>数据。</li>
<li>缺点：错误传播的敏感性，不适合并行处理，需要保证初始向量的唯一性和完整性。</li>
</ul>
<h4 id="4-输出反馈模式（OFB）"><a href="#4-输出反馈模式（OFB）" class="headerlink" title="4.输出反馈模式（OFB）"></a>4.输出反馈模式（OFB）</h4><p><img src="/./../imgs/image-20241112155548523.png" alt="image-20241112155548523"></p>
<p>输出反馈模式的重点在于：</p>
<ul>
<li><p>前一个加密算法的输出作为下一个加密算法的输入</p>
</li>
<li><p>加密后得到密钥流</p>
</li>
<li><p>密钥流与明文进行异或得到密文块</p>
</li>
</ul>
<p> <img src="/./../imgs/image-20241112155958301.png" alt="image-20241112155958301"></p>
<p>CFB和OFB模式的唯一不同在于密钥流的获取方式不同。</p>
<p>优缺点及适用场景：</p>
<ul>
<li><p>优点：长度可变，实时加密，错误传播敏感。</p>
</li>
<li><p>缺点：传输错误不可恢复 ，无法提供数据完整性保护，不支持并行加密。</p>
</li>
<li><p>适用场景：实时数据流加密和随机访问的场景。</p>
</li>
</ul>
<h4 id="5-计数器模式（CTR）"><a href="#5-计数器模式（CTR）" class="headerlink" title="5.计数器模式（CTR）"></a>5.计数器模式（CTR）</h4><p><img src="/./../imgs/image-20241112212818757.png" alt="image-20241112212818757"></p>
<p>计数器模式重点在于：</p>
<ul>
<li>每一个明文分组都与一个<strong>经过加密</strong>的<strong>计数器异或</strong>。</li>
<li>对于后续的分组，计数器自增</li>
<li>加密算法针对的是计数器</li>
</ul>
<p>优缺点及适用场景：</p>
<p>优点：</p>
<ul>
<li>可以并行处理</li>
<li>随机访问，根据计数器的值和密钥生成密钥流</li>
<li>不受错误传播的影响</li>
</ul>
<p>缺点：</p>
<ul>
<li>计数器必须唯一</li>
<li>密钥流和明文的相关性较弱</li>
</ul>
<p>适用场景：</p>
<ul>
<li>并行加密</li>
<li>随机访问</li>
<li>实时加密</li>
</ul>
<hr>
<p><img src="/./../imgs/image-20241112213505563.png" alt="image-20241112213505563"></p>
<hr>
<h3 id="3-TEA系列加密算法"><a href="#3-TEA系列加密算法" class="headerlink" title="3.TEA系列加密算法"></a>3.TEA系列加密算法</h3><h3 id="4-DES加密算法"><a href="#4-DES加密算法" class="headerlink" title="4.DES加密算法"></a>4.DES加密算法</h3><p>​	DES是一个经典的分组加密算法，通常一组是64位的数据，以电码本模式加密以下是加密步骤：</p>
<ol>
<li><strong>密钥生成</strong>：首先，从用户提供的64位密钥中提取出56位有效密钥（每第8位用于奇偶校验），然后生成16个子密钥，供每轮加密使用。</li>
<li><strong>初始置换（IP）</strong>：对64位输入数据进行初始置换，重排列数据的位。</li>
<li><strong>16轮加密</strong>：进行16轮的 Feistel 结构加密。在每一轮中，数据被分为左右两个32位部分，右半部分经过扩展置换和与当前轮的子密钥进行异或运算，经过S-盒替换后，再经过P-盒置换，最后与左半部分进行异或运算，交换左右部分。</li>
<li><strong>逆初始置换（IP⁻¹）</strong>：在完成16轮加密后，对数据进行逆初始置换，得到最终的密文</li>
</ol>
<h4 id="1-密钥生成"><a href="#1-密钥生成" class="headerlink" title="1.密钥生成"></a>1.密钥生成</h4><p>​	种子密钥为64位且唯一，经过两轮置换选择变为48位：</p>
<p><img src="/./../imgs/image-20241115191827253.png" alt="image-20241115191827253"></p>
<ul>
<li><p>PC1置换：</p>
<p>PC1置换将8位校验位去除，并进行比特重排打乱顺序</p>
<p><img src="/./../imgs/image-20241115191945874.png" alt="image-20241115191945874"></p>
</li>
<li><p>将PC1置换后的56位中间密钥分为C,D两部分，经过16次迭代，每次迭代进行不同次数的循环左移，得到打乱顺序后的56位中间密钥,值得注意的是，<strong>每一次迭代都是在前一次产生的C<sub>i</sub>，D<sub>i</sub>的基础上进行循环左移</strong>，生成C<sub><strong>i+1</strong></sub>，D<sub><strong>i+1</strong></sub>且这里的每一次迭代都生成一个中间密钥M-key<sub><strong>i</strong></sub>，只有这样才能保证能输出<strong>16个不同</strong>子密钥。</p>
<p><img src="/./../imgs/image-20241115192505906.png" alt="image-20241115192505906"></p>
</li>
<li><p>PC2置换：</p>
</li>
</ul>
<p>​	使用PC2置换将56位中间密钥M-key<sub><strong>i</strong></sub>去除8位并打乱</p>
<p><img src="/./../imgs/image-20241115192621065.png" alt="image-20241115192621065"></p>
<ul>
<li>得到48位密钥key<sub><strong>i</strong></sub>。</li>
</ul>
<h4 id="2-初始置换"><a href="#2-初始置换" class="headerlink" title="2.初始置换"></a>2.初始置换</h4><p>​	使用IP(Initial Permutation)置换对明文进行比特重排。</p>
<p><img src="/./../imgs/image-20241115193345521.png" alt="image-20241115193345521"></p>
<h4 id="3-16轮迭代加密"><a href="#3-16轮迭代加密" class="headerlink" title="3.16轮迭代加密"></a>3.16轮迭代加密</h4><p>​	进行16轮的 Feistel 结构加密。</p>
<h5 id="Feistel结构加密"><a href="#Feistel结构加密" class="headerlink" title="Feistel结构加密"></a>Feistel结构加密</h5><p>​	Feistel结构加密是指在每一轮中，数据被分为左右两个32位部分A<sub><strong>i</strong></sub>，B<sub><strong>i</strong></sub>，左半部分变不变，右半部分经过<strong>E扩展置换</strong>和与当前轮的<strong>子密钥进行异或运算</strong>，经过<strong>S-盒替换</strong>后，再经过<strong>P-盒置换</strong>，最后<strong>与左半部分进行异或运算</strong>，交换左右部分。</p>
<img src="./../imgs/image-20241115195530995.png" alt="image-20241115195530995" style="zoom:67%;" />

<h6 id="1-E扩展置换"><a href="#1-E扩展置换" class="headerlink" title="1.E扩展置换"></a>1.E扩展置换</h6><p>​	E扩展置换将32位的B<sub><strong>i</strong></sub>置换为48位的数据。而将32位扩展至48位关键在于将32位均分为8组，每一组的4位数据如何扩展至6位。</p>
<p>​	E扩展将原4位数据前后各加一位以此达到扩展的目的，前一位来自于前一组的最后一位，后一位来自后一组的第一位。第一组的前一位来自最后一组的最后一位，最后一组的后一位来自第一组的第一位。最终得到EB<sub><strong>i</strong></sub>以下是一个示例：</p>
<img src="./../imgs/image-20241115195942892.png" alt="image-20241115195942892" style="zoom: 50%;" />

<h6 id="2-与子密钥异或"><a href="#2-与子密钥异或" class="headerlink" title="2.与子密钥异或"></a>2.与子密钥异或</h6><p>​	EB<sub><strong>i</strong></sub>^key<sub><strong>i</strong></sub></p>
<h6 id="3-S-盒压缩"><a href="#3-S-盒压缩" class="headerlink" title="3.S-盒压缩"></a>3.S-盒压缩</h6><p>​	S-盒压缩将EB<sub><strong>i</strong></sub>均分为8组，将头尾数据分别转化为10进制数，以头尾十进制作行数，中间十进制数作列数，在S-盒表中查找对应数据，得到的十进制数转化为2进制就得到压缩后的4位数据，拼接起来得到32位数据SEB<sub><strong>i</strong></sub>。</p>
<p><img src="/./../imgs/image-20241115201231380.png" alt="image-20241115201231380"></p>
<h6 id="4-P-盒替换"><a href="#4-P-盒替换" class="headerlink" title="4.P-盒替换"></a>4.P-盒替换</h6><p>​	将SEB<sub><strong>i</strong></sub>进行P-盒置换得到PSEB<sub><strong>i</strong></sub>。</p>
<p><img src="/./../imgs/image-20241115201544932.png" alt="image-20241115201544932"></p>
<h6 id="5-与Ai进行异或"><a href="#5-与Ai进行异或" class="headerlink" title="5.与Ai进行异或"></a>5.与A<sub><strong>i</strong></sub>进行异或</h6><p>​	将PSEB<sub><strong>i</strong></sub>与A<sub><strong>i</strong></sub>进行异或，赋值给A<sub><strong>i+1</strong></sub>，将A<sub><strong>i</strong></sub>赋值给B<sub><strong>i+1</strong></sub>。</p>
<h4 id="4-逆初始置换（IP⁻¹）"><a href="#4-逆初始置换（IP⁻¹）" class="headerlink" title="4.逆初始置换（IP⁻¹）"></a>4.逆初始置换（IP⁻¹）</h4><p><img src="/./../imgs/image-20241115202459825.png" alt="image-20241115202459825"></p>
<h2 id="3-公开密钥加密算法"><a href="#3-公开密钥加密算法" class="headerlink" title="3.公开密钥加密算法"></a>3.公开密钥加密算法</h2><h2 id="4-其他算法"><a href="#4-其他算法" class="headerlink" title="4.其他算法"></a>4.其他算法</h2><h3 id="2-Base64编码"><a href="#2-Base64编码" class="headerlink" title="2.Base64编码"></a>2.Base64编码</h3><p>​	Base64编码将二进制数据编码为可显示的字母和数字，用于传送图形，声音和传真等非文本数据，<strong>常用于MIME电子邮件格式</strong>中。其使用含有65个字符的ASCII字符集，并用6个进制位表示一个可显示字符。</p>
<p><img src="/./../imgs/image-20241107183531620.png" alt="image-20241107183531620"></p>
<ul>
<li><p>Base64编过程：</p>
<ul>
<li><p>以3个字节为一组，将第一个字节放在24位缓冲区的高8位，第二个放在中8位，第三个放在低8位。</p>
</li>
<li><p>对24位缓冲区以6位为索引，高位优先，从字符串“ABCDEFGHIJKLMN<br>OPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;”中取出相应元素作为输出</p>
</li>
<li><p>如果仅有一字节或两字节输入，那么只使用输出的2~3个字节，其余用”&#x3D;“填充</p>
</li>
<li><p>“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;”即为字符集</p>
<p><img src="/./../imgs/image-20241107184614133.png" alt="image-20241107184614133"></p>
</li>
</ul>
</li>
</ul>
<p>（关于Base64的解码程序，详见PythonProject1&#x2F;Base64.py）</p>
<h3 id="3-Hex编码"><a href="#3-Hex编码" class="headerlink" title="3.Hex编码"></a>3.Hex编码</h3><p>​	Hex编码将数据以16进制数表示。</p>
<p>​	编码方式：每个字节（8位）的数据被转换为两个Hex字符。第一个字符代表字节的高4位，第二个字符代表字节的低4位。</p>
<p>​	字符集：”0123456789abcdef”</p>
<p>​	(关于Hex编码的解码程序，详见Python&#x2F;Hex.py)</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-加密与解密——解密篇1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%871/"
    >加密与解密——解密篇1</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%871/" class="article-date">
  <time datetime="2024-12-21T10:09:14.000Z" itemprop="datePublished">2024-12-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="32位逆向技术"><a href="#32位逆向技术" class="headerlink" title="32位逆向技术"></a>32位逆向技术</h1><h2 id="1-启动函数"><a href="#1-启动函数" class="headerlink" title="1.启动函数"></a>1.启动函数</h2><ul>
<li>编写win32程序时必须在源码里实现WinMain函数。但Windows程序的执行并不从WinMain函数开始。</li>
<li>在WinMain函数启动之前，首先被执行的是启动函数的相关代码，这项工作由编译器完成。</li>
<li>启动源码可以被修改</li>
<li><em><strong><u>在分析程序的过程中，可以略过启动代码，将重心放在WinMain函数体上</u></strong></em></li>
</ul>
<h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h2><p>​	程序都过程中，是由具有不同功能的函数组成的，因此，在逆向的分析中，应将目光更多放在函数的识别及参数的传递上，让注意力集中在某一块代码上。</p>
<p>​	函数作为一个程序模块，用于实现特定的功能。一个函数包括函数名，入口参数，返回值，函数功能等部分。</p>
<hr>
<h3 id="1-函数的识别"><a href="#1-函数的识别" class="headerlink" title="1.函数的识别"></a>1.函数的识别</h3><p>​	程序调用函数，调用完毕后又返回程序，这就要求函数能够“知道”返回的程序的地址。这也是函数与其他跳转指令的区别。</p>
<p>​	事实上，调用函数的代码中保存了一个返回地址，该地址会<strong>与参数一起传递</strong>给被调用的函数。</p>
<p>​	有多种方法实现该功能，在绝大多数情况下，编译器使用call和ret指令调用函数以及返回调用位置，这也意味这在分析时可以对关键指令进行查找进而确定函数体。</p>
<hr>
<h3 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2.函数的参数"></a>2.函数的参数</h3><p>​	函数的传递有三种方式：栈方式，寄存器方式以及通过全局变量进行隐含参数传递的方式。</p>
<h4 id="1-利用栈传递参数"><a href="#1-利用栈传递参数" class="headerlink" title="1.利用栈传递参数"></a>1.利用栈传递参数</h4><p>​	栈作为“后进先出”的储存区，ESP指向栈顶，也就是栈中第一个可用的数据项。在函数调用过程中，调用者将函数依次压入栈，然后调用函数。调用结束以后，由调用者或函数本身修改栈，使栈恢复原样（即平衡栈数据）。</p>
<p>​	那么，显然地，在栈传参时有两个问题：</p>
<p>​	当参数多于一个的时候，按什么顺序压入栈？</p>
<p>​	函数调用结束后，谁来平衡栈？</p>
<p>这些需要有一个都认可的约定，这种在程序设计语言中为了实现函数调用而建立的协议称为调用约定（Calling Convention），这种协议规定了函数中的参数传送方式，参数是否可变和由谁处理栈的问题。</p>
<hr>
<h5 id="常用的调用约定"><a href="#常用的调用约定" class="headerlink" title="常用的调用约定"></a><a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">常用的调用约定</a></h5><ul>
<li>__cdecl:参数按照从右至左的顺序入栈，由调用者负责平衡栈。</li>
</ul>
<p>__cdecl(C Declaration)是C&#x2F;C++和MFC程序默认的调用约定，也可以在函数声明时加上__cdecl关键字来手动指定</p>
<ul>
<li>__pascall：参数从左至右入栈，要求被调用函数负责平衡栈。</li>
<li>__stdcall：__stdcall（Standard Call）是Win32API采用的约定方式，意为“标准调用”，采用C规范的参数入栈顺序和pascall调用约定的调整栈指针方式。</li>
</ul>
<p>​	<a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">图形说明</a></p>
<h5 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h5><ol>
<li>非优化方式：使用EBP间接寻址</li>
<li>优化方式：直接使用ESP寻址</li>
</ol>
<p>（忘了就再回去看《加密与解密》p105~107）</p>
<h4 id="2-利用寄存器传参"><a href="#2-利用寄存器传参" class="headerlink" title="2.利用寄存器传参"></a>2.利用寄存器传参</h4><p>​	寄存器传参的方式没有特定标准，取决于编译器开发人员，但都在不对兼容性进行声明的情况下遵循相应的规范，即Fastcall。顾名思义，快速。</p>
<p>​	<a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">不同编译器实现的Fastcall有所不同</a></p>
<ul>
<li>值得注意的是，另一个调用规范也用到了寄存器—thiscall</li>
<li>在采用thiscall调用约定时，参数从右至左入栈，函数负责平衡栈，仅通过一个寄存器ECX传送一个额外的参数—this指针。</li>
</ul>
<h4 id="3-名称修饰约定"><a href="#3-名称修饰约定" class="headerlink" title="3.名称修饰约定"></a>3.<a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">名称修饰约定</a></h4><hr>
<h3 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3.函数的返回值"></a>3.函数的返回值</h3><p>​	函数被调用后返回一个或多个<strong>执行结果</strong>（不单指数值），称为函数返回值。返回值最常见的是return操作符，还有通过参数按传引用方式，通过全局变量返回等。</p>
<h4 id="1-用return操作符返回值"><a href="#1-用return操作符返回值" class="headerlink" title="1.用return操作符返回值"></a>1.用return操作符返回值</h4><p>​	一般情况下，函数的返回值放在EAX寄存器中返回，若处理结果的大小超出EAX寄存器的容量，那么其高32位存放在EDX中。</p>
<h4 id="2-通过参数按传引用方式返回值"><a href="#2-通过参数按传引用方式返回值" class="headerlink" title="2.通过参数按传引用方式返回值"></a>2.通过参数按传引用方式返回值</h4><p>​	给函数传递参数的方式有两种，传值和传引用。</p>
<p>​	进行传值调用时，会建立参数的一份复本，将其传入函数，在调用函数中修改参数值的复本不会影响原始的变量值。（传值）</p>
<p>​	进行传引用调用时，允许调用函数修改原始变量的值。（传指针）</p>
<p>（不懂再看《加密与解密》p110~111）</p>
<hr>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h2><p>​	数据结构是计算机储存，组织数据的方式。在进行逆向分析时，确定数据结构以后，算法就很容易得到了。当然，有时也会根据特定的算法来判断数据结构，以下是一些常见的数据结构以及汇编语言的实现方式。</p>
<h3 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h3><p>​	局部变量是函数内定义的一个变量，其作用域和生命周期局限于所在函数。使用局部变量使得程序模块化封装成为可能。从汇编的角度来看，局部变量分配空间时，通常会使用栈和寄存器。</p>
<h4 id="1-利用栈存放局部变量"><a href="#1-利用栈存放局部变量" class="headerlink" title="1.利用栈存放局部变量"></a>1.利用栈存放局部变量</h4><p>​	详见《加密与解密》p112</p>
<h4 id="2-利用寄存器存放局部变量"><a href="#2-利用寄存器存放局部变量" class="headerlink" title="2.利用寄存器存放局部变量"></a>2.利用寄存器存放局部变量</h4><p>​	除去栈占用的ESP,EBP两个寄存器，编译器会尽可能多地使用剩下的6个通用寄存器，这样可以提高程序效率，减少内存消耗。如果寄存器不够用，才考虑栈储存参数。在分析时注意，局部变量的生存周期短，必须及时确定当前寄存器存放的是哪个变量。</p>
<hr>
<h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2.全局变量"></a>2.全局变量</h3><p>​	全局变量作用于整个程序，放在全局变量的内存区中。局部变量存在于函数的栈区，函数调用结束后就消失。大多数程序中，常数一般放在全局变量中，例如一些注册版标记，测试版标记等。</p>
<p>​	全局变量通常位于数据区块（.idata）的一个固定地址处，也就是说，当程序需要访问全局变量时，一般会用一个固定的硬编码地址<strong>直接</strong>对内存寻址，这也意味着，全局变量更容易被识别。</p>
<p>​	全局变量可以被同一文件中的所有函数修改，如果某一个函数改变了全局变量的值，就可以影响其他函数。因此，全局变量可以实现传参和函数返回值。</p>
<p>​	它<strong>永远</strong>占据有内存的“一席之地”，而不像局部变量每次需要时都需要“申请”。</p>
<h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><p>​	数组是相同数据类型的集合，它们在内存中按顺序连续存放在一起。在汇编状态下访问输在一般是通过基址加变址寻址实现的。</p>
<p>​	在内存中，数组可以存在于栈，数据段及动态内存中。</p>
<p>​	一般来说，间接寻址出现在给一些数组或结构赋值的情况下，寻址形式一般为[基址+n]。基址可以为常量，也可以是寄存器，总之为定值。</p>
<hr>
<h2 id="4-虚函数"><a href="#4-虚函数" class="headerlink" title="4.虚函数"></a>4.虚函数</h2><p>​	虚函数是在程序运行时定义的函数。虚函数的地址不能在编译时确定，只能在调用<strong>即将进行</strong>时确定。</p>
<p>​	所有对虚函数的引用通常放在一个专用数组——虚函数表（Virtual Table，VTBL）中，数组的每个元素存放的就是“类”中虚函数的地址。</p>
<p>​	调用虚函数时，先取出虚函数表指针，得到虚函数表的地址，再根据这个地址到虚函数表中取出该函数的地址，最后调用该函数。</p>
<h2 id="5-控制语句"><a href="#5-控制语句" class="headerlink" title="5.控制语句"></a>5.控制语句</h2><h3 id="IF-THEN-ELSE语句"><a href="#IF-THEN-ELSE语句" class="headerlink" title="IF-THEN-ELSE语句"></a>IF-THEN-ELSE语句</h3><p>​	通常使用cmp+条件跳转实现，但许多情况下会优化使用test指令</p>
<h3 id="SWITCH-CASE语句"><a href="#SWITCH-CASE语句" class="headerlink" title="SWITCH-CASE语句"></a>SWITCH-CASE语句</h3><p>​	switch-case语句是多分支选择语句。编译之后的SWICTH语句本质是多个IF-THEN语句的嵌套。</p>
<h3 id="转移指令机器码的计算"><a href="#转移指令机器码的计算" class="headerlink" title="转移指令机器码的计算"></a>转移指令机器码的计算</h3><ol>
<li>**短转移 (Short Jump)**：无条件转移和条件转移的机器码通常为2字节，转移范围在-128到127字节内。</li>
<li>**长转移 (Long Jump)**：无条件转移的机器码为5字节，条件转移的机器码为6字节。条件转移的情况包括两类，2字节表示某转移偏移量，4字节表示目标位置。为了代码优化，CPU提供了无符号1字节偏移。</li>
<li>**子程序调用指令 (call)**：call指令用于调用子程序，一类是call label，类似于长转移，另一类常用于涉及寄存器和栈的操作，例如“call dword ptr [eax+2]”。</li>
</ol>
<p>条件转移指令由于16位CPU的遗留问题，通常只能进行255字节的转移。</p>
<p>转移指令机器码由转移类型和转移的位移量共同决定。</p>
<h3 id="纯算法实现逻辑判断"><a href="#纯算法实现逻辑判断" class="headerlink" title="纯算法实现逻辑判断"></a>纯算法实现逻辑判断</h3><p>​	在优化时，往往在不改变逻辑的情况下，用数学技巧将代码中的逻辑分支语句转换为算术操作，减少条件转移指令的出现，提高CPU性能。</p>
<hr>
<h2 id="6-循环语句"><a href="#6-循环语句" class="headerlink" title="6.循环语句"></a>6.循环语句</h2><p>​	高级语言中可以进行反向引用的一种语言形式，可以通过这种特性将其识别出来。</p>
<p>​	一般使用ECX作为计数器。或者“test eax，eax”等其他指令。</p>
<h2 id="7-数学运算符"><a href="#7-数学运算符" class="headerlink" title="7.数学运算符"></a>7.数学运算符</h2><p>​	此处仅涉及整数的四则运算的优化方式</p>
<h3 id="1-整数的加减"><a href="#1-整数的加减" class="headerlink" title="1.整数的加减"></a>1.整数的加减</h3><p>​	一般使用add，sub指令，但在一些优化方案中，常常使用lea指令来代替。</p>
<p>​	lea指令允许用户在一个时钟内完成对c&#x3D;a+b+idata的计算。其中c，a，b都是寄存器。“lea c，[a+b+idata]”</p>
<p>​	注意，lea是直接取的地址加到c中，而不是取的值。</p>
<h3 id="2-整数的乘法"><a href="#2-整数的乘法" class="headerlink" title="2.整数的乘法"></a>2.整数的乘法</h3><p>​	一般使用mul，imul指令，但运行速度慢。在优化方案中，编译器倾向于使用其他可以完成相同功能的指令来代替。</p>
<p>​	比如：若要进行2的幂运算，将使用shl指令进行左移操作。</p>
<p>​	再比如：5*eax可以写成lea eax，[eax+4*eax]。lea指令可以实现寄存器乘以2，4或8的操作。</p>
<h3 id="3-整数的除法"><a href="#3-整数的除法" class="headerlink" title="3.整数的除法"></a>3.整数的除法</h3><p>​	一般使用div，idiv指令，但除法运算的代价相当高，几乎消耗比乘法多十倍的CPU时钟。</p>
<p>​	当被除数是未知数时，那么编译器直接使用div指令。</p>
<p>​	若除数与被除数是常量的情况下则会使用一些技巧来替换div，idiv指令。</p>
<p>比如：当除数是2的幂时，会直接使用shr指令进行右移操作。而位移指令只消耗一个时钟。</p>
<hr>
<h2 id="8-文本字符串"><a href="#8-文本字符串" class="headerlink" title="8.文本字符串"></a>8.文本字符串</h2><p>​	字符串的识别与分析时软件逆向的重要步骤，特别是在对序列号的分析中。</p>
<h3 id="1-字符串储存格式"><a href="#1-字符串储存格式" class="headerlink" title="1.字符串储存格式"></a>1.字符串储存格式</h3><h4 id="（1）C字符串"><a href="#（1）C字符串" class="headerlink" title="（1）C字符串"></a>（1）C字符串</h4><p>​	也称“ASCCIIZ字符串”，广泛运用于Windows和UNIX操作系统，“Z”表示以’\0’为结束标志</p>
<h4 id="（2）DOS字符串"><a href="#（2）DOS字符串" class="headerlink" title="（2）DOS字符串"></a>（2）DOS字符串</h4><p>​	以“$”为结束标志，少见。</p>
<h4 id="（3）PASCAL字符串"><a href="#（3）PASCAL字符串" class="headerlink" title="（3）PASCAL字符串"></a>（3）PASCAL字符串</h4><p>​	无终止符，但在字符串开头使用一字节来定义字符串长度，因此最长不超过255字节，少见。</p>
<h4 id="（4）Delphi字符串"><a href="#（4）Delphi字符串" class="headerlink" title="（4）Delphi字符串"></a>（4）Delphi字符串</h4><p>​	本质是PASCAL字符串的变体，区别在于在字符串头部用2或4个字节定义长度。（双字节Delphi和四字节Delphi）。</p>
<h3 id="2-字符寻址指令"><a href="#2-字符寻址指令" class="headerlink" title="2.字符寻址指令"></a>2.字符寻址指令</h3><p>​	略</p>
<h3 id="3-大小写切换"><a href="#3-大小写切换" class="headerlink" title="3.大小写切换"></a>3.大小写切换</h3><p>​	遵循ASCII码表</p>
<h3 id="4-计算字符串长度"><a href="#4-计算字符串长度" class="headerlink" title="4.计算字符串长度"></a>4.计算字符串长度</h3><hr>
<h2 id="9-指令修改技巧"><a href="#9-指令修改技巧" class="headerlink" title="9.指令修改技巧"></a>9.指令修改技巧</h2><h1 id="64位逆向技术"><a href="#64位逆向技术" class="headerlink" title="64位逆向技术"></a>64位逆向技术</h1><h2 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h2><p>​	本节所说的x64是AMD64与Intel64的合称，是指与现有x86兼容的64位CPU。在64位系统中，内存地址为64位。x64位环境下的寄存器相较于32位有一些变化。</p>
<p>​	x64通用寄存器的名字由Exx改为Rxx，大小扩展至64位，数量增加了8个（R8~R15），扩充了8个128位的XMM寄存器（在64位程序中，XMM寄存器常用于优化代码）。</p>
<p>​	64位寄存器与32位兼容，例如RAX（64位），EAX（低32位），AX（低16位），AH，AL。新扩展的寄存器高低位访问使用D,W,B后缀，如R8（64位），R8D（低32位），R8W（低16位），R8B（低8位）。</p>
<p>​	<strong>64位系统寄存器</strong><img src="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》\64位系统寄存器.png" alt="64位系统寄存器"></p>
<h2 id="2-函数-1"><a href="#2-函数-1" class="headerlink" title="2.函数"></a>2.函数</h2><h3 id="1-栈平衡"><a href="#1-栈平衡" class="headerlink" title="1.栈平衡"></a>1.栈平衡</h3><p>​	略</p>
<h3 id="2-启动函数"><a href="#2-启动函数" class="headerlink" title="2.启动函数"></a>2.启动函数</h3><p>​	程序在运行时，先初始化函数代码，再调用main函数执行用户自己写的代码，也就是说，在程序运行时，其主函数并不放在开头，而是需要自己寻找主程序的入口。那么，如何找到主程序入口就是逆向分析的重点。</p>
<p>​	通常来说，可以直接在IDA Pro中查找main来找到main函数。如果找不到，也可以找到exit标签进行反向查找。</p>
<h3 id="3-调用约定"><a href="#3-调用约定" class="headerlink" title="3.调用约定"></a>3.调用约定</h3><p>​	x86应用程序函数调用有stdcall，__cdecl，Fstcall等方式，但x64应用程序只有一种寄存器快速调用约定。</p>
<p>​	前四个参数使用寄存器传递，如果参数超过四个，剩下的放在栈里，入栈顺序为从右至左，由函数负责平衡栈。</p>
<p>​	前四个放在固定的寄存器中，RCX（1）,RDX（2）,R8（3）,R9（4）。</p>
<p>​	任何大于8字节或者不是1，2，4，8字节的参数必须通过传引用的方式间接传参。所有浮点数的传递都是由XMM寄存器完成的。（前六个浮点型参数用XMM0~XMM5传送，超出部分用栈传送）。</p>
<p>​	<strong>前四个参数的调用约定</strong></p>
<p>​	虽然前四个参数并不使用栈空间，但栈还是为它们预留了空间（32字节），称之为预留栈空间。预留栈空间的作用是，当程序比较复杂，造成寄存器不够用的时候，可以将参数存放到预留栈空间，以此释放四个寄存器。</p>
<p>​	预留栈空间由函数的调用者提前申请，由函数调用者负责平衡栈。</p>
<h3 id="4-参数传递"><a href="#4-参数传递" class="headerlink" title="4.参数传递"></a>4.参数传递</h3><p>​	详见《加密与解密》p135~142</p>
<h3 id="5-函数返回值"><a href="#5-函数返回值" class="headerlink" title="5.函数返回值"></a>5.函数返回值</h3><p>​	64位环境下，使用RAX保存返回值。浮点类型使用MMX0寄存器返回。RAX寄存器可以保存8字节的数据，大于8字节时传引用解决。</p>
<hr>
<h2 id="3-数据结构-1"><a href="#3-数据结构-1" class="headerlink" title="3.数据结构"></a>3.数据结构</h2><p>​	与x86相似，主要是对局部变量，全局变量，数组等的访问。</p>
<h3 id="1-局部变量-1"><a href="#1-局部变量-1" class="headerlink" title="1.局部变量"></a>1.局部变量</h3><p>​	局部变量是<strong>函数</strong>内部定义的变量，存放在栈区，生命周期与函数相同。</p>
<p>函数申请的预留栈空间在低地址，声明的局部变量在高地址。</p>
<h3 id="2-全局变量-1"><a href="#2-全局变量-1" class="headerlink" title="2.全局变量"></a>2.全局变量</h3><p>​	全局变量在编译时就会确定并且固定下来，所以一般使用固定的地址去访问全局变量。</p>
<p>​	全局变量的地址先定义的在低地址，后定义的在高地址。</p>
<h3 id="3-数组-1"><a href="#3-数组-1" class="headerlink" title="3.数组"></a>3.数组</h3><p>​	数组是相同数据类型的集合，以线性方式连续储存在内存中。数组中的数据是由低到高排列的。</p>
<h4 id="（1）数组寻址公式"><a href="#（1）数组寻址公式" class="headerlink" title="（1）数组寻址公式"></a>（1）数组寻址公式</h4><p>​	一维数组：数组元素地址&#x3D;数组首地址+sizeof（数组类型）*下标</p>
<p>​	二维数组：数组元素地址&#x3D;数组首地址+sizeof（一维数组类型）*下标1+sizeof（数组类型）*下标2</p>
<h4 id="（2）一维数组和二维数组"><a href="#（2）一维数组和二维数组" class="headerlink" title="（2）一维数组和二维数组"></a>（2）一维数组和二维数组</h4><p>​	编译器访问数组的代码就是利用数组寻址公式访问的。当访问的数组下标为常量时，编译器会根据一维数组寻址公式直接计算出数组元素相对于数组首地址的偏移，比如：[ary+4*3]会被优化为[ary+12]。</p>
<p>​	但是，若下标为变量且未知，就无法进行计算进而优化，仍然是寻址公式的原始形式。二维数组同理。</p>
<p>数组特征总结如下：</p>
<ul>
<li>[数组首地址+n]</li>
<li>[数组首地址+寄存器*n]</li>
</ul>
<p>在进行逆向分析时，如果有以上特征，可以怀疑为一个数组访问。需要注意的是，在Release版本中，数组初始化时，可能会使用XMM寄存器进行优化。</p>
<h2 id="4-控制语句"><a href="#4-控制语句" class="headerlink" title="4.控制语句"></a>4.控制语句</h2><p>​	因为应用程序中存在大量的流程控制语句，所以识别流程控制语句是逆向分析的基础。这里主要介绍两种快速识别控制语句的方法，特征识别法和图形识别法。</p>
<h3 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h3><p>​	if语句是分支结构的重要组成部分，功能是，判断，非0则真，跳转，执行。因为汇编语言的逻辑问题，编译器生成的汇编代码会对表达式结果取反。</p>
<ul>
<li>特征识别：</li>
</ul>
<p>​	首先有一个jxx指令用于向下跳转，且跳转的目的地if_end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。</p>
<p><img src="/./../imgs/image-20241102214222867.png" alt="image-20241102214222867"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	在逆向分析工具中，为了方便的表示跳转的位置，使用虚线箭头表示条件跳转jxx，使用实线箭头表示无条件jmp。</p>
<h3 id="2-if……else语句"><a href="#2-if……else语句" class="headerlink" title="2.if……else语句"></a>2.if……else语句</h3><ul>
<li>特征识别：</li>
</ul>
<p>​	jxx指令用于向下跳转，且跳转的目的else中可以有jmp指令，但是else的结尾没有jmp指令，else的代码也会执行if_else_end的代码。</p>
<p><img src="/./../imgs/image-20241102220711805.png" alt="image-20241102220711805"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h3 id="3-if……else-if……else语句"><a href="#3-if……else-if……else语句" class="headerlink" title="3.if……else if……else语句"></a>3.if……else if……else语句</h3><p>​	多分支结构。</p>
<ul>
<li>特征识别：</li>
</ul>
<p>​	首先有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if跳转的目的else中可以有jmp指令，且else代码的结尾没有无条件跳转jmp。所有jmp的目标地址一致。</p>
<p><img src="/./../imgs/image-20241102222940769.png" alt="image-20241102222940769"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	见上图。</p>
<h3 id="4-switch—case语句"><a href="#4-switch—case语句" class="headerlink" title="4.switch—case语句"></a>4.switch—case语句</h3><p>​	switch是常用的多分支结构。通常比if语句有更高的效率。编译器有多种优化方案，当swicth分支数小于6时会直接使用if……else语句来实现，大于等于6时则会进行优化。比如：case表</p>
<p>​	当case&gt;&#x3D;6，且case值的间隔小时，将所有要跳转的case位置偏移放在一个一维数组的表中（case表），然后把case的值当作下标进行跳转，就可以避免使用if，从而使程序不那么冗长。</p>
<p>​	例如，switch（argc）只需要将argc-idata当作case表的下标，得出偏移，直接跳转过去。但是，为什么不直接将argc当作下标？</p>
<p><img src="/./../imgs/image-20241102230359416.png" alt="image-20241102230359416"></p>
<p>如果出现一个代码如下，并且直接将argc的值当作下标，那么建立起一个case表将需要101项，但事实上，能起作用的只有两项，其他都是swicth结束地址偏移，对空间的浪费不可估量。因此，将argc-idata再建表就只需要两项。</p>
<p><img src="/./../imgs/image-20241102230820870.png" alt="image-20241102230820870"></p>
<p>再比如：判定树</p>
<p>​	当实现swicth的if语句很多时，采用另一种优化方案——判定树。将每个case作为一个节点，从这些节点中找到中间值作为根节点，形成二叉平衡树。从根节点开始判定，这样就可以大大减少跳转的次数。</p>
<p><img src="/./../imgs/image-20241102231510971.png" alt="image-20241102231510971"></p>
<h3 id="5-转移指令的机器码"><a href="#5-转移指令的机器码" class="headerlink" title="5.*转移指令的机器码"></a>5.*转移指令的机器码</h3><p><img src="/./../imgs/image-20241102231631517.png" alt="image-20241102231631517"></p>
<h2 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5.循环语句"></a>5.循环语句</h2><p>​	对于C&#x2F;C++来说，循环语法有三种，do，while，for。虽然三者功能相同，但是不同的语法有不同的执行流程。</p>
<h3 id="1-do循环"><a href="#1-do循环" class="headerlink" title="1.do循环"></a>1.do循环</h3><ul>
<li>特征识别：</li>
</ul>
<p>​	首先会有jxx指令用于<strong>向上</strong>跳转，且跳转的do_while_start语句中没有jxx指令。根据以上特征，jxx指令在反推高级语言时不取反。</p>
<p><img src="/./../imgs/image-20241103125645809.png" alt="image-20241103125645809"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><p>​	循环的特征是会向低地址跳转。在while循环中向低地址跳转的情况与do不一样，while使用的是无条件跳转jmp指令，while循环的jxx指令要取反。</p>
<p>​	值得注意的是，同样的循环次数下while循环会会比do多一次条件判断，性能上不如do。在Release版本中，编译器会把while优化为等价的do循环。</p>
<ul>
<li>特征识别：</li>
</ul>
<p>​	首先会有一个jmp向上跳转指令，且跳转的目的while_start下面有jxx跳转指令。while代码也会执行while_end的代码。根据以上特征，在反推高级语言代码时，需要对jxx取反。</p>
<p><img src="/./../imgs/image-20241103130715258.png" alt="image-20241103130715258"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h3><ul>
<li>特征识别：</li>
</ul>
<p>​	for循环也出现向上跳转，但是与while循环不同的是，这里前面多了一个jmp指令。for循环的返回汇编需要取反。</p>
<p><img src="/./../imgs/image-20241103131625076.png" alt="image-20241103131625076"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h2 id="6-数学运算符"><a href="#6-数学运算符" class="headerlink" title="6.数学运算符"></a>6.数学运算符</h2><p>​	虽然整数的四则运算在汇编代码中都有对应的指令，但是，在Release版本中往往会对其进行优化。</p>
<h3 id="1-整数的加减-1"><a href="#1-整数的加减-1" class="headerlink" title="1.整数的加减"></a>1.整数的加减</h3><h4 id="（1）lea指令"><a href="#（1）lea指令" class="headerlink" title="（1）lea指令"></a>（1）lea指令</h4><p>​	与在32位逆向技术中一样，略。</p>
<h4 id="（2）常量折叠"><a href="#（2）常量折叠" class="headerlink" title="（2）常量折叠"></a>（2）常量折叠</h4><p>​	常量折叠优化是指当表达式出现两个以上常量进行计算的情况时，编译器可以在编译时就对其进行计算，并用计算结果替换表达式，这样就不用在程序运行期间进行计算，从而提高程序性能。</p>
<p><img src="/./../imgs/image-20241103133445088.png" alt="image-20241103133445088"></p>
<h3 id="2-整数的乘法-1"><a href="#2-整数的乘法-1" class="headerlink" title="2.整数的乘法"></a>2.整数的乘法</h3><p>​	编译器常使用lea比例因子寻址来优化乘法指令。</p>
<p><img src="/./../imgs/image-20241103135158439.png" alt="image-20241103135158439"></p>
<h3 id="3-整数的除法-1"><a href="#3-整数的除法-1" class="headerlink" title="3.整数的除法"></a>3.整数的除法</h3><p>​	除法指令的执行周期太长，因此许多编译器会尽可能用其他指令来代替除法指令，通常情况下，优化方法是转换成等价位移或乘法运算。</p>
<p>​	但是，计算机的除法与数学中的除法有所不同，计算机中整数除法是取整的除法，因此在位移时需要进行修正。</p>
<h4 id="（1）有符号除法，除数为2n"><a href="#（1）有符号除法，除数为2n" class="headerlink" title="（1）有符号除法，除数为2n"></a>（1）有符号除法，除数为2<sup>n</sup></h4><p>​	当除数为2<sup>n</sup>时，编译器一般会使用位移优化。数学优化公式为：若x&gt;&#x3D;0,x&#x2F;2<sup>n</sup>&#x3D;x&gt;&gt;n;如果x&lt;0,则x&#x2F;2<sup>n</sup>&#x3D;(x+(2<sup>n</sup>-1))&gt;&gt;n。</p>
<h4 id="（2）有符号除法，除数为-2n"><a href="#（2）有符号除法，除数为-2n" class="headerlink" title="（2）有符号除法，除数为-2n"></a>（2）有符号除法，除数为-2<sup>n</sup></h4><p>​	当除数为-2<sup>n</sup>时，相比于（1）多了一个求补的过程。数学优化公式为：若x&gt;&#x3D;0,x&#x2F;2<sup>n</sup>&#x3D;-(x&gt;&gt;n);如果x&lt;0,则x&#x2F;2<sup>n</sup>&#x3D;-{(x+(2<sup>n</sup>-1))&gt;&gt;n}。</p>
<h4 id="（3）-有符号除法，除数为正非2n"><a href="#（3）-有符号除法，除数为正非2n" class="headerlink" title="（3）*有符号除法，除数为正非2n"></a>（3）*有符号除法，除数为正非2<sup>n</sup></h4><h4 id="（4）-有符号除法，除数为负非2n"><a href="#（4）-有符号除法，除数为负非2n" class="headerlink" title="（4）*有符号除法，除数为负非2n"></a>（4）*有符号除法，除数为负非2<sup>n</sup></h4><h4 id="（5）无符号除法，除数为2n"><a href="#（5）无符号除法，除数为2n" class="headerlink" title="（5）无符号除法，除数为2n"></a>（5）无符号除法，除数为2<sup>n</sup></h4><p>​	直接shr右移即可。</p>
<h4 id="（6）-无符号除法，除数为正非2n"><a href="#（6）-无符号除法，除数为正非2n" class="headerlink" title="（6）*无符号除法，除数为正非2n"></a>（6）*无符号除法，除数为正非2<sup>n</sup></h4><h4 id="（7）-无符号除法，除数为负非2n"><a href="#（7）-无符号除法，除数为负非2n" class="headerlink" title="（7）*无符号除法，除数为负非2n"></a>（7）*无符号除法，除数为负非2<sup>n</sup></h4><p>[打*号的部分着重看《加密与解密》p161~167]</p>
<h3 id="4-整数得取模"><a href="#4-整数得取模" class="headerlink" title="4.整数得取模"></a>4.整数得取模</h3><h4 id="（1）除数为2n"><a href="#（1）除数为2n" class="headerlink" title="（1）除数为2n"></a>（1）除数为2<sup>n</sup></h4><p><img src="/./../imgs/image-20241103152218849.png" alt="image-20241103152218849"></p>
<h4 id="（2）除数为非2n"><a href="#（2）除数为非2n" class="headerlink" title="（2）除数为非2n"></a>（2）除数为非2<sup>n</sup></h4><p>​	编译器一般采用”余数&#x3D;被除数-商*除数“的方式进行优化。</p>
<hr>
<h2 id="7-虚函数"><a href="#7-虚函数" class="headerlink" title="7.虚函数"></a>7.虚函数</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/Linux/"
    >Linux</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/Linux/" class="article-date">
  <time datetime="2024-12-21T10:07:28.000Z" itemprop="datePublished">2024-12-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一-初识Linux"><a href="#一-初识Linux" class="headerlink" title="一.初识Linux"></a>一.初识Linux</h1><h2 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1.操作系统"></a>1.操作系统</h2><p>​	操作系统是计算机软件的一种，用于管理和调度硬件。它由内核（特权级）和系统级应用程序（用户级）。</p>
<p>​	常见的操作系统有Windows，Mac，Linux，IOS，Android，鸿蒙。</p>
<p>对于PC端的操作系统，Windows和Mac来说，Linux更注重于对服务器硬件和软件进行管理和调用。</p>
<h2 id="2-Linux初识"><a href="#2-Linux初识" class="headerlink" title="2.Linux初识"></a>2.Linux初识</h2><ul>
<li><p>内核：Linux的内核提供系统的主要功能，如硬件调度管理的能力，是免费开源的</p>
</li>
<li><p>Linux系统发行版：</p>
</li>
</ul>
<p>​	光有内核无法被用户使用，需要配合应用程序才能被用户使用。</p>
<p>​	在内核之上，封装系统级应用程序，组合在一起称之为Linux发行版。</p>
<p>本篇主要对CentOS进行学习。</p>
<h2 id="3-远程连接Linux系统"><a href="#3-远程连接Linux系统" class="headerlink" title="3.远程连接Linux系统"></a>3.远程连接Linux系统</h2><p>​	使用FinalShell跨越虚拟机，从而在windows系统上远程操控Linux</p>
<h2 id="4-WSL-Windows-Subsystem-for-Linux"><a href="#4-WSL-Windows-Subsystem-for-Linux" class="headerlink" title="4.WSL(Windows Subsystem for Linux)"></a>4.WSL(Windows Subsystem for Linux)</h2><p>​	直连计算机真机硬件来构建一个完整的Linux系统，而无需通过虚拟机使用虚拟计算机硬件来构建完整系统</p>
<h2 id="5-虚拟机快照"><a href="#5-虚拟机快照" class="headerlink" title="5.虚拟机快照"></a>5.虚拟机快照</h2><p>​	说人话就是存档</p>
<p>​	<strong>在VMware中制作快照</strong>：</p>
<h1 id="二-Linux基础命令"><a href="#二-Linux基础命令" class="headerlink" title="二.Linux基础命令"></a>二.Linux基础命令</h1><h2 id="1-Linux系统目录结构"><a href="#1-Linux系统目录结构" class="headerlink" title="1.Linux系统目录结构"></a>1.Linux系统目录结构</h2><ul>
<li><p>Linux系统目录是树状，并且有且仅有一个树根&#x2F;，也就是说，Linux系统目录的顶级目录有且仅有一个“&#x2F;”，所有的文件都在它之下。</p>
</li>
<li><p>Linux的路径描述：Linux不同于Windows，它的层级关系是用“&#x2F;”来描述的，而Windows是用“\”来描述的。</p>
</li>
</ul>
<h2 id="2-Linux命令入门"><a href="#2-Linux命令入门" class="headerlink" title="2.Linux命令入门"></a>2.Linux命令入门</h2><h3 id="1-Linux中所有的命令都有统一的格式："><a href="#1-Linux中所有的命令都有统一的格式：" class="headerlink" title="1.Linux中所有的命令都有统一的格式："></a>1.Linux中所有的命令都有统一的格式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command [-options] [parameter]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>command:命令本身</p>
</li>
<li><p>-options:命令的一些选项，可以通过选项控制命令的行为细节</p>
</li>
<li><p>parameter:命令的参数，多数用于命令的指向目标等</p>
</li>
</ul>
<h3 id="2-ls命令"><a href="#2-ls命令" class="headerlink" title="2.ls命令"></a>2.ls命令</h3><ul>
<li>ls命令的作用是列出目录下的内容，语法细节如下：</li>
</ul>
<p>​	ls [-a -l -h] [Linux路径]</p>
<ul>
<li>当不使用选项和参数时，直接使用ls命令的本体，表示：以平铺形式，列出当前工作目录下的内容，如果不指定目录，那么将打开HOME目录</li>
<li>-a:列出全部目录(包含隐藏的文件和文件夹)</li>
<li>-l:以列表(竖向排列)的形式展示内容，并展示更多信息</li>
<li>-h:表示易于阅读的形式，列出文件大小，-h必须与-l一起使用</li>
</ul>
<h2 id="3-目录切换相关命令"><a href="#3-目录切换相关命令" class="headerlink" title="3.目录切换相关命令"></a>3.目录切换相关命令</h2><h3 id="1-cd-ChangeDirectory-命令切换工作目录"><a href="#1-cd-ChangeDirectory-命令切换工作目录" class="headerlink" title="1.cd(ChangeDirectory)命令切换工作目录"></a>1.cd(ChangeDirectory)命令切换工作目录</h3><ul>
<li><p>Linux会默认工作目录为&#x2F;home，通过cd可以改变工作目录</p>
</li>
<li><p>cd命令语法：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [Linux路径]</span><br></pre></td></tr></table></figure>

<ul>
<li>当cd没有Linux路径时，会回到&#x2F;home</li>
<li>当cd有Linux路径时，会打开路径目录，并切换工作目录为路径目录</li>
</ul>
<h3 id="2-pwd-PrintWorkDirectory-查看当前工作目录"><a href="#2-pwd-PrintWorkDirectory-查看当前工作目录" class="headerlink" title="2.pwd(PrintWorkDirectory)查看当前工作目录"></a>2.pwd(PrintWorkDirectory)查看当前工作目录</h3><ul>
<li>pwd命令语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<ul>
<li>pwd无选项，无参数</li>
</ul>
<h2 id="4-相对路径、绝对路径和特殊路径符"><a href="#4-相对路径、绝对路径和特殊路径符" class="headerlink" title="4.相对路径、绝对路径和特殊路径符"></a>4.相对路径、绝对路径和特殊路径符</h2><ul>
<li><p>相对路径：以当前工作目录为起点描述路径(无需以”&#x2F;“起手)</p>
</li>
<li><p>绝对路径：以根目录为起点描述路径(“&#x2F;“起手)</p>
</li>
<li><p>特殊路径符：</p>
<ul>
<li><p>“.”  :表示当前路径，cd .&#x2F;Desktop &#x3D;&#x3D; cd Desktop</p>
</li>
<li><p>“..”  :表示上一级目录，eg:</p>
<p>假设：现在的工作目录的绝对路径为&#x2F;home&#x2F;zhouyue</p>
<p>那么：cd ..将切换到&#x2F;home</p>
<p>​	    cd ..&#x2F;.. 将切换到&#x2F;</p>
</li>
<li><p>“~”  :表示home目录，cd ~即可切换到home目录，eg:</p>
<p>cd ~ 切换到home</p>
<p>cd ~&#x2F;zhouyue 切换到zhouyue</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-创建目录命令"><a href="#5-创建目录命令" class="headerlink" title="5.创建目录命令"></a>5.创建目录命令</h2><ul>
<li><p>通过mkdir命令可以创建新的目录</p>
</li>
<li><p>mkdir(MakeDirectory)命令：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li>参数必填，没路径创牛魔的目录啊</li>
<li>-p：表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<p>​	eg:如果要创建一条全新的多层级目录，比如：</p>
<p>​	local&#x2F;test03</p>
<p>​	需要加-p ,也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p local/test03</span><br><span class="line">#注意，这里创建的多层级目录的&quot;根&quot;是当前工作目录</span><br></pre></td></tr></table></figure>

<p>创建文件夹需要修改权限，也就是说如果不涉及权限修改，那么仅能在home目录中进行创建</p>
<h2 id="6-文件操作命令"><a href="#6-文件操作命令" class="headerlink" title="6.文件操作命令"></a>6.文件操作命令</h2><ul>
<li>touch创建文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li>cat查看文件内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li>more查看文件内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li><p>同样是查看命令，cat会将所有内容显示，而more会分页显示</p>
</li>
<li><p>cp复制文件&#x2F;文件夹</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [-r] param1 param2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-r :复制文件夹时使用，表示递归</p>
</li>
<li><p>param1 :Linux路径，表示被复制的文件&#x2F;文件夹</p>
</li>
<li><p>param2 :Linux路径，表示要复制去的地方</p>
</li>
<li><p>mv移动文件&#x2F;文件夹</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv param1 param2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>param1 :Linux路径，表示被移动的文件&#x2F;文件夹</p>
</li>
<li><p>param2 :Linux路径，表示要移动过去的地方，如果目标不存在，则进行改名，确保目标存在</p>
</li>
<li><p>rm删除文件&#x2F;文件夹</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-r/-f] param1,param2,……,paramn</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-r :表示删除文件夹</p>
</li>
<li><p>-f(force) :表示强制删除</p>
</li>
<li><p>多个参数表示其可以同时删除多个文件&#x2F;文件夹</p>
</li>
<li><p>通配符<code>*</code></p>
</li>
<li><p>Linux中rm命令支持通配符做模糊匹配</p>
</li>
<li><p><code>test*</code>:匹配任意以test开头的内容</p>
</li>
<li><p><code>*test</code>:匹配任意以test结尾的内容</p>
</li>
<li><p><code>*test*</code>:匹配任意包含test的内容</p>
</li>
</ul>
<h2 id="7-查找命令"><a href="#7-查找命令" class="headerlink" title="7.查找命令"></a>7.查找命令</h2><ul>
<li>which查找命令的程序文件存放地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which command</span><br></pre></td></tr></table></figure>

<ul>
<li>find按文件名查找文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find start_path -name &quot;file_name&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>find按文件大小查找文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find start_path -size +(geater)/-(smaller)n[k/M/G]</span><br></pre></td></tr></table></figure>

<ul>
<li>n表示单位，k表示kb，M表示MB，G表示GB</li>
</ul>
<h2 id="8-grep、wc和管道符"><a href="#8-grep、wc和管道符" class="headerlink" title="8.grep、wc和管道符"></a>8.grep、wc和管道符</h2><ul>
<li>grep通过关键字过滤文件行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-n] &quot;key_word&quot; file_path</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-n:显示匹配行的行号</p>
</li>
<li><p>wc做数量统计</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [-c -m -l -w] file_path</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-c:统计bytes数量</p>
</li>
<li><p>-m:统计字符数量</p>
</li>
<li><p>-l:统计行数</p>
</li>
<li><p>-w:统计单词数量(以空格划分)</p>
</li>
<li><p>什么都不加默认输出bytes数量、行数、单词数量</p>
</li>
<li><p>file_path可以作内容输入端口</p>
</li>
<li><p>管道符”|”</p>
</li>
</ul>
<p>​	管道符会将其左边的结果作为右边命令的输入</p>
<p>​	eg:wc | cat test01.txt</p>
<h2 id="9-echo、tail和重定向符"><a href="#9-echo、tail和重定向符" class="headerlink" title="9.echo、tail和重定向符"></a>9.echo、tail和重定向符</h2><ul>
<li>echo在命令行输出指定内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;content&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>飘号&#96;</li>
</ul>
<p>​	在echo命令中，飘号中的会被认为是命令而不是content</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `pwd`</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重定向符</p>
<ul>
<li><code>&gt;</code>:将左侧命令的结果<strong>覆盖</strong>到右侧的文件中</li>
<li><code>&gt;&gt;</code>:将左侧命令的结果<strong>追加</strong>到右侧的文件中</li>
</ul>
</li>
<li><p>tail查看文件尾部内容，跟踪文件的最新更改</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-f -num] file_path</span><br></pre></td></tr></table></figure>

<ul>
<li>-f:表示持续跟踪</li>
<li>-num:表示查看尾部多少行，不填默认十行</li>
</ul>
<h2 id="10-vi-vim编辑器"><a href="#10-vi-vim编辑器" class="headerlink" title="10.vi&#x2F;vim编辑器"></a>10.vi&#x2F;vim编辑器</h2><p><img src="/./../imgs/image-20241204212354233.png" alt="image-20241204212354233"></p>
<p>以下是一些常用的命令模式快捷键：</p>
<ol>
<li><p><strong>光标移动</strong>：</p>
<ul>
<li><code>h</code>: 向左移动光标</li>
<li><code>j</code>: 向下移动光标</li>
<li><code>k</code>: 向上移动光标</li>
<li><code>l</code>: 向右移动光标</li>
<li><code>w</code>: 跳到下一个单词的开头</li>
<li><code>b</code>: 跳到上一个单词的开头</li>
<li><code>0</code>: 跳到行首</li>
<li><code>$</code>: 跳到行尾</li>
</ul>
</li>
<li><p><strong>文本编辑</strong>：</p>
<ul>
<li><code>i</code>: 切换到插入模式</li>
<li><code>a</code>: 在光标后插入并切换到插入模式</li>
<li><code>o</code>: 在当前行下插入新行并切换到插入模式</li>
<li><code>x</code>: 删除当前字符</li>
<li><code>dd</code>: 删除当前行</li>
<li><code>yy</code>: 复制当前行</li>
<li><code>p</code>: 粘贴</li>
</ul>
</li>
<li><p><strong>查找和替换</strong>：</p>
<ul>
<li><code>/pattern</code>: 向前查找 <code>pattern</code></li>
<li><code>?pattern</code>: 向后查找 <code>pattern</code></li>
<li><code>n</code>: 跳到下一个匹配项</li>
<li><code>N</code>: 跳到上一个匹配项</li>
<li><code>:s/old/new/g</code>: 将当前行中的 <code>old</code> 替换为 <code>new</code></li>
<li><code>:%s/old/new/g</code>: 替换整个文件中的 <code>old</code> 为 <code>new</code></li>
</ul>
</li>
<li><p><strong>保存和退出</strong>：</p>
<ul>
<li><code>:w</code>: 保存文件</li>
<li><code>:q</code>: 退出</li>
<li><code>:wq</code>: 保存并退出</li>
<li><code>:q!</code>: 强制退出不保存</li>
</ul>
</li>
</ol>
<h1 id="三-Linux用户和权限"><a href="#三-Linux用户和权限" class="headerlink" title="三.Linux用户和权限"></a>三.Linux用户和权限</h1><h2 id="1-Linux的root用户"><a href="#1-Linux的root用户" class="headerlink" title="1.Linux的root用户"></a>1.Linux的root用户</h2><p>​	Linux中允许配置多个用户和用户组，这是因为Linux的权限管控分针对用户和针对用户组两个级别。</p>
<ul>
<li><p>用户组管理(root权限下)</p>
<ul>
<li><p>groupadd user_group_name创建用户组</p>
</li>
<li><p>groupdel  user_group_name删除用户组</p>
</li>
</ul>
</li>
<li><p>用户管理(root权限下)</p>
<ul>
<li><p>useradd [-g -d] user_name</p>
<ul>
<li>-g:指定用户的<strong>组</strong>，如果不加-g,会创建同名用户组并自动加入，指定-g要求组已经存在，如已存在同名组，必须使用-g</li>
<li>-d:指定用户的home目录，不指定，home目录默认为：&#x2F;home&#x2F;user_name</li>
</ul>
</li>
<li><p>userdel [-r] user_name</p>
<ul>
<li>-r:删除用户的home目录，如果不使用-r，删除用户时会保留home目录</li>
</ul>
</li>
<li><p>id [user_name]</p>
<ul>
<li>如果不提供用户名则查看自身</li>
</ul>
</li>
<li><p>usermod -aG user_group user_name</p>
<ul>
<li>将指定用户加入指定用户组</li>
</ul>
</li>
<li><p>getent passwd</p>
<ul>
<li><p>查看当前系统中的用户，弹出来的信息从左往右依次代表：</p>
<p>用户名:密码(x):用户ID:组ID:描述信息:home目录:执行终端</p>
</li>
</ul>
</li>
<li><p>getent group</p>
<ul>
<li><p>查看系统中的组，包含三份信息：</p>
<p>组名称:组认证(x):组ID</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-查看权限控制信息"><a href="#2-查看权限控制信息" class="headerlink" title="2.查看权限控制信息"></a>2.查看权限控制信息</h2><p>​	当我们只用ls -l查看时，会出现以下信息：</p>
<p><img src="/./../imgs/image-20241205213116859.png" alt="image-20241205213116859"></p>
<p>从左往右，第一个红框内表示文件&#x2F;文件夹的权限控制信息，第二个是该文件&#x2F;文件夹归属于哪个用户，第三个是该用户归属于哪个用户组</p>
<ul>
<li>认知权限细节</li>
</ul>
<p><img src="/./../imgs/image-20241205213414552.png" alt="image-20241205213414552"></p>
<h2 id="3-chmod命令"><a href="#3-chmod命令" class="headerlink" title="3.chmod命令"></a>3.chmod命令</h2><p>只有文件&#x2F;文件夹的所属用户或者root用户才可以对其进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] power file/folder</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-R:对文件夹内的全部内容应用同样的操作</p>
</li>
<li><p>权限的数字代号</p>
<ul>
<li><p><code>rwx</code> (读、写、执行) &#x3D; 4 + 2 + 1 &#x3D; 7</p>
</li>
<li><p><code>rw-</code> (读、写) &#x3D; 4 + 2 + 0 &#x3D; 6</p>
</li>
<li><p><code>r--</code> (读) &#x3D; 4 + 0 + 0 &#x3D; 4</p>
</li>
<li><p><code>r-x</code> (读、执行) &#x3D; 4 + 0 + 1 &#x3D; 5</p>
</li>
<li><p><code>-wx</code> (写、执行) &#x3D; 0 + 2 + 1 &#x3D; 3</p>
</li>
<li><p><code>--x</code> (执行) &#x3D; 0 + 0 + 1 &#x3D; 1</p>
</li>
<li><p><code>---</code> (无权限) &#x3D; 0</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-chown"><a href="#4-chown" class="headerlink" title="4.chown"></a>4.chown</h2><p>此命令仅限root用户使用</p>
<p>chown命令可以修改文件&#x2F;文件夹的所属用户或者组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] [user][:][user_group] file/folder</span><br></pre></td></tr></table></figure>





<h1 id="四-Linux的实用命令"><a href="#四-Linux的实用命令" class="headerlink" title="四.Linux的实用命令"></a>四.Linux的实用命令</h1><h2 id="1-systemctl"><a href="#1-systemctl" class="headerlink" title="1.systemctl"></a>1.systemctl</h2><p>systemctl可以管理Linux的一些内置服务(其实就是软件)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start|stop|status|enable|disable</span><br></pre></td></tr></table></figure>

<p>同时system也可以管理一些第三方软件，只要软件有注册服务的功能</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >前端学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2024-12-21T10:06:47.000Z" itemprop="datePublished">2024-12-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端学习笔记"><a href="#前端学习笔记" class="headerlink" title="前端学习笔记"></a>前端学习笔记</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><ul>
<li><p>HTML(Hypertext Markup Language)，通过一系列的**标签(或者说元素)**来定义文本，图像，链接等。HTML标签是由尖括号包围的关键字。</p>
</li>
<li><p>标签通常成对出现，包括开始标签和结束标签，内容位于这两个标签之内，eg:</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是一个超链接。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>除了双标签，也存在单标签，eg:</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>区别：单标签用于没有内容的元素，双标签用于有内容的元素</p>
<h3 id="HTML文件结构"><a href="#HTML文件结构" class="headerlink" title="HTML文件结构"></a>HTML文件结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里放置文档的元信息 -- &gt;</span></span><br><span class="line"><span class="comment">&lt;! DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">    &lt;head&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 这里放置文档的元信息 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;title&gt;文档标题&lt;/title&gt;</span></span><br><span class="line"><span class="comment">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 连接外部样式表或脚本文件等 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;/head&gt;</span></span><br><span class="line"><span class="comment">    &lt;body&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 这里放置页面内容 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;h1&gt;这是一个标题&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">        &lt;p&gt;这是一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        &lt;a href=&quot;https://www.example.com&quot;&gt;这是一个链接&lt;/a&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 其他内容 -- &gt;</span></span><br><span class="line"><span class="comment">    &lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML的常用标签"><a href="#HTML的常用标签" class="headerlink" title="HTML的常用标签"></a>HTML的常用标签</h3><p>详见test01.html</p>
<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><ul>
<li>HTML的属性用于定义元素的行为和外观，以及其他元素的关系</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">start_label</span> <span class="attr">attribute_name</span>=<span class="string">&quot;attribute_value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>每个HTML元素可以具有不同的属性</li>
<li>属性名大小写不敏感，属性值大小写敏感</li>
</ul>
<h3 id="HTML区块"><a href="#HTML区块" class="headerlink" title="HTML区块"></a>HTML区块</h3><ul>
<li><p>块元素</p>
<p>块级元素通常用于组织和布局页面的主要结构内容。它们用于创建页面的主要部分，将内容分割为<strong>逻辑块</strong>。</p>
<ul>
<li>块级元素通常从新行开始，并占据整行的宽度，因此它们会在页面上呈现为一块独立的内容块</li>
<li>可以包含其他块级元素和行内元素</li>
</ul>
</li>
<li><p>行内元素</p>
<ul>
<li>无法包含块级元素，仅能包含行内元素</li>
</ul>
</li>
</ul>
<h4 id="标签"><a href="#标签" class="headerlink" title="&lt;div&gt;标签"></a><code>&lt;div&gt;</code>标签</h4><ul>
<li><strong>块级元素</strong>：<code>&lt;div&gt;</code>是一个块级元素，意味着它会独占一行，前后有换行。</li>
<li><strong>结构性</strong>：通常用于对页面内容进行分组，帮助组织和布局。可以包含其他块级和行内元素。</li>
<li><strong>样式和脚本</strong>：通常与CSS和JavaScript一起使用，以便对特定部分的样式进行控制或添加交互功能。</li>
<li><strong>常见用途</strong>：用于创建页面的布局结构，比如头部、侧边栏、内容区域和页脚等。</li>
</ul>
<h4 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;span&gt;标签"></a><code>&lt;span&gt;</code>标签</h4><ul>
<li><strong>行内元素</strong>：<code>&lt;span&gt;</code>是一个行内元素，意味着它不会独占一行，通常用于对文本或其他行内元素进行样式化。</li>
<li><strong>无语义</strong>：<code>&lt;span&gt;</code>本身没有语义，仅用于样式和布局，通常与CSS一起使用来改变文本的样式。</li>
<li><strong>常见用途</strong>：用于包裹部分文本，应用特定的样式或脚本，比如改变颜色、字体或添加事件监听</li>
</ul>
<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><ul>
<li>HTML表单是用于收集用户输入数据的结构化元素。通过表单，用户可以输入信息并将其提交到服务器进行处理。HTML表单通常包含各种输入元素，例如文本框、单选按钮、复选框、下拉列表等</li>
</ul>
<p>关于表单的创建，有以下需要注意的点：</p>
<ol>
<li>所有表单需要在form标签下</li>
<li>常用于表单的标签有：<ol>
<li>label：用于描述表单控件的标签</li>
<li>input：各种类型的输入控件</li>
</ol>
</li>
</ol>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的三种导入方式"><a href="#CSS的三种导入方式" class="headerlink" title="CSS的三种导入方式"></a>CSS的三种导入方式</h3><p>内联样式&gt;内部样式表&gt;外部样式表</p>
<p>详见test02.html</p>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>选择器是CSS中的关键部分，它允许针对特定元素或一组元素定义样式</p>
<p>ID&gt;类&gt;标签名</p>
<h3 id="CSS网页布局"><a href="#CSS网页布局" class="headerlink" title="CSS网页布局"></a>CSS网页布局</h3><p>略</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>轻量级的解释型脚本语言，常用于网页交互和客户端脚本开发</p>
<h3 id="JS的导入"><a href="#JS的导入" class="headerlink" title="JS的导入"></a>JS的导入</h3><p>同CSS，只不过在<code>&lt;script&gt;&lt;/script&gt;</code>标签中写罢了</p>
<h3 id="JS的变量和数据类型"><a href="#JS的变量和数据类型" class="headerlink" title="JS的变量和数据类型"></a>JS的变量和数据类型</h3><p><strong>在JavaScript中，<code>const</code>用于声明常量，<code>var</code> 和 <code>let</code> 都是用来声明变量的方法，但它们有一些重要的区别：</strong></p>
<h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><ul>
<li>**<code>var</code>**：具有函数作用域（function scope）。这意味着在一个函数内声明的 <code>var</code> 变量在整个函数中都是可见的。</li>
<li>**<code>let</code>**：具有块级作用域（block scope）。这意味着在一个块（例如花括号 <code>&#123;&#125;</code>）内声明的 <code>let</code> 变量只在这个块内部可见。</li>
</ul>
<h3 id="2-变量提升"><a href="#2-变量提升" class="headerlink" title="2. 变量提升"></a>2. 变量提升</h3><ul>
<li>**<code>var</code>**：变量声明会被提升（hoisting）到函数或全局作用域的顶部，但赋值不会提升。因此，可以在声明之前使用，但值为 <code>undefined</code>。</li>
<li>**<code>let</code>**：变量声明不会被提升，或者说会被提升但不会初始化。在声明之前使用 <code>let</code> 变量会导致 ReferenceError 错误。</li>
</ul>
<h3 id="3-重复声明"><a href="#3-重复声明" class="headerlink" title="3. 重复声明"></a>3. 重复声明</h3><ul>
<li>**<code>var</code>**：可以在同一作用域内多次声明同一个变量。</li>
<li>**<code>let</code>**：在同一作用域内不能重复声明同一个变量。</li>
</ul>
<p>现在的代码中尽量使用let而不是var，但是也不是什么要紧的事，由于前端三大件语法的简单，AI已经可以很好地写很漂亮的代码，不需要自己写，仅作了解即可</p>
<h2 id="JS的数据类型与变量"><a href="#JS的数据类型与变量" class="headerlink" title="JS的数据类型与变量"></a>JS的数据类型与变量</h2><p>略，无需在意</p>
<h2 id="JS的控制语句"><a href="#JS的控制语句" class="headerlink" title="JS的控制语句"></a>JS的控制语句</h2><p>和C语言完全一致</p>
<h2 id="JS的函数"><a href="#JS的函数" class="headerlink" title="JS的函数"></a>JS的函数</h2><p>与C几乎相同，唯一的区别事使用function定义而不需要根据函数返回值的类型更改函数头信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">function_name</span>(<span class="params">param1,param2,……</span>)&#123;</span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="zhouyue&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>