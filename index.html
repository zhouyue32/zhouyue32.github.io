<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> zhouyue&#39;s blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">zhouyue&#39;s blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['会当凌绝顶，一览众山小', '且放白鹿青崖间，须行即骑访名山', '不畏浮云遮望眼，自缘身在最高层'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-reverse：pythonre"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/22/reverse%EF%BC%9Apythonre/"
    >reverse：pythonre</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/22/reverse%EF%BC%9Apythonre/" class="article-date">
  <time datetime="2024-12-22T09:30:00.000Z" itemprop="datePublished">2024-12-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="reverse：pythonre"><a href="#reverse：pythonre" class="headerlink" title="reverse：pythonre"></a>reverse：pythonre</h1><p>​	打开附件，可以看到是.pyc文件，直接用pycdc解密即可，解密之后代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex, a2b_hex</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aestest</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="variable language_">self</span>.key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.cipher = AES.new(<span class="variable language_">self</span>.key, AES.MODE_ECB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        padded_text = pad(text.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size)</span><br><span class="line">        encrypted = <span class="variable language_">self</span>.cipher.encrypt(padded_text)</span><br><span class="line">        <span class="keyword">return</span> b2a_hex(encrypted)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, enc_text</span>):</span><br><span class="line">        encrypted = a2b_hex(enc_text)</span><br><span class="line">        decrypted = <span class="variable language_">self</span>.cipher.decrypt(encrypted)</span><br><span class="line">        <span class="keyword">return</span> unpad(decrypted, AES.block_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Evidence</span>(<span class="params">text, key</span>):</span><br><span class="line">    aes = aestest(key)</span><br><span class="line">    detext = aes.decrypt(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = <span class="string">b&#x27;d6e7e40e61c0d951c84dc8f0d03596a087ecc6b690b45a9b8d4c749deb465b51&#x27;</span></span><br><span class="line">    key = <span class="string">&#x27;Chong_mou_people&#x27;</span></span><br><span class="line">    Evidence(text, key)</span><br></pre></td></tr></table></figure>

<p>显然，这是一个AES加解密，看Evidence中的是AES解密，我们可以猜测下文中的text就是密文，经过上述流程就可以解出flag，稍作修改：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex, a2b_hex</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aestest</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="variable language_">self</span>.key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.cipher = AES.new(<span class="variable language_">self</span>.key, AES.MODE_ECB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        padded_text = pad(text.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size)</span><br><span class="line">        encrypted = <span class="variable language_">self</span>.cipher.encrypt(padded_text)</span><br><span class="line">        <span class="keyword">return</span> b2a_hex(encrypted)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, enc_text</span>):</span><br><span class="line">        encrypted = a2b_hex(enc_text)</span><br><span class="line">        decrypted = <span class="variable language_">self</span>.cipher.decrypt(encrypted)</span><br><span class="line">        <span class="keyword">return</span> unpad(decrypted, AES.block_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Evidence</span>(<span class="params">text, key</span>):</span><br><span class="line">    aes = aestest(key)</span><br><span class="line">    detext = aes.decrypt(text)</span><br><span class="line">    <span class="built_in">print</span>(aes)</span><br><span class="line">    <span class="built_in">print</span>(detext)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = <span class="string">b&#x27;d6e7e40e61c0d951c84dc8f0d03596a087ecc6b690b45a9b8d4c749deb465b51&#x27;</span></span><br><span class="line">    key = <span class="string">&#x27;Chong_mou_people&#x27;</span></span><br><span class="line">    Evidence(text, key)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<p><img src="/./../imgs/image-20241208114813005.png" alt="image-20241208114813005"></p>
<p>得到flag</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-reverse：EZ_DOC"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/22/reverse%EF%BC%9AEZ_DOC/"
    >reverse：EZ_DOC</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/22/reverse%EF%BC%9AEZ_DOC/" class="article-date">
  <time datetime="2024-12-22T09:30:00.000Z" itemprop="datePublished">2024-12-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="reverse：EZ-DOC"><a href="#reverse：EZ-DOC" class="headerlink" title="reverse：EZ_DOC"></a>reverse：EZ_DOC</h1><p>​	打开附件，进010，发现不是一般的.doc文件，甚至可能不是.doc文件，查找发现base64的字样，还有很多base64加密特征的字符串，可以考虑将特殊字符提取出来base64解密看看有没有提示信息，由于我不会使用010，所以进ida分析二进制文件：</p>
<p><img src="/./../imgs/image-20241222164913139.png" alt="image-20241222164913139"></p>
<p>将字符串解密即可得到如下字符串：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">caesar_cipher_encrypt</span>(<span class="params">text, shift</span>):</span><br><span class="line"><span class="keyword">return</span> encrypted_text</span><br><span class="line">encrypted_text = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> text:</span><br><span class="line"><span class="keyword">if</span> char.isalpha():</span><br><span class="line">encrypted_char = <span class="built_in">chr</span>((<span class="built_in">ord</span>(char) - start + shift) % <span class="number">26</span> + start)</span><br><span class="line">encrypted_text += encrypted_char</span><br><span class="line">encrypted_text += char</span><br><span class="line">original_text = <span class="string">&quot;cixd&#123;SYx_lccfzxi&#125;&quot;</span></span><br><span class="line">encrypted = caesar_cipher_encrypt(original_text, shift_amount)</span><br><span class="line">rt = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">if</span> char.islower() <span class="keyword">else</span> <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>很显然这是凯撒加密，直接将oringinal_text右移4位即可。</p>
<p>得到flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;VBa_offical&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-加密与解密——解密篇2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%872/"
    >加密与解密——解密篇2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%872/" class="article-date">
  <time datetime="2024-12-21T10:11:19.000Z" itemprop="datePublished">2024-12-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="1-单向散列算法"><a href="#1-单向散列算法" class="headerlink" title="1.单向散列算法"></a>1.单向散列算法</h2><h2 id="2-对称加密算法"><a href="#2-对称加密算法" class="headerlink" title="2.对称加密算法"></a>2.对称加密算法</h2><h3 id="1-RC4流密码"><a href="#1-RC4流密码" class="headerlink" title="1.RC4流密码"></a>1.RC4流密码</h3><ul>
<li><p>算法原理：RC4生成一种称为密钥流的伪随机流，它与明文通过异或操作混合，从而达到加密的效果。解密时与密文进行异或操作。其密钥流由两部分组成，分别是KSR和PRGA。</p>
</li>
<li><p>KSA（the Key-Scheduling Algorithm）</p>
<ul>
<li><p>初始化256字节的数组S</p>
<ul>
<li>将S线性填充</li>
<li>用种子密钥对另一表K进行填充</li>
<li>用K表对S表进行初始置换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span>:</span><br><span class="line">       S[i] = i</span><br><span class="line">    </span><br><span class="line">   j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">255</span>:</span><br><span class="line">       j = (j + S[i] + K[i]) mod <span class="number">256</span></span><br><span class="line">       swap(S[i], S[j])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PRGA</p>
<ul>
<li><p>密钥流的生成</p>
<ul>
<li>从S表中随机获取值组成密钥流与明文异或</li>
<li>伪随机数的生成</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> r=<span class="number">0</span> to len <span class="keyword">do</span></span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">    j=(j+S[i])%<span class="number">256</span></span><br><span class="line">    swap(S[i],S[j])</span><br><span class="line">    t=(S[i]+S[j])%<span class="number">256</span></span><br><span class="line">    k[r]=S[t]</span><br></pre></td></tr></table></figure>

<p>注：一旦密钥流生成，种子密钥就失去作用。</p>
<p>(Python实现见PythonProject&#x2F;RC4.py)</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-分组加密"><a href="#2-分组加密" class="headerlink" title="2.分组加密"></a>2.分组加密</h3><h4 id="1-电码本模式（ECB）"><a href="#1-电码本模式（ECB）" class="headerlink" title="1.电码本模式（ECB）"></a>1.电码本模式（ECB）</h4><p><img src="/./../imgs/image-20241112150004848.png" alt="image-20241112150004848"></p>
<p>电码本模式的重点在于，使用<strong>相同的</strong>密钥对进行分组的<strong>等长</strong>的明文<strong>单独加密</strong>。</p>
<ul>
<li><p>优点：每个数据块<strong>独立</strong>加密，可<strong>并行</strong>加密，实现简单。</p>
</li>
<li><p>缺点：相同明文会产生相同的密文，不具备数据完整保护性。也就是说，它并不具备混淆和扩散的能力，攻击者可以通过相同的密文块推断明文的一些信息。</p>
</li>
<li><p>适用场景：短消息的加密传输，比如对加密密钥的传输。</p>
</li>
</ul>
<h4 id="2-密文分组链接模式（CBC）"><a href="#2-密文分组链接模式（CBC）" class="headerlink" title="2.密文分组链接模式（CBC）"></a>2.密文分组链接模式（CBC）</h4><p><img src="/./../imgs/image-20241112151241702.png" alt="image-20241112151241702"></p>
<p>密文分组链接模式的重点在于：</p>
<ul>
<li>将前一个密文块与当前明文块进行异或运算<strong>之后</strong>再加密。</li>
<li>初始向量用于第一个块的加密。</li>
<li>加密算法的输入是上一个密文分组和当前明文分组的<strong>异或结果</strong>。</li>
</ul>
<p><img src="/./../imgs/image-20241112151738547.png" alt="image-20241112151738547"></p>
<p>优缺点及适用场景：  </p>
<ul>
<li>优点：每个密文块的加密依赖前一个密文块，具备数据完整保护性。</li>
<li>缺点：传输过程中的错误会传播下去，不适合并行处理。 </li>
<li>适用场景：适用于常规文件加密，非实时加密等场景。</li>
</ul>
<h4 id="3-密文反馈模式-CFB"><a href="#3-密文反馈模式-CFB" class="headerlink" title="3.密文反馈模式(CFB)"></a>3.密文反馈模式(CFB)</h4><p><img src="/./../imgs/image-20241112152305771.png" alt="image-20241112152305771"></p>
<p>密文反馈模式的重点在于：</p>
<ul>
<li><p>将<strong>前一个密文块</strong>作为<strong>加密算法的输入</strong>。</p>
</li>
<li><p>加密算法生成一个<strong>密钥流</strong>，再与当前的明文块进行<strong>异或</strong>得到密文块。</p>
</li>
<li><p>明文本身并<strong>不在</strong>加密算法中。</p>
</li>
</ul>
<p>优缺点及适用场景：  </p>
<ul>
<li>优点：可以处理<strong>任意长度</strong>的数据，<strong>实时</strong>加密解密，可以<strong>部分解密</strong>数据。</li>
<li>缺点：错误传播的敏感性，不适合并行处理，需要保证初始向量的唯一性和完整性。</li>
</ul>
<h4 id="4-输出反馈模式（OFB）"><a href="#4-输出反馈模式（OFB）" class="headerlink" title="4.输出反馈模式（OFB）"></a>4.输出反馈模式（OFB）</h4><p><img src="/./../imgs/image-20241112155548523.png" alt="image-20241112155548523"></p>
<p>输出反馈模式的重点在于：</p>
<ul>
<li><p>前一个加密算法的输出作为下一个加密算法的输入</p>
</li>
<li><p>加密后得到密钥流</p>
</li>
<li><p>密钥流与明文进行异或得到密文块</p>
</li>
</ul>
<p> <img src="/./../imgs/image-20241112155958301.png" alt="image-20241112155958301"></p>
<p>CFB和OFB模式的唯一不同在于密钥流的获取方式不同。</p>
<p>优缺点及适用场景：</p>
<ul>
<li><p>优点：长度可变，实时加密，错误传播敏感。</p>
</li>
<li><p>缺点：传输错误不可恢复 ，无法提供数据完整性保护，不支持并行加密。</p>
</li>
<li><p>适用场景：实时数据流加密和随机访问的场景。</p>
</li>
</ul>
<h4 id="5-计数器模式（CTR）"><a href="#5-计数器模式（CTR）" class="headerlink" title="5.计数器模式（CTR）"></a>5.计数器模式（CTR）</h4><p><img src="/./../imgs/image-20241112212818757.png" alt="image-20241112212818757"></p>
<p>计数器模式重点在于：</p>
<ul>
<li>每一个明文分组都与一个<strong>经过加密</strong>的<strong>计数器异或</strong>。</li>
<li>对于后续的分组，计数器自增</li>
<li>加密算法针对的是计数器</li>
</ul>
<p>优缺点及适用场景：</p>
<p>优点：</p>
<ul>
<li>可以并行处理</li>
<li>随机访问，根据计数器的值和密钥生成密钥流</li>
<li>不受错误传播的影响</li>
</ul>
<p>缺点：</p>
<ul>
<li>计数器必须唯一</li>
<li>密钥流和明文的相关性较弱</li>
</ul>
<p>适用场景：</p>
<ul>
<li>并行加密</li>
<li>随机访问</li>
<li>实时加密</li>
</ul>
<hr>
<p><img src="/./../imgs/image-20241112213505563.png" alt="image-20241112213505563"></p>
<hr>
<h3 id="3-TEA系列加密算法"><a href="#3-TEA系列加密算法" class="headerlink" title="3.TEA系列加密算法"></a>3.TEA系列加密算法</h3><h3 id="4-DES加密算法"><a href="#4-DES加密算法" class="headerlink" title="4.DES加密算法"></a>4.DES加密算法</h3><p>​	DES是一个经典的分组加密算法，通常一组是64位的数据，以电码本模式加密以下是加密步骤：</p>
<ol>
<li><strong>密钥生成</strong>：首先，从用户提供的64位密钥中提取出56位有效密钥（每第8位用于奇偶校验），然后生成16个子密钥，供每轮加密使用。</li>
<li><strong>初始置换（IP）</strong>：对64位输入数据进行初始置换，重排列数据的位。</li>
<li><strong>16轮加密</strong>：进行16轮的 Feistel 结构加密。在每一轮中，数据被分为左右两个32位部分，右半部分经过扩展置换和与当前轮的子密钥进行异或运算，经过S-盒替换后，再经过P-盒置换，最后与左半部分进行异或运算，交换左右部分。</li>
<li><strong>逆初始置换（IP⁻¹）</strong>：在完成16轮加密后，对数据进行逆初始置换，得到最终的密文</li>
</ol>
<h4 id="1-密钥生成"><a href="#1-密钥生成" class="headerlink" title="1.密钥生成"></a>1.密钥生成</h4><p>​	种子密钥为64位且唯一，经过两轮置换选择变为48位：</p>
<p><img src="/./../imgs/image-20241115191827253.png" alt="image-20241115191827253"></p>
<ul>
<li><p>PC1置换：</p>
<p>PC1置换将8位校验位去除，并进行比特重排打乱顺序</p>
<p><img src="/./../imgs/image-20241115191945874.png" alt="image-20241115191945874"></p>
</li>
<li><p>将PC1置换后的56位中间密钥分为C,D两部分，经过16次迭代，每次迭代进行不同次数的循环左移，得到打乱顺序后的56位中间密钥,值得注意的是，<strong>每一次迭代都是在前一次产生的C<sub>i</sub>，D<sub>i</sub>的基础上进行循环左移</strong>，生成C<sub><strong>i+1</strong></sub>，D<sub><strong>i+1</strong></sub>且这里的每一次迭代都生成一个中间密钥M-key<sub><strong>i</strong></sub>，只有这样才能保证能输出<strong>16个不同</strong>子密钥。</p>
<p><img src="/./../imgs/image-20241115192505906.png" alt="image-20241115192505906"></p>
</li>
<li><p>PC2置换：</p>
</li>
</ul>
<p>​	使用PC2置换将56位中间密钥M-key<sub><strong>i</strong></sub>去除8位并打乱</p>
<p><img src="/./../imgs/image-20241115192621065.png" alt="image-20241115192621065"></p>
<ul>
<li>得到48位密钥key<sub><strong>i</strong></sub>。</li>
</ul>
<h4 id="2-初始置换"><a href="#2-初始置换" class="headerlink" title="2.初始置换"></a>2.初始置换</h4><p>​	使用IP(Initial Permutation)置换对明文进行比特重排。</p>
<p><img src="/./../imgs/image-20241115193345521.png" alt="image-20241115193345521"></p>
<h4 id="3-16轮迭代加密"><a href="#3-16轮迭代加密" class="headerlink" title="3.16轮迭代加密"></a>3.16轮迭代加密</h4><p>​	进行16轮的 Feistel 结构加密。</p>
<h5 id="Feistel结构加密"><a href="#Feistel结构加密" class="headerlink" title="Feistel结构加密"></a>Feistel结构加密</h5><p>​	Feistel结构加密是指在每一轮中，数据被分为左右两个32位部分A<sub><strong>i</strong></sub>，B<sub><strong>i</strong></sub>，左半部分变不变，右半部分经过<strong>E扩展置换</strong>和与当前轮的<strong>子密钥进行异或运算</strong>，经过<strong>S-盒替换</strong>后，再经过<strong>P-盒置换</strong>，最后<strong>与左半部分进行异或运算</strong>，交换左右部分。</p>
<img src="./../imgs/image-20241115195530995.png" alt="image-20241115195530995" style="zoom:67%;" />

<h6 id="1-E扩展置换"><a href="#1-E扩展置换" class="headerlink" title="1.E扩展置换"></a>1.E扩展置换</h6><p>​	E扩展置换将32位的B<sub><strong>i</strong></sub>置换为48位的数据。而将32位扩展至48位关键在于将32位均分为8组，每一组的4位数据如何扩展至6位。</p>
<p>​	E扩展将原4位数据前后各加一位以此达到扩展的目的，前一位来自于前一组的最后一位，后一位来自后一组的第一位。第一组的前一位来自最后一组的最后一位，最后一组的后一位来自第一组的第一位。最终得到EB<sub><strong>i</strong></sub>以下是一个示例：</p>
<img src="./../imgs/image-20241115195942892.png" alt="image-20241115195942892" style="zoom: 50%;" />

<h6 id="2-与子密钥异或"><a href="#2-与子密钥异或" class="headerlink" title="2.与子密钥异或"></a>2.与子密钥异或</h6><p>​	EB<sub><strong>i</strong></sub>^key<sub><strong>i</strong></sub></p>
<h6 id="3-S-盒压缩"><a href="#3-S-盒压缩" class="headerlink" title="3.S-盒压缩"></a>3.S-盒压缩</h6><p>​	S-盒压缩将EB<sub><strong>i</strong></sub>均分为8组，将头尾数据分别转化为10进制数，以头尾十进制作行数，中间十进制数作列数，在S-盒表中查找对应数据，得到的十进制数转化为2进制就得到压缩后的4位数据，拼接起来得到32位数据SEB<sub><strong>i</strong></sub>。</p>
<p><img src="/./../imgs/image-20241115201231380.png" alt="image-20241115201231380"></p>
<h6 id="4-P-盒替换"><a href="#4-P-盒替换" class="headerlink" title="4.P-盒替换"></a>4.P-盒替换</h6><p>​	将SEB<sub><strong>i</strong></sub>进行P-盒置换得到PSEB<sub><strong>i</strong></sub>。</p>
<p><img src="/./../imgs/image-20241115201544932.png" alt="image-20241115201544932"></p>
<h6 id="5-与Ai进行异或"><a href="#5-与Ai进行异或" class="headerlink" title="5.与Ai进行异或"></a>5.与A<sub><strong>i</strong></sub>进行异或</h6><p>​	将PSEB<sub><strong>i</strong></sub>与A<sub><strong>i</strong></sub>进行异或，赋值给A<sub><strong>i+1</strong></sub>，将A<sub><strong>i</strong></sub>赋值给B<sub><strong>i+1</strong></sub>。</p>
<h4 id="4-逆初始置换（IP⁻¹）"><a href="#4-逆初始置换（IP⁻¹）" class="headerlink" title="4.逆初始置换（IP⁻¹）"></a>4.逆初始置换（IP⁻¹）</h4><p><img src="/./../imgs/image-20241115202459825.png" alt="image-20241115202459825"></p>
<h2 id="3-公开密钥加密算法"><a href="#3-公开密钥加密算法" class="headerlink" title="3.公开密钥加密算法"></a>3.公开密钥加密算法</h2><h2 id="4-其他算法"><a href="#4-其他算法" class="headerlink" title="4.其他算法"></a>4.其他算法</h2><h3 id="2-Base64编码"><a href="#2-Base64编码" class="headerlink" title="2.Base64编码"></a>2.Base64编码</h3><p>​	Base64编码将二进制数据编码为可显示的字母和数字，用于传送图形，声音和传真等非文本数据，<strong>常用于MIME电子邮件格式</strong>中。其使用含有65个字符的ASCII字符集，并用6个进制位表示一个可显示字符。</p>
<p><img src="/./../imgs/image-20241107183531620.png" alt="image-20241107183531620"></p>
<ul>
<li><p>Base64编过程：</p>
<ul>
<li><p>以3个字节为一组，将第一个字节放在24位缓冲区的高8位，第二个放在中8位，第三个放在低8位。</p>
</li>
<li><p>对24位缓冲区以6位为索引，高位优先，从字符串“ABCDEFGHIJKLMN<br>OPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;”中取出相应元素作为输出</p>
</li>
<li><p>如果仅有一字节或两字节输入，那么只使用输出的2~3个字节，其余用”&#x3D;“填充</p>
</li>
<li><p>“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;”即为字符集</p>
<p><img src="/./../imgs/image-20241107184614133.png" alt="image-20241107184614133"></p>
</li>
</ul>
</li>
</ul>
<p>（关于Base64的解码程序，详见PythonProject1&#x2F;Base64.py）</p>
<h3 id="3-Hex编码"><a href="#3-Hex编码" class="headerlink" title="3.Hex编码"></a>3.Hex编码</h3><p>​	Hex编码将数据以16进制数表示。</p>
<p>​	编码方式：每个字节（8位）的数据被转换为两个Hex字符。第一个字符代表字节的高4位，第二个字符代表字节的低4位。</p>
<p>​	字符集：”0123456789abcdef”</p>
<p>​	(关于Hex编码的解码程序，详见Python&#x2F;Hex.py)</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-加密与解密——解密篇1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%871/"
    >加密与解密——解密篇1</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E5%AF%86%E7%AF%871/" class="article-date">
  <time datetime="2024-12-21T10:09:14.000Z" itemprop="datePublished">2024-12-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="32位逆向技术"><a href="#32位逆向技术" class="headerlink" title="32位逆向技术"></a>32位逆向技术</h1><h2 id="1-启动函数"><a href="#1-启动函数" class="headerlink" title="1.启动函数"></a>1.启动函数</h2><ul>
<li>编写win32程序时必须在源码里实现WinMain函数。但Windows程序的执行并不从WinMain函数开始。</li>
<li>在WinMain函数启动之前，首先被执行的是启动函数的相关代码，这项工作由编译器完成。</li>
<li>启动源码可以被修改</li>
<li><em><strong><u>在分析程序的过程中，可以略过启动代码，将重心放在WinMain函数体上</u></strong></em></li>
</ul>
<h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h2><p>​	程序都过程中，是由具有不同功能的函数组成的，因此，在逆向的分析中，应将目光更多放在函数的识别及参数的传递上，让注意力集中在某一块代码上。</p>
<p>​	函数作为一个程序模块，用于实现特定的功能。一个函数包括函数名，入口参数，返回值，函数功能等部分。</p>
<hr>
<h3 id="1-函数的识别"><a href="#1-函数的识别" class="headerlink" title="1.函数的识别"></a>1.函数的识别</h3><p>​	程序调用函数，调用完毕后又返回程序，这就要求函数能够“知道”返回的程序的地址。这也是函数与其他跳转指令的区别。</p>
<p>​	事实上，调用函数的代码中保存了一个返回地址，该地址会<strong>与参数一起传递</strong>给被调用的函数。</p>
<p>​	有多种方法实现该功能，在绝大多数情况下，编译器使用call和ret指令调用函数以及返回调用位置，这也意味这在分析时可以对关键指令进行查找进而确定函数体。</p>
<hr>
<h3 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2.函数的参数"></a>2.函数的参数</h3><p>​	函数的传递有三种方式：栈方式，寄存器方式以及通过全局变量进行隐含参数传递的方式。</p>
<h4 id="1-利用栈传递参数"><a href="#1-利用栈传递参数" class="headerlink" title="1.利用栈传递参数"></a>1.利用栈传递参数</h4><p>​	栈作为“后进先出”的储存区，ESP指向栈顶，也就是栈中第一个可用的数据项。在函数调用过程中，调用者将函数依次压入栈，然后调用函数。调用结束以后，由调用者或函数本身修改栈，使栈恢复原样（即平衡栈数据）。</p>
<p>​	那么，显然地，在栈传参时有两个问题：</p>
<p>​	当参数多于一个的时候，按什么顺序压入栈？</p>
<p>​	函数调用结束后，谁来平衡栈？</p>
<p>这些需要有一个都认可的约定，这种在程序设计语言中为了实现函数调用而建立的协议称为调用约定（Calling Convention），这种协议规定了函数中的参数传送方式，参数是否可变和由谁处理栈的问题。</p>
<hr>
<h5 id="常用的调用约定"><a href="#常用的调用约定" class="headerlink" title="常用的调用约定"></a><a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">常用的调用约定</a></h5><ul>
<li>__cdecl:参数按照从右至左的顺序入栈，由调用者负责平衡栈。</li>
</ul>
<p>__cdecl(C Declaration)是C&#x2F;C++和MFC程序默认的调用约定，也可以在函数声明时加上__cdecl关键字来手动指定</p>
<ul>
<li>__pascall：参数从左至右入栈，要求被调用函数负责平衡栈。</li>
<li>__stdcall：__stdcall（Standard Call）是Win32API采用的约定方式，意为“标准调用”，采用C规范的参数入栈顺序和pascall调用约定的调整栈指针方式。</li>
</ul>
<p>​	<a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">图形说明</a></p>
<h5 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h5><ol>
<li>非优化方式：使用EBP间接寻址</li>
<li>优化方式：直接使用ESP寻址</li>
</ol>
<p>（忘了就再回去看《加密与解密》p105~107）</p>
<h4 id="2-利用寄存器传参"><a href="#2-利用寄存器传参" class="headerlink" title="2.利用寄存器传参"></a>2.利用寄存器传参</h4><p>​	寄存器传参的方式没有特定标准，取决于编译器开发人员，但都在不对兼容性进行声明的情况下遵循相应的规范，即Fastcall。顾名思义，快速。</p>
<p>​	<a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">不同编译器实现的Fastcall有所不同</a></p>
<ul>
<li>值得注意的是，另一个调用规范也用到了寄存器—thiscall</li>
<li>在采用thiscall调用约定时，参数从右至左入栈，函数负责平衡栈，仅通过一个寄存器ECX传送一个额外的参数—this指针。</li>
</ul>
<h4 id="3-名称修饰约定"><a href="#3-名称修饰约定" class="headerlink" title="3.名称修饰约定"></a>3.<a href="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》">名称修饰约定</a></h4><hr>
<h3 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3.函数的返回值"></a>3.函数的返回值</h3><p>​	函数被调用后返回一个或多个<strong>执行结果</strong>（不单指数值），称为函数返回值。返回值最常见的是return操作符，还有通过参数按传引用方式，通过全局变量返回等。</p>
<h4 id="1-用return操作符返回值"><a href="#1-用return操作符返回值" class="headerlink" title="1.用return操作符返回值"></a>1.用return操作符返回值</h4><p>​	一般情况下，函数的返回值放在EAX寄存器中返回，若处理结果的大小超出EAX寄存器的容量，那么其高32位存放在EDX中。</p>
<h4 id="2-通过参数按传引用方式返回值"><a href="#2-通过参数按传引用方式返回值" class="headerlink" title="2.通过参数按传引用方式返回值"></a>2.通过参数按传引用方式返回值</h4><p>​	给函数传递参数的方式有两种，传值和传引用。</p>
<p>​	进行传值调用时，会建立参数的一份复本，将其传入函数，在调用函数中修改参数值的复本不会影响原始的变量值。（传值）</p>
<p>​	进行传引用调用时，允许调用函数修改原始变量的值。（传指针）</p>
<p>（不懂再看《加密与解密》p110~111）</p>
<hr>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h2><p>​	数据结构是计算机储存，组织数据的方式。在进行逆向分析时，确定数据结构以后，算法就很容易得到了。当然，有时也会根据特定的算法来判断数据结构，以下是一些常见的数据结构以及汇编语言的实现方式。</p>
<h3 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h3><p>​	局部变量是函数内定义的一个变量，其作用域和生命周期局限于所在函数。使用局部变量使得程序模块化封装成为可能。从汇编的角度来看，局部变量分配空间时，通常会使用栈和寄存器。</p>
<h4 id="1-利用栈存放局部变量"><a href="#1-利用栈存放局部变量" class="headerlink" title="1.利用栈存放局部变量"></a>1.利用栈存放局部变量</h4><p>​	详见《加密与解密》p112</p>
<h4 id="2-利用寄存器存放局部变量"><a href="#2-利用寄存器存放局部变量" class="headerlink" title="2.利用寄存器存放局部变量"></a>2.利用寄存器存放局部变量</h4><p>​	除去栈占用的ESP,EBP两个寄存器，编译器会尽可能多地使用剩下的6个通用寄存器，这样可以提高程序效率，减少内存消耗。如果寄存器不够用，才考虑栈储存参数。在分析时注意，局部变量的生存周期短，必须及时确定当前寄存器存放的是哪个变量。</p>
<hr>
<h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2.全局变量"></a>2.全局变量</h3><p>​	全局变量作用于整个程序，放在全局变量的内存区中。局部变量存在于函数的栈区，函数调用结束后就消失。大多数程序中，常数一般放在全局变量中，例如一些注册版标记，测试版标记等。</p>
<p>​	全局变量通常位于数据区块（.idata）的一个固定地址处，也就是说，当程序需要访问全局变量时，一般会用一个固定的硬编码地址<strong>直接</strong>对内存寻址，这也意味着，全局变量更容易被识别。</p>
<p>​	全局变量可以被同一文件中的所有函数修改，如果某一个函数改变了全局变量的值，就可以影响其他函数。因此，全局变量可以实现传参和函数返回值。</p>
<p>​	它<strong>永远</strong>占据有内存的“一席之地”，而不像局部变量每次需要时都需要“申请”。</p>
<h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><p>​	数组是相同数据类型的集合，它们在内存中按顺序连续存放在一起。在汇编状态下访问输在一般是通过基址加变址寻址实现的。</p>
<p>​	在内存中，数组可以存在于栈，数据段及动态内存中。</p>
<p>​	一般来说，间接寻址出现在给一些数组或结构赋值的情况下，寻址形式一般为[基址+n]。基址可以为常量，也可以是寄存器，总之为定值。</p>
<hr>
<h2 id="4-虚函数"><a href="#4-虚函数" class="headerlink" title="4.虚函数"></a>4.虚函数</h2><p>​	虚函数是在程序运行时定义的函数。虚函数的地址不能在编译时确定，只能在调用<strong>即将进行</strong>时确定。</p>
<p>​	所有对虚函数的引用通常放在一个专用数组——虚函数表（Virtual Table，VTBL）中，数组的每个元素存放的就是“类”中虚函数的地址。</p>
<p>​	调用虚函数时，先取出虚函数表指针，得到虚函数表的地址，再根据这个地址到虚函数表中取出该函数的地址，最后调用该函数。</p>
<h2 id="5-控制语句"><a href="#5-控制语句" class="headerlink" title="5.控制语句"></a>5.控制语句</h2><h3 id="IF-THEN-ELSE语句"><a href="#IF-THEN-ELSE语句" class="headerlink" title="IF-THEN-ELSE语句"></a>IF-THEN-ELSE语句</h3><p>​	通常使用cmp+条件跳转实现，但许多情况下会优化使用test指令</p>
<h3 id="SWITCH-CASE语句"><a href="#SWITCH-CASE语句" class="headerlink" title="SWITCH-CASE语句"></a>SWITCH-CASE语句</h3><p>​	switch-case语句是多分支选择语句。编译之后的SWICTH语句本质是多个IF-THEN语句的嵌套。</p>
<h3 id="转移指令机器码的计算"><a href="#转移指令机器码的计算" class="headerlink" title="转移指令机器码的计算"></a>转移指令机器码的计算</h3><ol>
<li>**短转移 (Short Jump)**：无条件转移和条件转移的机器码通常为2字节，转移范围在-128到127字节内。</li>
<li>**长转移 (Long Jump)**：无条件转移的机器码为5字节，条件转移的机器码为6字节。条件转移的情况包括两类，2字节表示某转移偏移量，4字节表示目标位置。为了代码优化，CPU提供了无符号1字节偏移。</li>
<li>**子程序调用指令 (call)**：call指令用于调用子程序，一类是call label，类似于长转移，另一类常用于涉及寄存器和栈的操作，例如“call dword ptr [eax+2]”。</li>
</ol>
<p>条件转移指令由于16位CPU的遗留问题，通常只能进行255字节的转移。</p>
<p>转移指令机器码由转移类型和转移的位移量共同决定。</p>
<h3 id="纯算法实现逻辑判断"><a href="#纯算法实现逻辑判断" class="headerlink" title="纯算法实现逻辑判断"></a>纯算法实现逻辑判断</h3><p>​	在优化时，往往在不改变逻辑的情况下，用数学技巧将代码中的逻辑分支语句转换为算术操作，减少条件转移指令的出现，提高CPU性能。</p>
<hr>
<h2 id="6-循环语句"><a href="#6-循环语句" class="headerlink" title="6.循环语句"></a>6.循环语句</h2><p>​	高级语言中可以进行反向引用的一种语言形式，可以通过这种特性将其识别出来。</p>
<p>​	一般使用ECX作为计数器。或者“test eax，eax”等其他指令。</p>
<h2 id="7-数学运算符"><a href="#7-数学运算符" class="headerlink" title="7.数学运算符"></a>7.数学运算符</h2><p>​	此处仅涉及整数的四则运算的优化方式</p>
<h3 id="1-整数的加减"><a href="#1-整数的加减" class="headerlink" title="1.整数的加减"></a>1.整数的加减</h3><p>​	一般使用add，sub指令，但在一些优化方案中，常常使用lea指令来代替。</p>
<p>​	lea指令允许用户在一个时钟内完成对c&#x3D;a+b+idata的计算。其中c，a，b都是寄存器。“lea c，[a+b+idata]”</p>
<p>​	注意，lea是直接取的地址加到c中，而不是取的值。</p>
<h3 id="2-整数的乘法"><a href="#2-整数的乘法" class="headerlink" title="2.整数的乘法"></a>2.整数的乘法</h3><p>​	一般使用mul，imul指令，但运行速度慢。在优化方案中，编译器倾向于使用其他可以完成相同功能的指令来代替。</p>
<p>​	比如：若要进行2的幂运算，将使用shl指令进行左移操作。</p>
<p>​	再比如：5*eax可以写成lea eax，[eax+4*eax]。lea指令可以实现寄存器乘以2，4或8的操作。</p>
<h3 id="3-整数的除法"><a href="#3-整数的除法" class="headerlink" title="3.整数的除法"></a>3.整数的除法</h3><p>​	一般使用div，idiv指令，但除法运算的代价相当高，几乎消耗比乘法多十倍的CPU时钟。</p>
<p>​	当被除数是未知数时，那么编译器直接使用div指令。</p>
<p>​	若除数与被除数是常量的情况下则会使用一些技巧来替换div，idiv指令。</p>
<p>比如：当除数是2的幂时，会直接使用shr指令进行右移操作。而位移指令只消耗一个时钟。</p>
<hr>
<h2 id="8-文本字符串"><a href="#8-文本字符串" class="headerlink" title="8.文本字符串"></a>8.文本字符串</h2><p>​	字符串的识别与分析时软件逆向的重要步骤，特别是在对序列号的分析中。</p>
<h3 id="1-字符串储存格式"><a href="#1-字符串储存格式" class="headerlink" title="1.字符串储存格式"></a>1.字符串储存格式</h3><h4 id="（1）C字符串"><a href="#（1）C字符串" class="headerlink" title="（1）C字符串"></a>（1）C字符串</h4><p>​	也称“ASCCIIZ字符串”，广泛运用于Windows和UNIX操作系统，“Z”表示以’\0’为结束标志</p>
<h4 id="（2）DOS字符串"><a href="#（2）DOS字符串" class="headerlink" title="（2）DOS字符串"></a>（2）DOS字符串</h4><p>​	以“$”为结束标志，少见。</p>
<h4 id="（3）PASCAL字符串"><a href="#（3）PASCAL字符串" class="headerlink" title="（3）PASCAL字符串"></a>（3）PASCAL字符串</h4><p>​	无终止符，但在字符串开头使用一字节来定义字符串长度，因此最长不超过255字节，少见。</p>
<h4 id="（4）Delphi字符串"><a href="#（4）Delphi字符串" class="headerlink" title="（4）Delphi字符串"></a>（4）Delphi字符串</h4><p>​	本质是PASCAL字符串的变体，区别在于在字符串头部用2或4个字节定义长度。（双字节Delphi和四字节Delphi）。</p>
<h3 id="2-字符寻址指令"><a href="#2-字符寻址指令" class="headerlink" title="2.字符寻址指令"></a>2.字符寻址指令</h3><p>​	略</p>
<h3 id="3-大小写切换"><a href="#3-大小写切换" class="headerlink" title="3.大小写切换"></a>3.大小写切换</h3><p>​	遵循ASCII码表</p>
<h3 id="4-计算字符串长度"><a href="#4-计算字符串长度" class="headerlink" title="4.计算字符串长度"></a>4.计算字符串长度</h3><hr>
<h2 id="9-指令修改技巧"><a href="#9-指令修改技巧" class="headerlink" title="9.指令修改技巧"></a>9.指令修改技巧</h2><h1 id="64位逆向技术"><a href="#64位逆向技术" class="headerlink" title="64位逆向技术"></a>64位逆向技术</h1><h2 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h2><p>​	本节所说的x64是AMD64与Intel64的合称，是指与现有x86兼容的64位CPU。在64位系统中，内存地址为64位。x64位环境下的寄存器相较于32位有一些变化。</p>
<p>​	x64通用寄存器的名字由Exx改为Rxx，大小扩展至64位，数量增加了8个（R8~R15），扩充了8个128位的XMM寄存器（在64位程序中，XMM寄存器常用于优化代码）。</p>
<p>​	64位寄存器与32位兼容，例如RAX（64位），EAX（低32位），AX（低16位），AH，AL。新扩展的寄存器高低位访问使用D,W,B后缀，如R8（64位），R8D（低32位），R8W（低16位），R8B（低8位）。</p>
<p>​	<strong>64位系统寄存器</strong><img src="C:\Users\zhouyue\逆向学习\《加密与解密—解密篇》\64位系统寄存器.png" alt="64位系统寄存器"></p>
<h2 id="2-函数-1"><a href="#2-函数-1" class="headerlink" title="2.函数"></a>2.函数</h2><h3 id="1-栈平衡"><a href="#1-栈平衡" class="headerlink" title="1.栈平衡"></a>1.栈平衡</h3><p>​	略</p>
<h3 id="2-启动函数"><a href="#2-启动函数" class="headerlink" title="2.启动函数"></a>2.启动函数</h3><p>​	程序在运行时，先初始化函数代码，再调用main函数执行用户自己写的代码，也就是说，在程序运行时，其主函数并不放在开头，而是需要自己寻找主程序的入口。那么，如何找到主程序入口就是逆向分析的重点。</p>
<p>​	通常来说，可以直接在IDA Pro中查找main来找到main函数。如果找不到，也可以找到exit标签进行反向查找。</p>
<h3 id="3-调用约定"><a href="#3-调用约定" class="headerlink" title="3.调用约定"></a>3.调用约定</h3><p>​	x86应用程序函数调用有stdcall，__cdecl，Fstcall等方式，但x64应用程序只有一种寄存器快速调用约定。</p>
<p>​	前四个参数使用寄存器传递，如果参数超过四个，剩下的放在栈里，入栈顺序为从右至左，由函数负责平衡栈。</p>
<p>​	前四个放在固定的寄存器中，RCX（1）,RDX（2）,R8（3）,R9（4）。</p>
<p>​	任何大于8字节或者不是1，2，4，8字节的参数必须通过传引用的方式间接传参。所有浮点数的传递都是由XMM寄存器完成的。（前六个浮点型参数用XMM0~XMM5传送，超出部分用栈传送）。</p>
<p>​	<strong>前四个参数的调用约定</strong></p>
<p>​	虽然前四个参数并不使用栈空间，但栈还是为它们预留了空间（32字节），称之为预留栈空间。预留栈空间的作用是，当程序比较复杂，造成寄存器不够用的时候，可以将参数存放到预留栈空间，以此释放四个寄存器。</p>
<p>​	预留栈空间由函数的调用者提前申请，由函数调用者负责平衡栈。</p>
<h3 id="4-参数传递"><a href="#4-参数传递" class="headerlink" title="4.参数传递"></a>4.参数传递</h3><p>​	详见《加密与解密》p135~142</p>
<h3 id="5-函数返回值"><a href="#5-函数返回值" class="headerlink" title="5.函数返回值"></a>5.函数返回值</h3><p>​	64位环境下，使用RAX保存返回值。浮点类型使用MMX0寄存器返回。RAX寄存器可以保存8字节的数据，大于8字节时传引用解决。</p>
<hr>
<h2 id="3-数据结构-1"><a href="#3-数据结构-1" class="headerlink" title="3.数据结构"></a>3.数据结构</h2><p>​	与x86相似，主要是对局部变量，全局变量，数组等的访问。</p>
<h3 id="1-局部变量-1"><a href="#1-局部变量-1" class="headerlink" title="1.局部变量"></a>1.局部变量</h3><p>​	局部变量是<strong>函数</strong>内部定义的变量，存放在栈区，生命周期与函数相同。</p>
<p>函数申请的预留栈空间在低地址，声明的局部变量在高地址。</p>
<h3 id="2-全局变量-1"><a href="#2-全局变量-1" class="headerlink" title="2.全局变量"></a>2.全局变量</h3><p>​	全局变量在编译时就会确定并且固定下来，所以一般使用固定的地址去访问全局变量。</p>
<p>​	全局变量的地址先定义的在低地址，后定义的在高地址。</p>
<h3 id="3-数组-1"><a href="#3-数组-1" class="headerlink" title="3.数组"></a>3.数组</h3><p>​	数组是相同数据类型的集合，以线性方式连续储存在内存中。数组中的数据是由低到高排列的。</p>
<h4 id="（1）数组寻址公式"><a href="#（1）数组寻址公式" class="headerlink" title="（1）数组寻址公式"></a>（1）数组寻址公式</h4><p>​	一维数组：数组元素地址&#x3D;数组首地址+sizeof（数组类型）*下标</p>
<p>​	二维数组：数组元素地址&#x3D;数组首地址+sizeof（一维数组类型）*下标1+sizeof（数组类型）*下标2</p>
<h4 id="（2）一维数组和二维数组"><a href="#（2）一维数组和二维数组" class="headerlink" title="（2）一维数组和二维数组"></a>（2）一维数组和二维数组</h4><p>​	编译器访问数组的代码就是利用数组寻址公式访问的。当访问的数组下标为常量时，编译器会根据一维数组寻址公式直接计算出数组元素相对于数组首地址的偏移，比如：[ary+4*3]会被优化为[ary+12]。</p>
<p>​	但是，若下标为变量且未知，就无法进行计算进而优化，仍然是寻址公式的原始形式。二维数组同理。</p>
<p>数组特征总结如下：</p>
<ul>
<li>[数组首地址+n]</li>
<li>[数组首地址+寄存器*n]</li>
</ul>
<p>在进行逆向分析时，如果有以上特征，可以怀疑为一个数组访问。需要注意的是，在Release版本中，数组初始化时，可能会使用XMM寄存器进行优化。</p>
<h2 id="4-控制语句"><a href="#4-控制语句" class="headerlink" title="4.控制语句"></a>4.控制语句</h2><p>​	因为应用程序中存在大量的流程控制语句，所以识别流程控制语句是逆向分析的基础。这里主要介绍两种快速识别控制语句的方法，特征识别法和图形识别法。</p>
<h3 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h3><p>​	if语句是分支结构的重要组成部分，功能是，判断，非0则真，跳转，执行。因为汇编语言的逻辑问题，编译器生成的汇编代码会对表达式结果取反。</p>
<ul>
<li>特征识别：</li>
</ul>
<p>​	首先有一个jxx指令用于向下跳转，且跳转的目的地if_end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。</p>
<p><img src="/./../imgs/image-20241102214222867.png" alt="image-20241102214222867"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	在逆向分析工具中，为了方便的表示跳转的位置，使用虚线箭头表示条件跳转jxx，使用实线箭头表示无条件jmp。</p>
<h3 id="2-if……else语句"><a href="#2-if……else语句" class="headerlink" title="2.if……else语句"></a>2.if……else语句</h3><ul>
<li>特征识别：</li>
</ul>
<p>​	jxx指令用于向下跳转，且跳转的目的else中可以有jmp指令，但是else的结尾没有jmp指令，else的代码也会执行if_else_end的代码。</p>
<p><img src="/./../imgs/image-20241102220711805.png" alt="image-20241102220711805"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h3 id="3-if……else-if……else语句"><a href="#3-if……else-if……else语句" class="headerlink" title="3.if……else if……else语句"></a>3.if……else if……else语句</h3><p>​	多分支结构。</p>
<ul>
<li>特征识别：</li>
</ul>
<p>​	首先有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if跳转的目的else中可以有jmp指令，且else代码的结尾没有无条件跳转jmp。所有jmp的目标地址一致。</p>
<p><img src="/./../imgs/image-20241102222940769.png" alt="image-20241102222940769"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	见上图。</p>
<h3 id="4-switch—case语句"><a href="#4-switch—case语句" class="headerlink" title="4.switch—case语句"></a>4.switch—case语句</h3><p>​	switch是常用的多分支结构。通常比if语句有更高的效率。编译器有多种优化方案，当swicth分支数小于6时会直接使用if……else语句来实现，大于等于6时则会进行优化。比如：case表</p>
<p>​	当case&gt;&#x3D;6，且case值的间隔小时，将所有要跳转的case位置偏移放在一个一维数组的表中（case表），然后把case的值当作下标进行跳转，就可以避免使用if，从而使程序不那么冗长。</p>
<p>​	例如，switch（argc）只需要将argc-idata当作case表的下标，得出偏移，直接跳转过去。但是，为什么不直接将argc当作下标？</p>
<p><img src="/./../imgs/image-20241102230359416.png" alt="image-20241102230359416"></p>
<p>如果出现一个代码如下，并且直接将argc的值当作下标，那么建立起一个case表将需要101项，但事实上，能起作用的只有两项，其他都是swicth结束地址偏移，对空间的浪费不可估量。因此，将argc-idata再建表就只需要两项。</p>
<p><img src="/./../imgs/image-20241102230820870.png" alt="image-20241102230820870"></p>
<p>再比如：判定树</p>
<p>​	当实现swicth的if语句很多时，采用另一种优化方案——判定树。将每个case作为一个节点，从这些节点中找到中间值作为根节点，形成二叉平衡树。从根节点开始判定，这样就可以大大减少跳转的次数。</p>
<p><img src="/./../imgs/image-20241102231510971.png" alt="image-20241102231510971"></p>
<h3 id="5-转移指令的机器码"><a href="#5-转移指令的机器码" class="headerlink" title="5.*转移指令的机器码"></a>5.*转移指令的机器码</h3><p><img src="/./../imgs/image-20241102231631517.png" alt="image-20241102231631517"></p>
<h2 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5.循环语句"></a>5.循环语句</h2><p>​	对于C&#x2F;C++来说，循环语法有三种，do，while，for。虽然三者功能相同，但是不同的语法有不同的执行流程。</p>
<h3 id="1-do循环"><a href="#1-do循环" class="headerlink" title="1.do循环"></a>1.do循环</h3><ul>
<li>特征识别：</li>
</ul>
<p>​	首先会有jxx指令用于<strong>向上</strong>跳转，且跳转的do_while_start语句中没有jxx指令。根据以上特征，jxx指令在反推高级语言时不取反。</p>
<p><img src="/./../imgs/image-20241103125645809.png" alt="image-20241103125645809"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><p>​	循环的特征是会向低地址跳转。在while循环中向低地址跳转的情况与do不一样，while使用的是无条件跳转jmp指令，while循环的jxx指令要取反。</p>
<p>​	值得注意的是，同样的循环次数下while循环会会比do多一次条件判断，性能上不如do。在Release版本中，编译器会把while优化为等价的do循环。</p>
<ul>
<li>特征识别：</li>
</ul>
<p>​	首先会有一个jmp向上跳转指令，且跳转的目的while_start下面有jxx跳转指令。while代码也会执行while_end的代码。根据以上特征，在反推高级语言代码时，需要对jxx取反。</p>
<p><img src="/./../imgs/image-20241103130715258.png" alt="image-20241103130715258"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h3><ul>
<li>特征识别：</li>
</ul>
<p>​	for循环也出现向上跳转，但是与while循环不同的是，这里前面多了一个jmp指令。for循环的返回汇编需要取反。</p>
<p><img src="/./../imgs/image-20241103131625076.png" alt="image-20241103131625076"></p>
<ul>
<li>图形识别：</li>
</ul>
<p>​	如上图。</p>
<h2 id="6-数学运算符"><a href="#6-数学运算符" class="headerlink" title="6.数学运算符"></a>6.数学运算符</h2><p>​	虽然整数的四则运算在汇编代码中都有对应的指令，但是，在Release版本中往往会对其进行优化。</p>
<h3 id="1-整数的加减-1"><a href="#1-整数的加减-1" class="headerlink" title="1.整数的加减"></a>1.整数的加减</h3><h4 id="（1）lea指令"><a href="#（1）lea指令" class="headerlink" title="（1）lea指令"></a>（1）lea指令</h4><p>​	与在32位逆向技术中一样，略。</p>
<h4 id="（2）常量折叠"><a href="#（2）常量折叠" class="headerlink" title="（2）常量折叠"></a>（2）常量折叠</h4><p>​	常量折叠优化是指当表达式出现两个以上常量进行计算的情况时，编译器可以在编译时就对其进行计算，并用计算结果替换表达式，这样就不用在程序运行期间进行计算，从而提高程序性能。</p>
<p><img src="/./../imgs/image-20241103133445088.png" alt="image-20241103133445088"></p>
<h3 id="2-整数的乘法-1"><a href="#2-整数的乘法-1" class="headerlink" title="2.整数的乘法"></a>2.整数的乘法</h3><p>​	编译器常使用lea比例因子寻址来优化乘法指令。</p>
<p><img src="/./../imgs/image-20241103135158439.png" alt="image-20241103135158439"></p>
<h3 id="3-整数的除法-1"><a href="#3-整数的除法-1" class="headerlink" title="3.整数的除法"></a>3.整数的除法</h3><p>​	除法指令的执行周期太长，因此许多编译器会尽可能用其他指令来代替除法指令，通常情况下，优化方法是转换成等价位移或乘法运算。</p>
<p>​	但是，计算机的除法与数学中的除法有所不同，计算机中整数除法是取整的除法，因此在位移时需要进行修正。</p>
<h4 id="（1）有符号除法，除数为2n"><a href="#（1）有符号除法，除数为2n" class="headerlink" title="（1）有符号除法，除数为2n"></a>（1）有符号除法，除数为2<sup>n</sup></h4><p>​	当除数为2<sup>n</sup>时，编译器一般会使用位移优化。数学优化公式为：若x&gt;&#x3D;0,x&#x2F;2<sup>n</sup>&#x3D;x&gt;&gt;n;如果x&lt;0,则x&#x2F;2<sup>n</sup>&#x3D;(x+(2<sup>n</sup>-1))&gt;&gt;n。</p>
<h4 id="（2）有符号除法，除数为-2n"><a href="#（2）有符号除法，除数为-2n" class="headerlink" title="（2）有符号除法，除数为-2n"></a>（2）有符号除法，除数为-2<sup>n</sup></h4><p>​	当除数为-2<sup>n</sup>时，相比于（1）多了一个求补的过程。数学优化公式为：若x&gt;&#x3D;0,x&#x2F;2<sup>n</sup>&#x3D;-(x&gt;&gt;n);如果x&lt;0,则x&#x2F;2<sup>n</sup>&#x3D;-{(x+(2<sup>n</sup>-1))&gt;&gt;n}。</p>
<h4 id="（3）-有符号除法，除数为正非2n"><a href="#（3）-有符号除法，除数为正非2n" class="headerlink" title="（3）*有符号除法，除数为正非2n"></a>（3）*有符号除法，除数为正非2<sup>n</sup></h4><h4 id="（4）-有符号除法，除数为负非2n"><a href="#（4）-有符号除法，除数为负非2n" class="headerlink" title="（4）*有符号除法，除数为负非2n"></a>（4）*有符号除法，除数为负非2<sup>n</sup></h4><h4 id="（5）无符号除法，除数为2n"><a href="#（5）无符号除法，除数为2n" class="headerlink" title="（5）无符号除法，除数为2n"></a>（5）无符号除法，除数为2<sup>n</sup></h4><p>​	直接shr右移即可。</p>
<h4 id="（6）-无符号除法，除数为正非2n"><a href="#（6）-无符号除法，除数为正非2n" class="headerlink" title="（6）*无符号除法，除数为正非2n"></a>（6）*无符号除法，除数为正非2<sup>n</sup></h4><h4 id="（7）-无符号除法，除数为负非2n"><a href="#（7）-无符号除法，除数为负非2n" class="headerlink" title="（7）*无符号除法，除数为负非2n"></a>（7）*无符号除法，除数为负非2<sup>n</sup></h4><p>[打*号的部分着重看《加密与解密》p161~167]</p>
<h3 id="4-整数得取模"><a href="#4-整数得取模" class="headerlink" title="4.整数得取模"></a>4.整数得取模</h3><h4 id="（1）除数为2n"><a href="#（1）除数为2n" class="headerlink" title="（1）除数为2n"></a>（1）除数为2<sup>n</sup></h4><p><img src="/./../imgs/image-20241103152218849.png" alt="image-20241103152218849"></p>
<h4 id="（2）除数为非2n"><a href="#（2）除数为非2n" class="headerlink" title="（2）除数为非2n"></a>（2）除数为非2<sup>n</sup></h4><p>​	编译器一般采用”余数&#x3D;被除数-商*除数“的方式进行优化。</p>
<hr>
<h2 id="7-虚函数"><a href="#7-虚函数" class="headerlink" title="7.虚函数"></a>7.虚函数</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/Linux/"
    >Linux</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/Linux/" class="article-date">
  <time datetime="2024-12-21T10:07:28.000Z" itemprop="datePublished">2024-12-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一-初识Linux"><a href="#一-初识Linux" class="headerlink" title="一.初识Linux"></a>一.初识Linux</h1><h2 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1.操作系统"></a>1.操作系统</h2><p>​	操作系统是计算机软件的一种，用于管理和调度硬件。它由内核（特权级）和系统级应用程序（用户级）。</p>
<p>​	常见的操作系统有Windows，Mac，Linux，IOS，Android，鸿蒙。</p>
<p>对于PC端的操作系统，Windows和Mac来说，Linux更注重于对服务器硬件和软件进行管理和调用。</p>
<h2 id="2-Linux初识"><a href="#2-Linux初识" class="headerlink" title="2.Linux初识"></a>2.Linux初识</h2><ul>
<li><p>内核：Linux的内核提供系统的主要功能，如硬件调度管理的能力，是免费开源的</p>
</li>
<li><p>Linux系统发行版：</p>
</li>
</ul>
<p>​	光有内核无法被用户使用，需要配合应用程序才能被用户使用。</p>
<p>​	在内核之上，封装系统级应用程序，组合在一起称之为Linux发行版。</p>
<p>本篇主要对CentOS进行学习。</p>
<h2 id="3-远程连接Linux系统"><a href="#3-远程连接Linux系统" class="headerlink" title="3.远程连接Linux系统"></a>3.远程连接Linux系统</h2><p>​	使用FinalShell跨越虚拟机，从而在windows系统上远程操控Linux</p>
<h2 id="4-WSL-Windows-Subsystem-for-Linux"><a href="#4-WSL-Windows-Subsystem-for-Linux" class="headerlink" title="4.WSL(Windows Subsystem for Linux)"></a>4.WSL(Windows Subsystem for Linux)</h2><p>​	直连计算机真机硬件来构建一个完整的Linux系统，而无需通过虚拟机使用虚拟计算机硬件来构建完整系统</p>
<h2 id="5-虚拟机快照"><a href="#5-虚拟机快照" class="headerlink" title="5.虚拟机快照"></a>5.虚拟机快照</h2><p>​	说人话就是存档</p>
<p>​	<strong>在VMware中制作快照</strong>：</p>
<h1 id="二-Linux基础命令"><a href="#二-Linux基础命令" class="headerlink" title="二.Linux基础命令"></a>二.Linux基础命令</h1><h2 id="1-Linux系统目录结构"><a href="#1-Linux系统目录结构" class="headerlink" title="1.Linux系统目录结构"></a>1.Linux系统目录结构</h2><ul>
<li><p>Linux系统目录是树状，并且有且仅有一个树根&#x2F;，也就是说，Linux系统目录的顶级目录有且仅有一个“&#x2F;”，所有的文件都在它之下。</p>
</li>
<li><p>Linux的路径描述：Linux不同于Windows，它的层级关系是用“&#x2F;”来描述的，而Windows是用“\”来描述的。</p>
</li>
</ul>
<h2 id="2-Linux命令入门"><a href="#2-Linux命令入门" class="headerlink" title="2.Linux命令入门"></a>2.Linux命令入门</h2><h3 id="1-Linux中所有的命令都有统一的格式："><a href="#1-Linux中所有的命令都有统一的格式：" class="headerlink" title="1.Linux中所有的命令都有统一的格式："></a>1.Linux中所有的命令都有统一的格式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command [-options] [parameter]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>command:命令本身</p>
</li>
<li><p>-options:命令的一些选项，可以通过选项控制命令的行为细节</p>
</li>
<li><p>parameter:命令的参数，多数用于命令的指向目标等</p>
</li>
</ul>
<h3 id="2-ls命令"><a href="#2-ls命令" class="headerlink" title="2.ls命令"></a>2.ls命令</h3><ul>
<li>ls命令的作用是列出目录下的内容，语法细节如下：</li>
</ul>
<p>​	ls [-a -l -h] [Linux路径]</p>
<ul>
<li>当不使用选项和参数时，直接使用ls命令的本体，表示：以平铺形式，列出当前工作目录下的内容，如果不指定目录，那么将打开HOME目录</li>
<li>-a:列出全部目录(包含隐藏的文件和文件夹)</li>
<li>-l:以列表(竖向排列)的形式展示内容，并展示更多信息</li>
<li>-h:表示易于阅读的形式，列出文件大小，-h必须与-l一起使用</li>
</ul>
<h2 id="3-目录切换相关命令"><a href="#3-目录切换相关命令" class="headerlink" title="3.目录切换相关命令"></a>3.目录切换相关命令</h2><h3 id="1-cd-ChangeDirectory-命令切换工作目录"><a href="#1-cd-ChangeDirectory-命令切换工作目录" class="headerlink" title="1.cd(ChangeDirectory)命令切换工作目录"></a>1.cd(ChangeDirectory)命令切换工作目录</h3><ul>
<li><p>Linux会默认工作目录为&#x2F;home，通过cd可以改变工作目录</p>
</li>
<li><p>cd命令语法：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [Linux路径]</span><br></pre></td></tr></table></figure>

<ul>
<li>当cd没有Linux路径时，会回到&#x2F;home</li>
<li>当cd有Linux路径时，会打开路径目录，并切换工作目录为路径目录</li>
</ul>
<h3 id="2-pwd-PrintWorkDirectory-查看当前工作目录"><a href="#2-pwd-PrintWorkDirectory-查看当前工作目录" class="headerlink" title="2.pwd(PrintWorkDirectory)查看当前工作目录"></a>2.pwd(PrintWorkDirectory)查看当前工作目录</h3><ul>
<li>pwd命令语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<ul>
<li>pwd无选项，无参数</li>
</ul>
<h2 id="4-相对路径、绝对路径和特殊路径符"><a href="#4-相对路径、绝对路径和特殊路径符" class="headerlink" title="4.相对路径、绝对路径和特殊路径符"></a>4.相对路径、绝对路径和特殊路径符</h2><ul>
<li><p>相对路径：以当前工作目录为起点描述路径(无需以”&#x2F;“起手)</p>
</li>
<li><p>绝对路径：以根目录为起点描述路径(“&#x2F;“起手)</p>
</li>
<li><p>特殊路径符：</p>
<ul>
<li><p>“.”  :表示当前路径，cd .&#x2F;Desktop &#x3D;&#x3D; cd Desktop</p>
</li>
<li><p>“..”  :表示上一级目录，eg:</p>
<p>假设：现在的工作目录的绝对路径为&#x2F;home&#x2F;zhouyue</p>
<p>那么：cd ..将切换到&#x2F;home</p>
<p>​	    cd ..&#x2F;.. 将切换到&#x2F;</p>
</li>
<li><p>“~”  :表示home目录，cd ~即可切换到home目录，eg:</p>
<p>cd ~ 切换到home</p>
<p>cd ~&#x2F;zhouyue 切换到zhouyue</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-创建目录命令"><a href="#5-创建目录命令" class="headerlink" title="5.创建目录命令"></a>5.创建目录命令</h2><ul>
<li><p>通过mkdir命令可以创建新的目录</p>
</li>
<li><p>mkdir(MakeDirectory)命令：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li>参数必填，没路径创牛魔的目录啊</li>
<li>-p：表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<p>​	eg:如果要创建一条全新的多层级目录，比如：</p>
<p>​	local&#x2F;test03</p>
<p>​	需要加-p ,也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p local/test03</span><br><span class="line">#注意，这里创建的多层级目录的&quot;根&quot;是当前工作目录</span><br></pre></td></tr></table></figure>

<p>创建文件夹需要修改权限，也就是说如果不涉及权限修改，那么仅能在home目录中进行创建</p>
<h2 id="6-文件操作命令"><a href="#6-文件操作命令" class="headerlink" title="6.文件操作命令"></a>6.文件操作命令</h2><ul>
<li>touch创建文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li>cat查看文件内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li>more查看文件内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more Linux路径</span><br></pre></td></tr></table></figure>

<ul>
<li><p>同样是查看命令，cat会将所有内容显示，而more会分页显示</p>
</li>
<li><p>cp复制文件&#x2F;文件夹</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [-r] param1 param2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-r :复制文件夹时使用，表示递归</p>
</li>
<li><p>param1 :Linux路径，表示被复制的文件&#x2F;文件夹</p>
</li>
<li><p>param2 :Linux路径，表示要复制去的地方</p>
</li>
<li><p>mv移动文件&#x2F;文件夹</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv param1 param2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>param1 :Linux路径，表示被移动的文件&#x2F;文件夹</p>
</li>
<li><p>param2 :Linux路径，表示要移动过去的地方，如果目标不存在，则进行改名，确保目标存在</p>
</li>
<li><p>rm删除文件&#x2F;文件夹</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-r/-f] param1,param2,……,paramn</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-r :表示删除文件夹</p>
</li>
<li><p>-f(force) :表示强制删除</p>
</li>
<li><p>多个参数表示其可以同时删除多个文件&#x2F;文件夹</p>
</li>
<li><p>通配符<code>*</code></p>
</li>
<li><p>Linux中rm命令支持通配符做模糊匹配</p>
</li>
<li><p><code>test*</code>:匹配任意以test开头的内容</p>
</li>
<li><p><code>*test</code>:匹配任意以test结尾的内容</p>
</li>
<li><p><code>*test*</code>:匹配任意包含test的内容</p>
</li>
</ul>
<h2 id="7-查找命令"><a href="#7-查找命令" class="headerlink" title="7.查找命令"></a>7.查找命令</h2><ul>
<li>which查找命令的程序文件存放地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which command</span><br></pre></td></tr></table></figure>

<ul>
<li>find按文件名查找文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find start_path -name &quot;file_name&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>find按文件大小查找文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find start_path -size +(geater)/-(smaller)n[k/M/G]</span><br></pre></td></tr></table></figure>

<ul>
<li>n表示单位，k表示kb，M表示MB，G表示GB</li>
</ul>
<h2 id="8-grep、wc和管道符"><a href="#8-grep、wc和管道符" class="headerlink" title="8.grep、wc和管道符"></a>8.grep、wc和管道符</h2><ul>
<li>grep通过关键字过滤文件行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-n] &quot;key_word&quot; file_path</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-n:显示匹配行的行号</p>
</li>
<li><p>wc做数量统计</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [-c -m -l -w] file_path</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-c:统计bytes数量</p>
</li>
<li><p>-m:统计字符数量</p>
</li>
<li><p>-l:统计行数</p>
</li>
<li><p>-w:统计单词数量(以空格划分)</p>
</li>
<li><p>什么都不加默认输出bytes数量、行数、单词数量</p>
</li>
<li><p>file_path可以作内容输入端口</p>
</li>
<li><p>管道符”|”</p>
</li>
</ul>
<p>​	管道符会将其左边的结果作为右边命令的输入</p>
<p>​	eg:wc | cat test01.txt</p>
<h2 id="9-echo、tail和重定向符"><a href="#9-echo、tail和重定向符" class="headerlink" title="9.echo、tail和重定向符"></a>9.echo、tail和重定向符</h2><ul>
<li>echo在命令行输出指定内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;content&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>飘号&#96;</li>
</ul>
<p>​	在echo命令中，飘号中的会被认为是命令而不是content</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `pwd`</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重定向符</p>
<ul>
<li><code>&gt;</code>:将左侧命令的结果<strong>覆盖</strong>到右侧的文件中</li>
<li><code>&gt;&gt;</code>:将左侧命令的结果<strong>追加</strong>到右侧的文件中</li>
</ul>
</li>
<li><p>tail查看文件尾部内容，跟踪文件的最新更改</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-f -num] file_path</span><br></pre></td></tr></table></figure>

<ul>
<li>-f:表示持续跟踪</li>
<li>-num:表示查看尾部多少行，不填默认十行</li>
</ul>
<h2 id="10-vi-vim编辑器"><a href="#10-vi-vim编辑器" class="headerlink" title="10.vi&#x2F;vim编辑器"></a>10.vi&#x2F;vim编辑器</h2><p><img src="/./../imgs/image-20241204212354233.png" alt="image-20241204212354233"></p>
<p>以下是一些常用的命令模式快捷键：</p>
<ol>
<li><p><strong>光标移动</strong>：</p>
<ul>
<li><code>h</code>: 向左移动光标</li>
<li><code>j</code>: 向下移动光标</li>
<li><code>k</code>: 向上移动光标</li>
<li><code>l</code>: 向右移动光标</li>
<li><code>w</code>: 跳到下一个单词的开头</li>
<li><code>b</code>: 跳到上一个单词的开头</li>
<li><code>0</code>: 跳到行首</li>
<li><code>$</code>: 跳到行尾</li>
</ul>
</li>
<li><p><strong>文本编辑</strong>：</p>
<ul>
<li><code>i</code>: 切换到插入模式</li>
<li><code>a</code>: 在光标后插入并切换到插入模式</li>
<li><code>o</code>: 在当前行下插入新行并切换到插入模式</li>
<li><code>x</code>: 删除当前字符</li>
<li><code>dd</code>: 删除当前行</li>
<li><code>yy</code>: 复制当前行</li>
<li><code>p</code>: 粘贴</li>
</ul>
</li>
<li><p><strong>查找和替换</strong>：</p>
<ul>
<li><code>/pattern</code>: 向前查找 <code>pattern</code></li>
<li><code>?pattern</code>: 向后查找 <code>pattern</code></li>
<li><code>n</code>: 跳到下一个匹配项</li>
<li><code>N</code>: 跳到上一个匹配项</li>
<li><code>:s/old/new/g</code>: 将当前行中的 <code>old</code> 替换为 <code>new</code></li>
<li><code>:%s/old/new/g</code>: 替换整个文件中的 <code>old</code> 为 <code>new</code></li>
</ul>
</li>
<li><p><strong>保存和退出</strong>：</p>
<ul>
<li><code>:w</code>: 保存文件</li>
<li><code>:q</code>: 退出</li>
<li><code>:wq</code>: 保存并退出</li>
<li><code>:q!</code>: 强制退出不保存</li>
</ul>
</li>
</ol>
<h1 id="三-Linux用户和权限"><a href="#三-Linux用户和权限" class="headerlink" title="三.Linux用户和权限"></a>三.Linux用户和权限</h1><h2 id="1-Linux的root用户"><a href="#1-Linux的root用户" class="headerlink" title="1.Linux的root用户"></a>1.Linux的root用户</h2><p>​	Linux中允许配置多个用户和用户组，这是因为Linux的权限管控分针对用户和针对用户组两个级别。</p>
<ul>
<li><p>用户组管理(root权限下)</p>
<ul>
<li><p>groupadd user_group_name创建用户组</p>
</li>
<li><p>groupdel  user_group_name删除用户组</p>
</li>
</ul>
</li>
<li><p>用户管理(root权限下)</p>
<ul>
<li><p>useradd [-g -d] user_name</p>
<ul>
<li>-g:指定用户的<strong>组</strong>，如果不加-g,会创建同名用户组并自动加入，指定-g要求组已经存在，如已存在同名组，必须使用-g</li>
<li>-d:指定用户的home目录，不指定，home目录默认为：&#x2F;home&#x2F;user_name</li>
</ul>
</li>
<li><p>userdel [-r] user_name</p>
<ul>
<li>-r:删除用户的home目录，如果不使用-r，删除用户时会保留home目录</li>
</ul>
</li>
<li><p>id [user_name]</p>
<ul>
<li>如果不提供用户名则查看自身</li>
</ul>
</li>
<li><p>usermod -aG user_group user_name</p>
<ul>
<li>将指定用户加入指定用户组</li>
</ul>
</li>
<li><p>getent passwd</p>
<ul>
<li><p>查看当前系统中的用户，弹出来的信息从左往右依次代表：</p>
<p>用户名:密码(x):用户ID:组ID:描述信息:home目录:执行终端</p>
</li>
</ul>
</li>
<li><p>getent group</p>
<ul>
<li><p>查看系统中的组，包含三份信息：</p>
<p>组名称:组认证(x):组ID</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-查看权限控制信息"><a href="#2-查看权限控制信息" class="headerlink" title="2.查看权限控制信息"></a>2.查看权限控制信息</h2><p>​	当我们只用ls -l查看时，会出现以下信息：</p>
<p><img src="/./../imgs/image-20241205213116859.png" alt="image-20241205213116859"></p>
<p>从左往右，第一个红框内表示文件&#x2F;文件夹的权限控制信息，第二个是该文件&#x2F;文件夹归属于哪个用户，第三个是该用户归属于哪个用户组</p>
<ul>
<li>认知权限细节</li>
</ul>
<p><img src="/./../imgs/image-20241205213414552.png" alt="image-20241205213414552"></p>
<h2 id="3-chmod命令"><a href="#3-chmod命令" class="headerlink" title="3.chmod命令"></a>3.chmod命令</h2><p>只有文件&#x2F;文件夹的所属用户或者root用户才可以对其进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] power file/folder</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-R:对文件夹内的全部内容应用同样的操作</p>
</li>
<li><p>权限的数字代号</p>
<ul>
<li><p><code>rwx</code> (读、写、执行) &#x3D; 4 + 2 + 1 &#x3D; 7</p>
</li>
<li><p><code>rw-</code> (读、写) &#x3D; 4 + 2 + 0 &#x3D; 6</p>
</li>
<li><p><code>r--</code> (读) &#x3D; 4 + 0 + 0 &#x3D; 4</p>
</li>
<li><p><code>r-x</code> (读、执行) &#x3D; 4 + 0 + 1 &#x3D; 5</p>
</li>
<li><p><code>-wx</code> (写、执行) &#x3D; 0 + 2 + 1 &#x3D; 3</p>
</li>
<li><p><code>--x</code> (执行) &#x3D; 0 + 0 + 1 &#x3D; 1</p>
</li>
<li><p><code>---</code> (无权限) &#x3D; 0</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-chown"><a href="#4-chown" class="headerlink" title="4.chown"></a>4.chown</h2><p>此命令仅限root用户使用</p>
<p>chown命令可以修改文件&#x2F;文件夹的所属用户或者组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] [user][:][user_group] file/folder</span><br></pre></td></tr></table></figure>





<h1 id="四-Linux的实用命令"><a href="#四-Linux的实用命令" class="headerlink" title="四.Linux的实用命令"></a>四.Linux的实用命令</h1><h2 id="1-systemctl"><a href="#1-systemctl" class="headerlink" title="1.systemctl"></a>1.systemctl</h2><p>systemctl可以管理Linux的一些内置服务(其实就是软件)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start|stop|status|enable|disable</span><br></pre></td></tr></table></figure>

<p>同时system也可以管理一些第三方软件，只要软件有注册服务的功能</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >前端学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2024-12-21T10:06:47.000Z" itemprop="datePublished">2024-12-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端学习笔记"><a href="#前端学习笔记" class="headerlink" title="前端学习笔记"></a>前端学习笔记</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><ul>
<li><p>HTML(Hypertext Markup Language)，通过一系列的**标签(或者说元素)**来定义文本，图像，链接等。HTML标签是由尖括号包围的关键字。</p>
</li>
<li><p>标签通常成对出现，包括开始标签和结束标签，内容位于这两个标签之内，eg:</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是一个超链接。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>除了双标签，也存在单标签，eg:</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>区别：单标签用于没有内容的元素，双标签用于有内容的元素</p>
<h3 id="HTML文件结构"><a href="#HTML文件结构" class="headerlink" title="HTML文件结构"></a>HTML文件结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里放置文档的元信息 -- &gt;</span></span><br><span class="line"><span class="comment">&lt;! DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">    &lt;head&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 这里放置文档的元信息 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;title&gt;文档标题&lt;/title&gt;</span></span><br><span class="line"><span class="comment">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 连接外部样式表或脚本文件等 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;/head&gt;</span></span><br><span class="line"><span class="comment">    &lt;body&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 这里放置页面内容 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;h1&gt;这是一个标题&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">        &lt;p&gt;这是一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        &lt;a href=&quot;https://www.example.com&quot;&gt;这是一个链接&lt;/a&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 其他内容 -- &gt;</span></span><br><span class="line"><span class="comment">    &lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML的常用标签"><a href="#HTML的常用标签" class="headerlink" title="HTML的常用标签"></a>HTML的常用标签</h3><p>详见test01.html</p>
<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><ul>
<li>HTML的属性用于定义元素的行为和外观，以及其他元素的关系</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">start_label</span> <span class="attr">attribute_name</span>=<span class="string">&quot;attribute_value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>每个HTML元素可以具有不同的属性</li>
<li>属性名大小写不敏感，属性值大小写敏感</li>
</ul>
<h3 id="HTML区块"><a href="#HTML区块" class="headerlink" title="HTML区块"></a>HTML区块</h3><ul>
<li><p>块元素</p>
<p>块级元素通常用于组织和布局页面的主要结构内容。它们用于创建页面的主要部分，将内容分割为<strong>逻辑块</strong>。</p>
<ul>
<li>块级元素通常从新行开始，并占据整行的宽度，因此它们会在页面上呈现为一块独立的内容块</li>
<li>可以包含其他块级元素和行内元素</li>
</ul>
</li>
<li><p>行内元素</p>
<ul>
<li>无法包含块级元素，仅能包含行内元素</li>
</ul>
</li>
</ul>
<h4 id="标签"><a href="#标签" class="headerlink" title="&lt;div&gt;标签"></a><code>&lt;div&gt;</code>标签</h4><ul>
<li><strong>块级元素</strong>：<code>&lt;div&gt;</code>是一个块级元素，意味着它会独占一行，前后有换行。</li>
<li><strong>结构性</strong>：通常用于对页面内容进行分组，帮助组织和布局。可以包含其他块级和行内元素。</li>
<li><strong>样式和脚本</strong>：通常与CSS和JavaScript一起使用，以便对特定部分的样式进行控制或添加交互功能。</li>
<li><strong>常见用途</strong>：用于创建页面的布局结构，比如头部、侧边栏、内容区域和页脚等。</li>
</ul>
<h4 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;span&gt;标签"></a><code>&lt;span&gt;</code>标签</h4><ul>
<li><strong>行内元素</strong>：<code>&lt;span&gt;</code>是一个行内元素，意味着它不会独占一行，通常用于对文本或其他行内元素进行样式化。</li>
<li><strong>无语义</strong>：<code>&lt;span&gt;</code>本身没有语义，仅用于样式和布局，通常与CSS一起使用来改变文本的样式。</li>
<li><strong>常见用途</strong>：用于包裹部分文本，应用特定的样式或脚本，比如改变颜色、字体或添加事件监听</li>
</ul>
<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><ul>
<li>HTML表单是用于收集用户输入数据的结构化元素。通过表单，用户可以输入信息并将其提交到服务器进行处理。HTML表单通常包含各种输入元素，例如文本框、单选按钮、复选框、下拉列表等</li>
</ul>
<p>关于表单的创建，有以下需要注意的点：</p>
<ol>
<li>所有表单需要在form标签下</li>
<li>常用于表单的标签有：<ol>
<li>label：用于描述表单控件的标签</li>
<li>input：各种类型的输入控件</li>
</ol>
</li>
</ol>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的三种导入方式"><a href="#CSS的三种导入方式" class="headerlink" title="CSS的三种导入方式"></a>CSS的三种导入方式</h3><p>内联样式&gt;内部样式表&gt;外部样式表</p>
<p>详见test02.html</p>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>选择器是CSS中的关键部分，它允许针对特定元素或一组元素定义样式</p>
<p>ID&gt;类&gt;标签名</p>
<h3 id="CSS网页布局"><a href="#CSS网页布局" class="headerlink" title="CSS网页布局"></a>CSS网页布局</h3><p>略</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>轻量级的解释型脚本语言，常用于网页交互和客户端脚本开发</p>
<h3 id="JS的导入"><a href="#JS的导入" class="headerlink" title="JS的导入"></a>JS的导入</h3><p>同CSS，只不过在<code>&lt;script&gt;&lt;/script&gt;</code>标签中写罢了</p>
<h3 id="JS的变量和数据类型"><a href="#JS的变量和数据类型" class="headerlink" title="JS的变量和数据类型"></a>JS的变量和数据类型</h3><p><strong>在JavaScript中，<code>const</code>用于声明常量，<code>var</code> 和 <code>let</code> 都是用来声明变量的方法，但它们有一些重要的区别：</strong></p>
<h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><ul>
<li>**<code>var</code>**：具有函数作用域（function scope）。这意味着在一个函数内声明的 <code>var</code> 变量在整个函数中都是可见的。</li>
<li>**<code>let</code>**：具有块级作用域（block scope）。这意味着在一个块（例如花括号 <code>&#123;&#125;</code>）内声明的 <code>let</code> 变量只在这个块内部可见。</li>
</ul>
<h3 id="2-变量提升"><a href="#2-变量提升" class="headerlink" title="2. 变量提升"></a>2. 变量提升</h3><ul>
<li>**<code>var</code>**：变量声明会被提升（hoisting）到函数或全局作用域的顶部，但赋值不会提升。因此，可以在声明之前使用，但值为 <code>undefined</code>。</li>
<li>**<code>let</code>**：变量声明不会被提升，或者说会被提升但不会初始化。在声明之前使用 <code>let</code> 变量会导致 ReferenceError 错误。</li>
</ul>
<h3 id="3-重复声明"><a href="#3-重复声明" class="headerlink" title="3. 重复声明"></a>3. 重复声明</h3><ul>
<li>**<code>var</code>**：可以在同一作用域内多次声明同一个变量。</li>
<li>**<code>let</code>**：在同一作用域内不能重复声明同一个变量。</li>
</ul>
<p>现在的代码中尽量使用let而不是var，但是也不是什么要紧的事，由于前端三大件语法的简单，AI已经可以很好地写很漂亮的代码，不需要自己写，仅作了解即可</p>
<h2 id="JS的数据类型与变量"><a href="#JS的数据类型与变量" class="headerlink" title="JS的数据类型与变量"></a>JS的数据类型与变量</h2><p>略，无需在意</p>
<h2 id="JS的控制语句"><a href="#JS的控制语句" class="headerlink" title="JS的控制语句"></a>JS的控制语句</h2><p>和C语言完全一致</p>
<h2 id="JS的函数"><a href="#JS的函数" class="headerlink" title="JS的函数"></a>JS的函数</h2><p>与C几乎相同，唯一的区别事使用function定义而不需要根据函数返回值的类型更改函数头信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">function_name</span>(<span class="params">param1,param2,……</span>)&#123;</span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Python2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/Python2/"
    >Python2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/Python2/" class="article-date">
  <time datetime="2024-12-21T10:04:23.000Z" itemprop="datePublished">2024-12-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一-面向对象"><a href="#一-面向对象" class="headerlink" title="一.面向对象"></a>一.面向对象</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h2><p>​	类(class)是面向对象编程的一个概念，它类似模板或者蓝图，拥有某一类事物共性的特征，比如cat类，那么一定有尾巴，眼睛，四肢等等，至于某一个属性的状态，比如存在或者不存在则是特性的东西。</p>
<p>​	事物可以从两方面来进行描述，属性和行为。相似地，类(class)中也有属性和行为，分别通过定义成员变量和成员方法来描述。</p>
<p>​	既然类是模板或者蓝图，那么想要依据共性的模板创建一个特性的实例就需要创建对象，这个根据类创建对象的过程叫做实例化。</p>
<p>​	面向对象三大特性：封装，继承，多态。</p>
<p>​	面向对象编程就是：设计类，基于类创建对象，让对象干活做具体的工作。</p>
<p>以下是python中面向对象编程的一个具体过程：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设计类，以Dog类为例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    age = <span class="literal">None</span></span><br><span class="line">    <span class="comment">#定义基本行为</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">    <span class="comment">#self是必须的形参，事实上，self只是一个特征，表明这是一个类中的方法，在实际调用方法是并不需要我们真的进行self的传参，IDE会自动传递实参self。</span></span><br><span class="line"><span class="comment">#创建对象</span></span><br><span class="line">xiaohua = Dog()</span><br><span class="line">xiaohua.name = <span class="string">&quot;xiaohua&quot;</span></span><br><span class="line">xiaohua.age = <span class="number">6</span></span><br><span class="line"><span class="comment">#让对象工作</span></span><br><span class="line">xiaohua.bark()</span><br></pre></td></tr></table></figure>

<p>​	这是一种创建类的手段，基于这种类创建对象时需要对属性一个个赋值，无法一次性赋值。</p>
<ul>
<li>__init__构造方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设计类，以Dog类为例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="comment">#__init__是python中的内置方法，用于初始化类的实例</span></span><br><span class="line">    <span class="comment">#定义基本行为</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line"><span class="comment">#创建对象</span></span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">#让对象工作</span></span><br><span class="line">xiaohua.bark()</span><br><span class="line"><span class="built_in">print</span>(xiaohua.age)</span><br></pre></td></tr></table></figure>

<p>​	__init__本身的作用是，在构建类时传入的参数会自动提供给__init__方法，并且__init__方法会自动执行</p>
<h2 id="2-python内置方法"><a href="#2-python内置方法" class="headerlink" title="2.python内置方法"></a>2.python内置方法</h2><p>​	类似上文中的__init__方法，python中有许多内置方法，称为魔术方法。</p>
<p>常见的内置方法：</p>
<h3 id="1-str-字符串方法"><a href="#1-str-字符串方法" class="headerlink" title="1.__str__字符串方法"></a>1.__str__字符串方法</h3><p>​	<code>__str__</code> 方法是 Python 中一个特殊的方法，它用于定义一个对象的“字符串表示”。当你使用 <code>print()</code> 函数或 <code>str()</code> 函数来输出一个对象时，Python 会调用该对象的 <code>__str__</code> 方法。</p>
<p>​	通过实现 <code>__str__</code> 方法，你可以提供一个更友好的、可读性更强的输出格式，方便调试和日志记录。</p>
<p>​	当没有对<code>__str__</code>进行人为定义时，默认会返回类的地址，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua)</span><br><span class="line"><span class="comment">#&lt;__main__.Dog object at 0x000001BD22E85DF0&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>&quot;</span></span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua)</span><br><span class="line"><span class="comment">#&quot;xiaohua&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-lt-方法"><a href="#2-lt-方法" class="headerlink" title="2.__lt__方法"></a>2.<code>__lt__</code>方法</h3><p>​	<code>__it__</code>方法用于比较两个类特定属性进行“&lt;”比较，返回bool值，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line">dahuang = Dog(<span class="string">&quot;dahuang&quot;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua&lt;dahuang)</span><br><span class="line"><span class="comment">#报错，因为在定义类时并没有赋予它可以比较这个属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,another_class</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.age&lt;another_class.age</span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line">sangbiao = Dog(<span class="string">&quot;sangbiao&quot;</span>,<span class="number">7</span>)</span><br><span class="line">dahuang = Dog(<span class="string">&quot;dahuang&quot;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua&lt;dahuang)</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(xiaohua&lt;sangbiao)</span><br><span class="line"><span class="comment">#True</span></span><br></pre></td></tr></table></figure>

<p>注意：这里的<code>__lt__</code>方法仅限于“&lt;”的比较，也就是说print(xiaohua&gt;sangbiao)会报错。</p>
<ul>
<li><p>其他比较魔术方法：</p>
</li>
<li><p><code>__eq__(self, other)</code>: 实现相等运算符 <code>==</code>。</p>
</li>
<li><p><code>__ne__(self, other)</code>: 实现不等运算符 <code>!=</code>。</p>
</li>
<li><p><code>__lt__(self, other)</code>: 实现小于运算符 <code>&lt;</code>。</p>
</li>
<li><p><code>__le__(self, other)</code>: 实现小于等于运算符 <code>&lt;=</code>。</p>
</li>
<li><p><code>__gt__(self, other)</code>: 实现大于运算符 <code>&gt;</code>。</p>
</li>
<li><p><code>__ge__(self, other)</code>: 实现大于等于运算符 <code>&gt;=</code>。</p>
</li>
</ul>
<h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h2><p>​	封装是面向对象编程的一种思想，它指的是将数据（属性）和操作数据的方法（行为）结合在一起，将数据的实现细节隐藏起来，只暴露出必要的接口给外部使用。这样可以提高代码的安全性和可维护性。</p>
<p>​	<img src="/./../imgs/image-20241120203845991.png" alt="image-20241120203845991"></p>
<p>封装的主要优点包括：</p>
<ol>
<li><strong>数据隐藏</strong>：通过将数据私有化，只允许通过公共方法访问，减少了数据被随意修改的风险。</li>
<li><strong>提高代码的可维护性</strong>：如果需要修改内部实现，只需在类内部进行修改，而不影响使用该类的外部代码。</li>
<li><strong>降低复杂性</strong>：外部代码只需要了解接口，而不需要关心内部实现，简化了使用过程。</li>
</ol>
<ul>
<li>私有成员</li>
</ul>
<p>​	现实生活中的一些事物的部分属性和行为并不对所有人开放，类也是如此。类中提供了私有成员的形式来支持该特性。</p>
<p>​	定义私有成员只需要在私有成员名字前加“__”即可。</p>
<p>​	虽然私有成员无法被通过类访问，但是可以在类中被其他成员访问</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>:</span><br><span class="line">    __current_voltage = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__keep_single_core</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g通话已开启&quot;</span>)</span><br><span class="line">xiaomi = Phone()</span><br><span class="line"><span class="built_in">print</span>(xiaomi.__current_voltage)</span><br><span class="line"><span class="built_in">print</span>(xiaomi.__keep_single_core)</span><br><span class="line"><span class="comment">#报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>:</span><br><span class="line">    __current_voltage = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__keep_single_core</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;CPU以单核模式运行&quot;</span>)</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">def</span> <span class="title function_">call_by_5g</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">if</span> <span class="variable language_">self</span>.__current_voltage&gt;=<span class="number">1</span>:</span><br><span class="line">        	<span class="built_in">print</span>(<span class="string">&quot;5g通话已开启&quot;</span>)</span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">        	<span class="variable language_">self</span>.__keep_single_core()</span><br><span class="line">        	<span class="built_in">print</span>(<span class="string">&quot;电量不足，无法开启5g通信，已设置单核模式省电&quot;</span>)</span><br><span class="line">xiaomi = Phone()</span><br><span class="line">call_by_5g()</span><br><span class="line"><span class="comment">#5g通话已开启</span></span><br></pre></td></tr></table></figure>



<h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h2><p>​	定义一个新的类，新的类的属性与方法继承自一个老的类，并且新的类有独属于自己的属性与方法。</p>
<p>语法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sub_class</span>(<span class="title class_ inherited__">super_class</span>):</span><br><span class="line">    class_stuct</span><br></pre></td></tr></table></figure>

<ul>
<li>单继承：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line">    IMET = <span class="literal">None</span></span><br><span class="line">    producer = <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_4g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4g&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone_new</span>(<span class="title class_ inherited__">phone</span>):</span><br><span class="line">    face_id = <span class="string">&quot;10001&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_5g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>多继承：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NFC</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#pass,占位符，无实际意义，用于定义空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xiaomi</span>(phone_new,NFC):</span><br><span class="line">    class_struct</span><br></pre></td></tr></table></figure>

<p>​	多个父类中,如果有同名的成员,那么默认以继承顺序(从左到右)为优先级。</p>
<p>即:先继承的保留,后继承的被覆盖</p>
<ul>
<li>复写父类成员</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line">    IMET = <span class="literal">None</span></span><br><span class="line">    producer = <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_4g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4g&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone_new</span>(<span class="title class_ inherited__">phone</span>):</span><br><span class="line">    face_id = <span class="string">&quot;10001&quot;</span></span><br><span class="line">    producer = <span class="string">&quot;microsoft&quot;</span> <span class="comment">#复写父类成员变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_4g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)	<span class="comment">#复写父类成员方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用父类同名成员</li>
</ul>
<p>​	如果在子类中对父类进行复写，那么在子类中调尝试用父类同名成员时会调用复写后的成员，如果想真正能访问到父类中同名成员，需要用特殊的调用方式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mode1:</span></span><br><span class="line">superclass_name.menber_variable</span><br><span class="line">superclass_name.menber_method(<span class="variable language_">self</span>)</span><br><span class="line"><span class="comment">#mode2:</span></span><br><span class="line"><span class="built_in">super</span>().menber_variable</span><br><span class="line"><span class="built_in">super</span>().menber_method()</span><br></pre></td></tr></table></figure>

<h2 id="5-类型注解"><a href="#5-类型注解" class="headerlink" title="5.类型注解"></a>5.类型注解</h2><p><img src="/./../imgs/image-20241120214610619.png" alt="image-20241120214610619"></p>
<p><strong>为容器作注解</strong></p>
<p><img src="/./../imgs/image-20241120214643703.png" alt="image-20241120214643703"></p>
<p><strong>在注释中作注解</strong></p>
<p><img src="/./../imgs/image-20241120214734372.png" alt="image-20241120214734372"></p>
<p><strong>对函数参数进行注解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">param1:<span class="built_in">type</span>,param2:<span class="built_in">type</span>,……</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>对函数返回值进行注解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">param1:<span class="built_in">type</span>,param2:<span class="built_in">type</span>,……</span>) -&gt; ret_type:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>Union注解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用 Union 来表示值可以是多种类型之一。</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_value</span>(<span class="params">value: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(value)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，注解并<strong>不会</strong>因为注解而改变变量，参数，或者返回值的类型，也就是说，<em><strong>注解仅仅是用于给编写者或者第三方IDE作提示信息</strong></em>。</p>
<h2 id="6-多态"><a href="#6-多态" class="headerlink" title="6.多态"></a>6.多态</h2><p>​	多态，指的是同一个行为，传入不同的对象，得到不同状态</p>
<p><img src="/./../imgs/image-20241120220404547.png" alt="image-20241120220404547"></p>
<p> <strong>抽象类(接口)</strong></p>
<p><img src="/./../imgs/image-20241120221426109.png" alt="image-20241120221426109"></p>
<hr>
<h1 id="二-SQL入门与实战"><a href="#二-SQL入门与实战" class="headerlink" title="二.SQL入门与实战"></a>二.SQL入门与实战</h1><h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><p>​	数据可以分为储存和计算两部分，编程语言可以归纳为数据计算一类，数据库就是用于数据存储一类。</p>
<ul>
<li>数据库如何组织数据</li>
</ul>
<p>​	<img src="/./../imgs/image-20241121124539489.png" alt="image-20241121124539489"></p>
<ul>
<li>数据库管理系统(数据库软件)</li>
</ul>
<p>​	MySQL,SQLSever等</p>
<ul>
<li>数据库和SQL语言的关系</li>
</ul>
<p>​	数据库用于储存数据，那么在这个过程中无法避免地涉及到数据地增删查改和数据库，数据表的管理。SQL语言就是对数据库进行操作，管理，查询的工具。</p>
<p>​	数据库软件可以获得库-&gt;表-&gt;数据，这种数据组织，储存的能力，并借助SQL语言完成对数据的操作，管理，查询。</p>
<h2 id="2-SQL基础与DDL"><a href="#2-SQL基础与DDL" class="headerlink" title="2.SQL基础与DDL"></a>2.SQL基础与DDL</h2><p>​	SQL全称Structured Query Language,结构化查询语言，用于访问和处理数据库的<strong>标准</strong>的计算机语言。</p>
<ul>
<li><p>SQL的基础语法特征：</p>
<ul>
<li><p>大小写不敏感</p>
</li>
<li><p>单行或多行书写，以;结束</p>
</li>
<li><p>支持注释：</p>
<ol>
<li><p>单行注释：– 注释内容</p>
</li>
<li><p>单行注释：# 注释内容</p>
</li>
<li><p>多行注释：<code>/*注释内容*/</code></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>​	DDL是“数据定义语言”（Data Definition Language）的缩写。它用于定义和管理数据库中的<strong>结构和对象</strong>。</p>
<ul>
<li><p>DDL-库管理</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;	<span class="comment">-- 查看数据库</span></span><br><span class="line">use database_name;	<span class="comment">-- 使用数据库</span></span><br><span class="line"><span class="keyword">create</span> database database_name [charset utf8];	<span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">drop</span> database database_name;	<span class="comment">-- 删除库</span></span><br><span class="line"><span class="keyword">select</span> database();	<span class="comment">-- 查看当前数据库</span></span><br></pre></td></tr></table></figure>




<ul>
<li><p>DLL-表管理</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;	<span class="comment">-- 查看表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> table_name;	<span class="comment">-- 删除表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> table_name(</span><br><span class="line">	column_name1 column_type1,</span><br><span class="line">    column_name2 column_type2,</span><br><span class="line">	column_name3 column_type3,</span><br><span class="line">    ……</span><br><span class="line">  );			<span class="comment">-- 创建表</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-SQL-DML"><a href="#3-SQL-DML" class="headerlink" title="3.SQL-DML"></a>3.SQL-DML</h2><p>​	DML是“数据操纵语言”（Data Manipulation Language）的缩写，它是数据库管理系统（DBMS）中用于<strong>管理数据</strong>的子语言。</p>
<ul>
<li>数据插入insert</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> <span class="keyword">table</span>[(column1,column2,……,<span class="keyword">column</span> n)] <span class="keyword">values</span>(data1,data2,……,data n)[,(data1,data2,……,data n),……,(data1,data2,……,data n)]</span><br><span class="line">#示例：</span><br><span class="line"><span class="keyword">create table</span> student(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line">#仅插入一列</span><br><span class="line"><span class="keyword">insert into</span> student(id) <span class="keyword">values</span>(<span class="number">10001</span>),(<span class="number">10002</span>),(<span class="number">10003</span>);</span><br><span class="line">#插入全部列表</span><br><span class="line"><span class="keyword">insert into</span> student(id,name,age) <span class="keyword">values</span>(<span class="number">10001</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>),(<span class="number">10002</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">#快速插入全部列表</span><br><span class="line"><span class="keyword">insert into</span> student <span class="keyword">values</span>(<span class="number">10001</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>),(<span class="number">10002</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>数据删除delete</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name [while <span class="keyword">condition</span>];</span><br><span class="line">#注意删除数据是删除所匹配数据所在的一整个结构或对象</span><br></pre></td></tr></table></figure>

<ul>
<li>数据更新update</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> <span class="keyword">column</span> <span class="operator">=</span> value1 [<span class="keyword">where</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>



<h2 id="3-SQL-DQL"><a href="#3-SQL-DQL" class="headerlink" title="3.SQL-DQL"></a>3.SQL-DQL</h2><p>​	DQL（Data Query Language）是用于查询数据库中数据的语言，主要用于从数据库中<strong>检索数据</strong>。</p>
<ul>
<li>查询数据select</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column1,column2,……,<span class="keyword">column</span> n <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>];</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name </span><br></pre></td></tr></table></figure>

<ul>
<li>分组聚合</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column1,column2,……,<span class="keyword">column</span> n<span class="operator">|</span>聚合函数 <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>] <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">column</span> x;</span><br><span class="line">#聚合函数：</span><br><span class="line"><span class="operator">-</span> <span class="built_in">sum</span>(<span class="keyword">column</span>)	求和</span><br><span class="line"><span class="operator">-</span> <span class="built_in">avg</span>(<span class="keyword">column</span>)	求平均值</span><br><span class="line"><span class="operator">-</span> <span class="built_in">min</span>(<span class="keyword">column</span>)	求最小值</span><br><span class="line"><span class="operator">-</span> <span class="built_in">max</span>(<span class="keyword">column</span>)	求最大值</span><br><span class="line"><span class="operator">-</span> <span class="built_in">count</span>(<span class="keyword">column</span><span class="operator">|</span><span class="operator">*</span>)	求数量</span><br></pre></td></tr></table></figure>

<ul>
<li>排序分页</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">column</span><span class="operator">|</span>聚合函数<span class="operator">|</span><span class="operator">*</span> <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>] <span class="keyword">group</span> <span class="keyword">by</span> …… <span class="keyword">order</span> <span class="keyword">by</span> [<span class="keyword">asc</span>(升序)<span class="operator">|</span><span class="keyword">desc</span>(降序)];	#排序</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">column</span><span class="operator">|</span>聚合函数<span class="operator">|</span><span class="operator">*</span> <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>] <span class="keyword">group</span> <span class="keyword">by</span> …… <span class="keyword">order</span> <span class="keyword">by</span> [<span class="keyword">asc</span>(升序)<span class="operator">|</span><span class="keyword">desc</span>(降序)] limit n[,m]; #分页</span><br></pre></td></tr></table></figure>



<h2 id="4-python操作MySQL"><a href="#4-python操作MySQL" class="headerlink" title="4.python操作MySQL"></a>4.python操作MySQL</h2><h3 id="1-python执行SQL语句"><a href="#1-python执行SQL语句" class="headerlink" title="1.python执行SQL语句"></a>1.python执行SQL语句</h3><p>​	除了使用图形化工具来执行SQL语句外，还可以使用编程语言来执行SQL从而进行数据操作。  </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql1</span><br><span class="line"><span class="keyword">from</span> pymysql1.cursors <span class="keyword">import</span> Cursor</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建MySQL数据库的链接</span></span><br><span class="line">conn = pymysql1.Connection(</span><br><span class="line">    password=<span class="string">&#x27;xxxxxxxxxxxx&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># print(conn.get_server_info())</span></span><br><span class="line"><span class="comment">#执行非查询性SQL语句</span></span><br><span class="line">cursor = conn.cursor()      <span class="comment">#获取到游标对象</span></span><br><span class="line">conn.select_db(<span class="string">&quot;try&quot;</span>)       <span class="comment">#选择数据库</span></span><br><span class="line">cursor.execute(<span class="string">&quot;create table test_pymysql(id int);&quot;</span>)    <span class="comment">#将SQL语句以字符串的形式作为参数传到execute方法即可</span></span><br><span class="line"><span class="comment">#执行查询性质的SQL语句</span></span><br><span class="line">cursor = conn.cursor()      <span class="comment">#获取到游标对象</span></span><br><span class="line">conn.select_db(<span class="string">&quot;try&quot;</span>)       <span class="comment">#选择数据库</span></span><br><span class="line">cursor.execute(<span class="string">&quot;select * from student;&quot;</span>)</span><br><span class="line"><span class="comment">#查询结果</span></span><br><span class="line">result: <span class="built_in">tuple</span> = cursor.fetchall()      <span class="comment">#获得查询结果并封装进元组</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="2-python数据插入MySQL"><a href="#2-python数据插入MySQL" class="headerlink" title="2.python数据插入MySQL"></a>2.python数据插入MySQL</h3><p>​	当我们在使用pymysql库执行数据插入或者其他可能产生数据更改的语句时，需要<strong>“提交”</strong>，通过链接对象.commit()即可确认此行为</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Python1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/Python1/"
    >Python1</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/Python1/" class="article-date">
  <time datetime="2024-12-21T09:54:31.000Z" itemprop="datePublished">2024-12-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一-Python基础语法"><a href="#一-Python基础语法" class="headerlink" title="一.Python基础语法"></a>一.Python基础语法</h1><h2 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h2><p>​	被写下来的固定不变的值（常量）。</p>
<p><img src="/./../imgs/image-20241103214206504.png" alt="image-20241103214206504"></p>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.**变量"></a>2.**变量</h2><p>​	在程序运行时，能储存计算结果或能表示值的抽象概念。</p>
<p>​	事实上，说“储存”是有所偏颇的，准确的来说，Python的变量实际上是对象的引用。（可以理解为C中的指针概念）</p>
<p>​	定义格式：</p>
<p>​	变量名称&#x3D;变量的值</p>
<p><img src="/./../imgs/image-20241104141420085.png" alt="image-20241104141420085"></p>
<p>（见test01.py）</p>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><ul>
<li>type语句：查看数据类型。</li>
<li>即使是查看的变量类型，也是数据类型，因为Python不同于C，它没有严格的类型检查，因此，它的变量是没有类型的，查看的变量的类型实际上是其中存储的数据的类型。</li>
</ul>
<h2 id="4-数据类型转换"><a href="#4-数据类型转换" class="headerlink" title="4.数据类型转换"></a>4.数据类型转换</h2><ul>
<li>为什么要转换类型？</li>
</ul>
<p><img src="/./../imgs/image-20241104143045034.png" alt="image-20241104143045034"></p>
<ul>
<li>常见的转换语句。</li>
</ul>
<p><img src="/./../imgs/image-20241104143224284.png" alt="image-20241104143224284"></p>
<p>​	值得注意的是，这里的三个函数同type()一样都是带返回值的，可以直接在print</p>
<p>函数中输出，或者将其存储于变量中。</p>
<ul>
<li>浮点和整型都可以转字符串</li>
<li>字符串不一定能转浮点和整型</li>
<li>浮点转整型会丢失小数部分</li>
</ul>
<h2 id="5-标识符"><a href="#5-标识符" class="headerlink" title="5.标识符"></a>5.标识符</h2><p>​	标识符就是名字，给变量，方法，类等取的名字，用于做内容的标识。</p>
<ul>
<li>标识符的命名规则：</li>
</ul>
<p>​	1.只允许出现英文，中文，数字，下划线。其中，中文不推荐使用，数字<strong>不能</strong>放开头。</p>
<p>​	2.Python大小写是敏感的。</p>
<p>​	3.不可使用关键字。</p>
<ul>
<li>标识符的命名规范：</li>
</ul>
<p>​	1.简洁明了</p>
<p>​	2.下划线命名法:</p>
<p>​		用下划线分隔单词，以免歧义</p>
<p>​	3.英文字母全部小写</p>
<h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h2><ul>
<li>算术运算符</li>
</ul>
<p><img src="/./../imgs/image-20241104145300579.png" alt="image-20241104145300579"></p>
<p>（这里需要注意的是，Python中的除法<strong>一定</strong>得到浮点型结果，且正常除法与整除是分别由一个运算符来运算的，不像C中是同一个运算符，结果由除数和被除数的类型决定。）</p>
<ul>
<li>赋值运算符：</li>
</ul>
<p>​	右赋左。</p>
<ul>
<li>复合赋值运算符：</li>
</ul>
<p>​	与C中一样由算数运算符+赋值运算符构成，功能也一样。</p>
<h2 id="7-字符串扩展内容"><a href="#7-字符串扩展内容" class="headerlink" title="7.字符串扩展内容"></a>7.字符串扩展内容</h2><h3 id="1-字符串的三种定义方式："><a href="#1-字符串的三种定义方式：" class="headerlink" title="1.字符串的三种定义方式："></a>1.字符串的三种定义方式：</h3><p><img src="/./../imgs/image-20241104150951471.png" alt="image-20241104150951471"></p>
<ul>
<li>字符串的引号嵌套</li>
</ul>
<p><img src="/./../imgs/image-20241104151310495.png" alt="image-20241104151310495"></p>
<h3 id="2-字符串的拼接"><a href="#2-字符串的拼接" class="headerlink" title="2.字符串的拼接"></a>2.字符串的拼接</h3><p> <img src="/./../imgs/image-20241104151724889.png" alt="image-20241104151724889"></p>
<p>（值得注意的是，通过”+“号对字符串的拼接仅限于<strong>字符串</strong>类型，浮点和整型会报错。）</p>
<h3 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3.字符串格式化"></a>3.字符串格式化</h3><ul>
<li>占位符%，和C基本一样。</li>
</ul>
<p><img src="/./../imgs/image-20241104152533368.png" alt="image-20241104152533368"></p>
<p>（当然，也可以使用%d，%f对整型和浮点型进行原封不动的输出，这里只用%s是因为进行了隐式转换。）</p>
<ul>
<li>快速格式化字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;name&#125;</span>，年龄<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125; and I am &#123;&#125; years old&quot;</span>.<span class="built_in">format</span>(name, age))</span><br></pre></td></tr></table></figure>

<p>（不关心类型和精度控制。）</p>
<p>事实上格式化并不是变量的专属，常量和表达式仍然可以直接格式化输出。</p>
<h3 id="4-格式化的精度控制"><a href="#4-格式化的精度控制" class="headerlink" title="4.格式化的精度控制"></a>4.格式化的精度控制</h3><p><img src="/./../imgs/image-20241104155646837.png" alt="image-20241104155646837"></p>
<p>(注意：这里的四舍五入就是最常见的四舍五入，而不是C中的四舍六入五成双。)</p>
<p><img src="/./../imgs/image-20241104161216428.png" alt="image-20241104161216428"></p>
<p>（见test02.py）</p>
<hr>
<h2 id="8-数据输入"><a href="#8-数据输入" class="headerlink" title="8.数据输入"></a>8.数据输入</h2><ul>
<li><p>input语句：从stdin获取输入数据。</p>
</li>
<li><p>input函数有返回值，也就是说可以赋值进变量。</p>
</li>
<li><p>input默认接收的数据都是字符串，输出其他类型需要强制转换。</p>
</li>
</ul>
<p><img src="/./../imgs/image-20241104164623296.png" alt="image-20241104164623296"></p>
<p>（见test03.py）</p>
<h1 id="二-Python判断语句"><a href="#二-Python判断语句" class="headerlink" title="二.Python判断语句"></a>二.Python判断语句</h1><h2 id="1-bool类型与比较运算符"><a href="#1-bool类型与比较运算符" class="headerlink" title="1.bool类型与比较运算符"></a>1.bool类型与比较运算符</h2><ul>
<li>bool类型：与C中相同，略</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = <span class="literal">True</span>/<span class="literal">False</span></span><br></pre></td></tr></table></figure>



<ul>
<li>比较运算符：同C</li>
</ul>
<h2 id="2-if语句的基本格式"><a href="#2-if语句的基本格式" class="headerlink" title="2.if语句的基本格式"></a>2.if语句的基本格式</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;this place isn&#x27;t for you&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get out!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>(与C不同，Python中判断一条语句是否从属于判断语句并不是用{}括起来进行分区，而是看是否有一个制表符的缩进。)</p>
<p><img src="/./../imgs/image-20241104194734905.png" alt="image-20241104194734905"></p>
<p>（见test04.py）</p>
<h2 id="3-if……else语句"><a href="#3-if……else语句" class="headerlink" title="3.if……else语句"></a>3.if……else语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    do1</span><br><span class="line">    do2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    do3</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241104200017292.png" alt="image-20241104200017292"></p>
<p>(见test05.py)</p>
<h2 id="4-if……elif……else语句"><a href="#4-if……elif……else语句" class="headerlink" title="4.if……elif……else语句"></a>4.if……elif……else语句</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1：</span><br><span class="line">	do1</span><br><span class="line"><span class="keyword">elif</span> condition2：</span><br><span class="line">	do2</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">	do3</span><br></pre></td></tr></table></figure>

<p>![屏幕截图 2024-11-04 201953](C:\Users\zhouyue\Pictures\Screenshots\屏幕截图 2024-11-04 201953.png)</p>
<p>（见test06.py）</p>
<h2 id="5-判断语句的嵌套"><a href="#5-判断语句的嵌套" class="headerlink" title="5.判断语句的嵌套"></a>5.判断语句的嵌套</h2><p>思想和C相同的，略</p>
<h2 id="6-实操案例"><a href="#6-实操案例" class="headerlink" title="6.实操案例"></a>6.实操案例</h2><p><img src="/./../imgs/image-20241104203624249.png" alt="image-20241104203624249"></p>
<p>（见test07.py）</p>
<h1 id="三-Python循环语句"><a href="#三-Python循环语句" class="headerlink" title="三.Python循环语句"></a>三.Python循环语句</h1><h2 id="1-while基础语法"><a href="#1-while基础语法" class="headerlink" title="1.while基础语法"></a>1.while基础语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    do1</span><br><span class="line">    do2</span><br><span class="line">    do3</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>

<p>（与C几乎一样，唯一需要注意的就是字符缩进）</p>
<p>![屏幕截图 2024-11-04 205556](C:\Users\zhouyue\Pictures\Screenshots\屏幕截图 2024-11-04 205556.png)</p>
<p>（见test08.py）</p>
<h2 id="2-while基础案例"><a href="#2-while基础案例" class="headerlink" title="2.while基础案例"></a>2.while基础案例</h2><p><img src="/./../imgs/image-20241104210331358.png" alt="image-20241104210331358"></p>
<p>（见test09.py）</p>
<h2 id="3-while嵌套循环"><a href="#3-while嵌套循环" class="headerlink" title="3.while嵌套循环"></a>3.while嵌套循环</h2><p>同C，唯一要注意的是，多个循环嵌套及条件分支时，没有了{}的明显区分，需要格外注意缩进来正确分块。</p>
<h2 id="4-while嵌套循环实操"><a href="#4-while嵌套循环实操" class="headerlink" title="4.while嵌套循环实操"></a>4.while嵌套循环实操</h2><p>补充：print输出不换行的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dfshjfs0&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sdjgsgsd&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241104212220936.png" alt="image-20241104212220936">（见test10.py)</p>
<h2 id="5-for循环基础语法"><a href="#5-for循环基础语法" class="headerlink" title="5.for循环基础语法"></a>5.for循环基础语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 数据集:</span><br><span class="line">    do</span><br></pre></td></tr></table></figure>

<p>(<strong>需要格外注意地是，Python中的for循环与C中的for循环的不同，C中的for循环可以等价写成while循环，但Python中无法定义循环条件</strong>)</p>
<p>理论上将Python中的for循环无法构建无限循环，因为不可能存在一个数据集中的元素个数无限。</p>
<p>临时变量x不一定要打印，也可以仅仅将其当作计数器使用。</p>
<p><img src="/./../imgs/image-20241105125840899.png" alt="image-20241105125840899"></p>
<p>（见test11.py）</p>
<h2 id="6-range语句"><a href="#6-range语句" class="headerlink" title="6.range语句"></a>6.range语句</h2><p>​	for循环语法中的带处理数据集事实上应该叫做“序列”，是一种特殊的类型。</p>
<p>​	序列类型是指，其中的内容可以一个个依次取出的一种类型，包括：</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>……</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(num)	</span><br><span class="line">	<span class="comment">#获取一个从0开始到num(不含num)的数字序列</span></span><br><span class="line"><span class="built_in">range</span>(num1, num2)</span><br><span class="line">	<span class="comment">#获取一个从num1开始到num2(不含num2)的数字序列</span></span><br><span class="line"><span class="built_in">range</span>(num1, num2, step)</span><br><span class="line">	<span class="comment">#获取一个从num1开始到num2(不含num2)的数字序列</span></span><br><span class="line">    <span class="comment">#数字间的步长以step为准(step默认为1)</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241105131141873.png" alt="image-20241105131141873"></p>
<p>（见test12.py）</p>
<h2 id="7-变量作用域"><a href="#7-变量作用域" class="headerlink" title="7.*变量作用域"></a>7.*变量作用域</h2><ul>
<li><p>同C</p>
</li>
<li><p>虽然在Python中可以尝试访问一个异域的变量，但是保不齐会出问题，尤其是在写大项目时。</p>
</li>
<li><p>如果真的想访问，可以先在大的域中定义一个变量名相同的变量，在for循环中对临时变量进行覆盖</p>
</li>
</ul>
<h2 id="8-for循环的嵌套循环"><a href="#8-for循环的嵌套循环" class="headerlink" title="8.for循环的嵌套循环"></a>8.for循环的嵌套循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range1:</span><br><span class="line">    do</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range2:</span><br><span class="line">        do</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">for</span> ……：</span><br><span class="line">	do</span><br><span class="line">    <span class="keyword">while</span> ……：</span><br><span class="line">    	do</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241105132606549.png" alt="image-20241105132606549"></p>
<p>(见test13.py)</p>
<h2 id="9-循环中断"><a href="#9-循环中断" class="headerlink" title="9.循环中断"></a>9.循环中断</h2><ul>
<li>continue：中断本次循环，<strong>直接</strong>进入下一次循环。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>:</span><br><span class="line">    do1</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    do2</span><br><span class="line">	<span class="comment">#上述代码不会执行do2</span></span><br></pre></td></tr></table></figure>

<p>（continue能且<strong>仅</strong>能中断离他<strong>最近</strong>的循环）</p>
<ul>
<li>break：直接结束循环</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>:</span><br><span class="line">    do1</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    do2</span><br><span class="line">do3</span><br><span class="line">	<span class="comment">#上述代码直接结束循环，do1后直接do3，不再进入循环</span></span><br></pre></td></tr></table></figure>

<p>（同样地，break也仅能跳过离他最近的循环）</p>
<h2 id="10-综合案例"><a href="#10-综合案例" class="headerlink" title="10.综合案例"></a>10.综合案例</h2><p><img src="/./../imgs/image-20241105134205905.png" alt="image-20241105134205905"></p>
<p>（见test14.py）</p>
<h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四.函数"></a>四.函数</h1><p>​	函数，是<strong>组织好</strong>的，<strong>可重复使用</strong>的，用来实现特定功能的代码段。同样的，Python除了自身有庞大的函数库外，也支持自己定义函数。</p>
<h2 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1.函数的定义"></a>1.函数的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">parameter1, parameter2, ……</span>):</span><br><span class="line">    function_struct</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>调用：function_name(parameter1, parameter2, ……)即可。</p>
<h2 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2.*函数的参数"></a>2.*函数的参数</h2><p>​	与C基本相同，唯一要注意的是在一些情况下，对函数的形参进行修改是会导致实参的改变的。</p>
<p><img src="/./../imgs/image-20241105152009847.png" alt="image-20241105152009847"></p>
<p>（见test15.py）</p>
<h2 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3.函数的返回值"></a>3.函数的返回值</h2><p>​	 与C基本相同，唯一要注意的是，无论有没有人为定义一个返回值，最终函数都会产生返回值，当没有人为定义的返回值时，此时返回值是“None”</p>
<p>​	<strong>None</strong>在Python中是一种类型’NoneType’，代表“无，空的，无意义”。</p>
<p>None的实际应用：</p>
<ul>
<li>无函数返回值</li>
<li>if条件判断：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">if</span> age &gt; <span class="number">18</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sucess&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">result = check_age(age)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Forbid child to enter there!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>声明无内容的变量：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line"><span class="comment">#仅声明，不赋值</span></span><br></pre></td></tr></table></figure>

<h2 id="4-函数的嵌套"><a href="#4-函数的嵌套" class="headerlink" title="4.函数的嵌套"></a>4.函数的嵌套</h2><p>​	在一个函数的里面再调用函数。</p>
<h2 id="5-变量的作用域"><a href="#5-变量的作用域" class="headerlink" title="5.*变量的作用域"></a>5.*变量的作用域</h2><ul>
<li><p>变量分为两类：局部变量，全局变量。</p>
</li>
<li><p>局部变量是指在函数内部定义的变量，它的作用域和生存周期和函数相同，也就意味着无法在函数外对其进行访问。</p>
</li>
<li><p>全局变量，至少对于Python来说，是指定义在函数外的变量。作用域和生存周期和程序相同。</p>
</li>
<li><p>如何在使在函数内定义的局部变量的值能“映射”到函数外的相同变量名的变量？</p>
</li>
</ul>
<p>​	1.golobal关键字</p>
<p>​		可以理解为强制将变量类型转化为全局变量。</p>
<p>​	2.引用特殊类型对象的<a href="##2.**%E5%8F%98%E9%87%8F">变量</a></p>
<p>​		修改一个<strong>可变对象</strong>（如列表、字典等）作为函数的形参时，会改变	实参的值。</p>
<h2 id="6-综合案例"><a href="#6-综合案例" class="headerlink" title="6.综合案例"></a>6.综合案例</h2><p><img src="/./../imgs/image-20241105193025908.png" alt="image-20241105193025908"></p>
<p>（见test16.py）</p>
<h1 id="五-Python数据容器"><a href="#五-Python数据容器" class="headerlink" title="五.Python数据容器"></a>五.Python数据容器</h1><h1 id="1-数据容器入门"><a href="#1-数据容器入门" class="headerlink" title="1.数据容器入门"></a>1.数据容器入门</h1><p>​	一种可以容纳多份数据的<strong>数据类型</strong>，容纳的每一份数据称为一个元素，<strong>每一个</strong>元素可以是<strong>任意类型</strong>的数据，如字符串，bool……（类似于C中的结构体）。</p>
<p>数据容器根据某些特征可以分为5类：</p>
<ul>
<li>是否支持重复元素</li>
<li>是否可以修改</li>
<li>是否有序</li>
</ul>
<p>列表（list），元组（tuple），字符串（str），集合（set），字典（dict）</p>
<h2 id="2-数据容器：list（列表）"><a href="#2-数据容器：list（列表）" class="headerlink" title="2.数据容器：list（列表）"></a>2.数据容器：list（列表）</h2><h3 id="1-list（列表）的定义"><a href="#1-list（列表）的定义" class="headerlink" title="1.list（列表）的定义"></a>1.list（列表）的定义</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字面量列表</span></span><br><span class="line">[element1,element2,……]</span><br><span class="line"><span class="comment">#变量列表</span></span><br><span class="line">variable_name = [element1,element2,……]</span><br><span class="line"><span class="comment">#空列表：</span></span><br><span class="line">variable_name = []</span><br><span class="line">variable_name = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure>

<p>注意：列表可以一次性存储多个数据，且可以为<strong>不同</strong>的数据类型</p>
<h3 id="2-list（列表）的索引"><a href="#2-list（列表）的索引" class="headerlink" title="2.list（列表）的索引"></a>2.list（列表）的索引</h3><p>​	类似于数组，不同的是，这里的元素下标可以从后往前定义，eg：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [element1,element2,elemrnt3]</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>] = element1</span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>] = elemrnt2</span><br><span class="line"><span class="built_in">list</span>[<span class="number">3</span>] = element3</span><br><span class="line">also</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] = element3</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">2</span>] = element2</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">3</span>] = element1</span><br></pre></td></tr></table></figure>

<p>对于list的嵌套，可以像二维数组一样进行下标索引。</p>
<h3 id="3-list（列表）的方法与特点"><a href="#3-list（列表）的方法与特点" class="headerlink" title="3.*list（列表）的方法与特点"></a>3.*list（列表）的方法与特点</h3><h4 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h4><p>​	本质上就是函数，只不过当函数被定义为在<a href="">class</a>（类）的成员，那么此时的函数就称之为方法。</p>
<pre><code> 函数和方法的参数，返回值，定义方式都一样，唯一值得注意的是，当我们调用一个class中的方法时与调用函数不太一样，eg：
</code></pre>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class_name</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">param</span>):</span><br><span class="line">        do</span><br><span class="line"><span class="comment">#调用方法</span></span><br><span class="line">variable = Class_name.method(param)</span><br></pre></td></tr></table></figure>

<pre><code> 那么对于列表（list）来说，它是由Python内置的list类实现的。也就是说，列表是一个list类的实例。
</code></pre>
<h4 id="2-list列表的常用操作"><a href="#2-list列表的常用操作" class="headerlink" title="2.list列表的常用操作"></a>2.list列表的常用操作</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义列表</span></span><br><span class="line">mylist = [elem1, elem2, elem3]</span><br></pre></td></tr></table></figure>

<ul>
<li>查找某元素在列表的下标索引</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.index(elem)</span></span><br><span class="line">number = mylist.index(elem1)</span><br><span class="line"><span class="built_in">print</span>(number)	<span class="comment">#结果输出elem1的下标</span></span><br><span class="line"><span class="built_in">print</span>(mylist.index(elem))</span><br><span class="line"><span class="comment">#结果为：ValueError</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改特定下标索引值</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#本质就是赋值操作</span></span><br><span class="line">mylist[<span class="number">0</span>] = element</span><br></pre></td></tr></table></figure>

<ul>
<li>插入元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.insert(index, elem)</span></span><br><span class="line">mylist.insert(<span class="number">1</span>, elem)</span><br><span class="line"><span class="comment">#结果：[elem1, elem, elem2, elem3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>追加元素</li>
</ul>
<ol>
<li>单个追加</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.append(elem)</span></span><br><span class="line">mylist.append(elem)</span><br><span class="line"><span class="comment">#结果：[elem1, elem2, elem3, elem]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>批量追加</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.extend(another data container)</span></span><br><span class="line">mylist.extend([elem4, elem5, elem6])</span><br><span class="line"><span class="comment">#结果：mylist = [elem1,elem2,elem3,elem4,elem5,elem6]</span></span><br></pre></td></tr></table></figure>

<p>​	注意：list.extend()接受任何可迭代对象（iterable），也就是说，这里的其他数据容器不仅仅指list。</p>
<ul>
<li>删除指定下标索引的元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法1：del list[index]</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">2</span>]</span><br><span class="line"><span class="comment">#结果为：mylist = [elem1,elem2]</span></span><br><span class="line">或者</span><br><span class="line"><span class="comment">#语法2：list.pop(index)</span></span><br><span class="line">name = mylist.pop(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#结果为：mylist = [elem1,elem2]</span></span><br></pre></td></tr></table></figure>

<p>​	注意：list.pop(index)方法有返回值，本质上它是将下标为index的值“取出”作为返回值，同时，list里下标为 index的值被删除。</p>
<ul>
<li>删除指定元素在list中从前向后数的第一个匹配项</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.remove(elem)</span></span><br><span class="line"><span class="built_in">list</span>.remove(elem1)</span><br><span class="line"><span class="comment">#结果为：mylist = [elem2,elem3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>清空列表内容</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.clear()</span></span><br><span class="line">mylist.clear()</span><br><span class="line"><span class="comment">#结果：mylist = []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计某元素在列表中的数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.count(elem)</span></span><br><span class="line"><span class="built_in">print</span>(mylist.conut(elem1))</span><br><span class="line"><span class="comment">#结果为：1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计列表中全部元素的数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：len(list)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mylist))</span><br><span class="line"><span class="comment">#结果为3</span></span><br></pre></td></tr></table></figure>

<p>​	注意：这里的len不是方法，是函数。</p>
<p>![ ](C:\Users\zhouyue\Pictures\Screenshots\屏幕截图 2024-11-06 134119.png)（见test17.py)</p>
<h2 id="3-列表的遍历"><a href="#3-列表的遍历" class="headerlink" title="3.列表的遍历"></a>3.列表的遍历</h2><p>​	对一个数据结构中的每一个元素进行访问和操作称之为遍历或迭代</p>
<p>​	尽管同样是对数据结构每一个元素的访问，但是遍历强调的是访问数据结构中每一个元素的<strong>过程</strong>，而迭代则更强调实现这个过程的<strong>代码段的重复</strong>过程，因此我们可以说遍历<strong>通常</strong>可以通过迭代实现。</p>
<p><img src="/./../imgs/image-20241106150243092.png" alt="image-20241106150243092"></p>
<p>（见test18.py）</p>
<h2 id="4-数据容器：元组（tuple）"><a href="#4-数据容器：元组（tuple）" class="headerlink" title="4.数据容器：元组（tuple）"></a>4.数据容器：元组（tuple）</h2><h3 id="1-元组（tuple）的定义"><a href="#1-元组（tuple）的定义" class="headerlink" title="1.元组（tuple）的定义"></a>1.元组（tuple）的定义</h3><p>​	元组同列表一样可以封装多个，不同类型的元素在内。但是它们最大的不同点在于元组一旦定义完成就<strong>无法修改</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义元组字面量</span></span><br><span class="line">(elem1,elem2,elem3)</span><br><span class="line"><span class="comment">#定义元组变量</span></span><br><span class="line">variable_name = (elem1,elem2,elem3)</span><br><span class="line"><span class="comment">#定义空元组</span></span><br><span class="line">variable_name = ()</span><br><span class="line">或者</span><br><span class="line">variable_name = <span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure>

<p>​	需要强调的是，当定义元组时，元组元素只有一个时，元素后须接逗号。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name = (elem,)</span><br></pre></td></tr></table></figure>

<h3 id="2-元组（tuple）的下标索引"><a href="#2-元组（tuple）的下标索引" class="headerlink" title="2.元组（tuple）的下标索引"></a>2.元组（tuple）的下标索引</h3><p>​	与列表相同，不过多赘述。</p>
<p>​	但是值得注意的是，在 Python 中，无论是列表、元组还是字符串，都使用方括号 <code>[]</code> 来索引或切片。这是一个通用的规则，适用于所有序列类型的数据。</p>
<h3 id="3-元组（tuple）的常用操作"><a href="#3-元组（tuple）的常用操作" class="headerlink" title="3.元组（tuple）的常用操作"></a>3.元组（tuple）的常用操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义列表</span></span><br><span class="line">mytuple = [elem1, elem2, elem3]</span><br></pre></td></tr></table></figure>

<ul>
<li>查找某个元素的下标</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：tuple.index(elem)</span></span><br><span class="line">number = mytuple.index(elem1)</span><br><span class="line"><span class="built_in">print</span>(number)	<span class="comment">#结果输出elem1的下标</span></span><br><span class="line"><span class="built_in">print</span>(mytuple.index(elem))</span><br><span class="line"><span class="comment">#结果为：ValueError</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计某元素在元组中的数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：tuple.count(elem)</span></span><br><span class="line"><span class="built_in">print</span>(mytuple.conut(elem1))</span><br><span class="line"><span class="comment">#结果为：1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计元组内元素个数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：len(tuple)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mytuple))</span><br><span class="line"><span class="comment">#结果为3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-元组的读写性"><a href="#4-元组的读写性" class="headerlink" title="4.元组的读写性"></a>4.元组的读写性</h3><p>​	元组本身没有写的权限，但是元组中嵌套的可变数据结构中的元素是可以修改的。</p>
<p><img src="/./../imgs/image-20241106154915684.png" alt="image-20241106154915684"></p>
<p>（见test19.py）</p>
<h2 id="5-数据容器：字符串（str）"><a href="#5-数据容器：字符串（str）" class="headerlink" title="5.数据容器：字符串（str）"></a>5.数据容器：字符串（str）</h2><h3 id="1-字符串的定义"><a href="#1-字符串的定义" class="headerlink" title="1.字符串的定义"></a>1.字符串的定义</h3><p>​	字符串是只含有字符类型的数据容器，它与元组一样不可修改。</p>
<h3 id="2-字符串的常用操作"><a href="#2-字符串的常用操作" class="headerlink" title="2.字符串的常用操作"></a>2.字符串的常用操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义字符串</span></span><br><span class="line">mystr = <span class="string">&quot;fsudygfusgf&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查询元素下标</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.index(elem)</span></span><br><span class="line"><span class="built_in">print</span>(mystr.index(<span class="string">&#x27;f&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的替换</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.replace(str1,str2)</span></span><br><span class="line"><span class="built_in">print</span>(mystr.replace(<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为&quot;fsudygfusgf&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr)</span><br><span class="line"><span class="comment">#结果为&quot;asudygfusgf&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：这里并不是将mystr中的值给覆盖了再输出mystr，而是相当于一个返回值。</p>
<ul>
<li>字符串的分割</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.split(分隔符字符串)</span></span><br><span class="line">mystr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="comment">#结果为：[&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>正如上面的结果所示，mystr.split()也不是对mystr进行分割，而是根据分割字符串将分割的结果以列表的形式返回。</p>
<ul>
<li>字符串的规整操作</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#去前后空格</span></span><br><span class="line">mtstr = <span class="string">&quot;   hello world   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.strip())</span><br><span class="line"><span class="comment">#结果为：&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去前后指定字符串</span></span><br><span class="line">mystr = <span class="string">&quot;12hello world21&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.strip(<span class="string">&quot;12&quot;</span>))</span><br><span class="line"><span class="comment">#结果为：&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>同样的，mystr.strip也不会更改mystr的值，也是将新字符串作为返回值返回。</p>
<ul>
<li>统计某字符串出现的次数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.count(string)</span></span><br><span class="line">mystr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.count(<span class="string">&quot;l&quot;</span>))</span><br><span class="line"><span class="comment">#结果为：3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计字符串长度</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mystr))</span><br><span class="line"><span class="comment">#结果为：11</span></span><br></pre></td></tr></table></figure>

<p>值得<strong>特别</strong>注意的是，Python中的字符串并不以’\0’结尾。</p>
<p><img src="/./../imgs/image-20241106173427119.png" alt="image-20241106173427119"></p>
<p>（见test20.py）</p>
<h2 id="6-数据容器（序列）的切片"><a href="#6-数据容器（序列）的切片" class="headerlink" title="6.数据容器（序列）的切片"></a>6.数据容器（序列）的切片</h2><ul>
<li><p>序列：内容连续，有序，可使用下标索引的一类数据容器。元组，列表，字符串都是序列的一种。</p>
</li>
<li><p>序列的切片：从一个序列中取出一个子序列</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：sequence[start_subscript:end_subscript:step]</span></span><br><span class="line"><span class="comment">#表示从序列中，指定位置开始，依次取出元素，到指定位置结束，得到一个新序列</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>起始下标表示从何处开始</p>
</li>
<li><p>结束下标（不含）表示何处结束，可以留空，留空视作取到结尾</p>
</li>
<li><p>步长表示依次取元素的间隔</p>
</li>
<li><p>步长n表示，每次跳过n-1个元素取</p>
</li>
<li><p>当n&lt;0时，表示反向取（此时，起始下标和结束下标也要反向标记 ）</p>
</li>
<li><p>步长为n(n&lt;0),每次反向跳过n-1个元素取</p>
</li>
<li><p>切片操作并不会更改原有序列，而是会产生新的序列</p>
</li>
</ul>
<p><img src="/./../imgs/image-20241106200121706.png" alt="image-20241106200121706"></p>
<p>(见test21.py)</p>
<h2 id="7-数据容器：集合（set）"><a href="#7-数据容器：集合（set）" class="headerlink" title="7.数据容器：集合（set）"></a>7.数据容器：集合（set）</h2><h3 id="1-集合的定义"><a href="#1-集合的定义" class="headerlink" title="1.集合的定义"></a>1.集合的定义</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义集合字面量</span></span><br><span class="line">&#123;elem1,elem2,elem3&#125;</span><br><span class="line"><span class="comment">#定义集合变量</span></span><br><span class="line">set_name = &#123;elem1,elem2,elem3&#125;</span><br><span class="line"><span class="comment">#定义空集合</span></span><br><span class="line">set_name = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>之所以这里只能使用set()而不是set{}的原因是，set是python的内置函数，用于创建集合对象,eg:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">myset = <span class="built_in">set</span>(mylist)</span><br><span class="line"><span class="comment">#myset = &#123;1,2,3,4&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以通过set函数创建空集合或者从其他可迭代数据结构中获取元素来创建集合。</p>
<h3 id="2-集合的常用操作"><a href="#2-集合的常用操作" class="headerlink" title="2.集合的常用操作"></a>2.集合的常用操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个集合</span></span><br><span class="line">myset = &#123;elem1, elem2, elem3&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加新元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.add(elem)</span></span><br><span class="line">myset.add(elem)</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果：myset = &#123;elem1,elem2,elem3,elem&#125;</span></span><br><span class="line">myset.add(elem1)</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果为：myset = &#123;elem1, elem2, elem3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：set集合不支持重复元素。</p>
<ul>
<li>移除元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.remove(elem)</span></span><br><span class="line">myset.remove(elem1)</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果：myset = &#123;elem2, elem3&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>随机取出一个元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.pop()</span></span><br><span class="line">myset.pop()</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment">#结果：不定，因为集合没有下标，所以pop会随机取出一个元素，并把这个元素作为返回值返回</span></span><br></pre></td></tr></table></figure>

<ul>
<li>清空集合</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.clear()</span></span><br><span class="line">myset.clear()</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果：set()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>取两个集合的差值</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set1.difference(set2)</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span><br><span class="line">set3 = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"><span class="comment">#结果：set3 = &#123;2，3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：difference方法会创建一个新的集合作为返回值返回，而不是修改set1或set2。并且，新集合的元素是set1有而set2没有的元素。</p>
<ul>
<li>消除两个集合的差值</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set1.difference_updata(set2)</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span><br><span class="line">set1.difference_updata(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)		<span class="comment">#结果为：&#123;2，3&#125;</span></span><br><span class="line"><span class="built_in">print</span>(set2)		<span class="comment">#结果为：&#123;1，4&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：difference_updata方法直接在set1上修改，删除set1中与set2中相同的元素，而不修改set2。</p>
<ul>
<li>合并两个集合</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set1.union(set2)</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)		<span class="comment">#&#123;1,2,3,4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(set2)		<span class="comment">#&#123;1,4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(set1)		<span class="comment">#&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：union方法不会修改set1和set2的值，而是合并集合后创建一个新的集合，并将新集合作为返回值返回。</p>
<ul>
<li>统计元素个数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>集合的遍历</li>
</ul>
<p>​	不支持while循环，因为没有下标。但是支持for循环。</p>
<p><img src="/./../imgs/image-20241106210245574.png" alt="image-20241106210245574"></p>
<p>（见test22.py）</p>
<h2 id="8-数据容器：dict-字典"><a href="#8-数据容器：dict-字典" class="headerlink" title="8.数据容器：dict(字典)"></a>8.数据容器：dict(字典)</h2><h3 id="1-dict-字典-的定义"><a href="#1-dict-字典-的定义" class="headerlink" title="1.dict(字典)的定义"></a>1.dict(字典)的定义</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义字典字面量</span></span><br><span class="line">&#123;key1:value1,key2:value2,key3:value3&#125;</span><br><span class="line"><span class="comment">#定义字典变量</span></span><br><span class="line">mydict = &#123;key1:value1,key2:value2,key3:value3&#125;</span><br><span class="line"><span class="comment">#定义空字典</span></span><br><span class="line">mydict = &#123;&#125;</span><br><span class="line">或</span><br><span class="line">mydict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>键值对，像key:value这样可以将关键信息与值匹配起来称为一个元素的称之为键值对。</p>
</li>
<li><p>重复定义字典：</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;key1:value1,key1:value2,key3:value3&#125;</span><br><span class="line"><span class="built_in">print</span>(mydict)</span><br><span class="line"><span class="comment">#结果：mydict = &#123;key1:value2,key3:value3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：重复定义字典（即key值相同），后定义的键值对会将先定义的键值对</p>
<p>覆盖。</p>
<ul>
<li>字典数据的获取</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;key1:value1,key1:value2,key3:value3&#125;</span><br><span class="line"><span class="built_in">print</span>(mydict[key1])</span><br><span class="line"><span class="built_in">print</span>(mydict[key2])</span><br><span class="line"><span class="built_in">print</span>(mydict[key3])</span><br></pre></td></tr></table></figure>

<p>注:字典没有下标，但是可以通过key取到value。</p>
<ul>
<li><p>嵌套字典<br>  字典的key和value类型不受限制（key不能为字典），这就意味着字典可以嵌套。</p>
</li>
<li><p>嵌套字典的索引</p>
</li>
</ul>
<p>​	类似二维数组的索引</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>[key_surface][key_inner]</span><br></pre></td></tr></table></figure>



<h3 id="2-字典的常用操作"><a href="#2-字典的常用操作" class="headerlink" title="2.字典的常用操作"></a>2.字典的常用操作</h3><ul>
<li>新增元素和更改元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在字典中我们可以对键值对中的value进行修改，eg:</span></span><br><span class="line"><span class="built_in">dict</span>[key] = value_new</span><br><span class="line"><span class="comment">#当key不存在时就是新增了一个键值对</span></span><br><span class="line"><span class="comment">#当key存在时就是对键值对key:value的value进行了修改，相当于更新元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：dict.pop(key)</span></span><br><span class="line">mydict = &#123;key1:value1,key2:value2,key3:value3&#125;</span><br><span class="line"><span class="built_in">print</span>(mydict.pop(key1))</span><br><span class="line"><span class="comment">#结果为：value2</span></span><br><span class="line"><span class="built_in">print</span>(mydict)</span><br><span class="line"><span class="comment">#结果为：mydict = &#123;key1:value2,key3:value3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：pop（key）方法可以取到键值对key:value的value，并且将该键值对从字典中删除。</p>
<ul>
<li>清除字典</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：dict.clear()</span></span><br><span class="line">mydict.clear()</span><br><span class="line"><span class="comment">#结果为：&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取全部key和遍历字典</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：dict.keys()</span></span><br><span class="line">keys= = mydict.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br><span class="line"><span class="comment">#结果：mydict = &#123;key1,key2,key3&#125;</span></span><br></pre></td></tr></table></figure>

<p>获取key之后就可以进行遍历了</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> mydict:</span><br></pre></td></tr></table></figure>

<p>注：上述两者的key值是完全等价的</p>
<ul>
<li>统计字典中的元素数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(mydict)</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241106220318867.png" alt="image-20241106220318867"></p>
<p>(见test23.py)</p>
<h2 id="9-数据容器总结"><a href="#9-数据容器总结" class="headerlink" title="9.数据容器总结"></a>9.数据容器总结</h2><ul>
<li><p>是否支持下标索引：</p>
<ul>
<li>支持：列表，元组，字符串—序列类型</li>
<li>不支持：集合，字典—非序列类型</li>
</ul>
</li>
<li><p>是否支持重复元素：</p>
<ul>
<li>支持：列表，元组，字符串—序列类型</li>
<li>不支持：集合，字典—非序列类型</li>
</ul>
</li>
<li><p>是否可以修改：</p>
<ul>
<li>支持：列表，集合，字典</li>
<li>元组，字符串</li>
</ul>
</li>
</ul>
<p><img src="/./../imgs/image-20241106221513743.png" alt="image-20241106221513743"></p>
<h2 id="10-数据容器的通用操作"><a href="#10-数据容器的通用操作" class="headerlink" title="10.数据容器的通用操作"></a>10.数据容器的通用操作</h2><ul>
<li><p>都支持遍历操作</p>
<ul>
<li>序列支持while</li>
<li>非序列不支持while</li>
</ul>
</li>
<li><p>通用方法：</p>
<ul>
<li>len()    （计算元素个数）</li>
<li>max()    (取最大元素)</li>
<li>min()    (取最小元素)</li>
<li>字符串也支持ASCII码</li>
</ul>
</li>
<li><p>强制转换：</p>
<ul>
<li>list(data_container)</li>
<li>str(data_container)</li>
<li>tuple(data_container)</li>
<li>set(data_container)</li>
</ul>
</li>
<li><p>通用排序函数：</p>
<p>sorted(data_container, [reverse&#x3D;True])</p>
<p>[reverse]默认是False，如果想让排序反转，[reverse&#x3D;Ture]</p>
</li>
</ul>
<h1 id="六-函数进阶"><a href="#六-函数进阶" class="headerlink" title="六.函数进阶"></a>六.函数进阶</h1><ul>
<li>函数的多返回值：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">param</span>):</span><br><span class="line">    <span class="keyword">return</span> ret1, ret2</span><br><span class="line">a, b = function</span><br><span class="line"><span class="built_in">print</span>(a)	<span class="comment">#ret1</span></span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#ret2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数的多种传参方式：</li>
</ul>
<ol>
<li><p><strong>位置参数</strong>：</p>
<ul>
<li>通过位置传递参数，参数的值根据其位置来匹配。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">result = func(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># a=1, b=2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关键字参数</strong>：</p>
<ul>
<li>使用关键字（参数名）传递参数，可以不按顺序传递。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = func(b=<span class="number">2</span>, a=<span class="number">1</span>)  <span class="comment"># a=1, b=2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>默认参数</strong>：</p>
<ul>
<li>在定义函数时为参数设置默认值，如果调用时不传递该参数，则使用默认值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">result1 = func(<span class="number">1</span>)    <span class="comment"># b使用默认值2</span></span><br><span class="line">result2 = func(<span class="number">1</span>, <span class="number">3</span>) <span class="comment"># b=3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>可变位置参数（*args）</strong>：</p>
<ul>
<li>使用星号（<code>*</code>）可以接收任意数量的位置参数，这些参数会被存储在一个元组中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line">result = func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># args=(1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>可变关键字参数（</strong>kwargs）**：</p>
<ul>
<li>使用双星号（<code>**</code>）可以接收任意数量的关键字参数，这些参数会被存储在一个字典中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> kwargs</span><br><span class="line"></span><br><span class="line">result = func(a=<span class="number">1</span>, b=<span class="number">2</span>)  <span class="comment"># kwargs=&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>命名关键字参数</strong>：</p>
<ul>
<li>在函数定义中可以限制关键字参数的名称，使用<code>*</code>来分隔位置参数与命名关键字参数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *, c, d</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d</span><br><span class="line"></span><br><span class="line">result = func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)  <span class="comment"># c=3, d=4</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>参数类型提示</strong>：</p>
<ul>
<li>使用类型提示来指明参数的预期类型，增加代码的可读性和可维护性。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些方法各自有其使用场景，可以根据需要选择适合的传参方式。</p>
<ul>
<li>**匿名函数<ul>
<li>def 可以定义一个带<strong>有名称</strong>的函数，lambda可以定义一个<strong>匿名</strong>函数</li>
<li>有名称的函数可以基于名称重复调用，匿名函数仅作临时使用</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义语法</span></span><br><span class="line"><span class="keyword">lambda</span> (parameter1,……):function_struct</span><br><span class="line"><span class="comment">#值得注意的是，函数体中仅能写一行代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实操</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">com</span>):</span><br><span class="line">    ret = com(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="built_in">print</span>(test_func(<span class="keyword">lambda</span> x,y: x*y))</span><br><span class="line"><span class="comment">#结果为：2</span></span><br><span class="line"><span class="comment">#等价于：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">add</span>):</span><br><span class="line">    ret = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="built_in">print</span>(test_func(add))</span><br></pre></td></tr></table></figure>

<h1 id="七-Pyhton文件操作"><a href="#七-Pyhton文件操作" class="headerlink" title="七.Pyhton文件操作"></a>七.Pyhton文件操作</h1><h2 id="1-文件编码"><a href="#1-文件编码" class="headerlink" title="1.文件编码"></a>1.文件编码</h2><p>​	编码技术：翻译的规则，记录了如何将内容翻译为二进制机器语言，以及如何将二进制文本转换为可识别内容。</p>
<p>​	但是编码的规则多种多样，但是现在一般都使用UTF-8编码规则。 </p>
<h2 id="2-文件的读取"><a href="#2-文件的读取" class="headerlink" title="2.文件的读取"></a>2.文件的读取</h2><ul>
<li>文件操作的作用</li>
</ul>
<p>​	内存中存放的数据在计算机关机后就会被重置，也就是说要长久地保存文件就得使用硬盘，光盘，U盘等设备。</p>
<p>​	但是很显然地，如果仅仅是这样，对于保存数据地再访问是麻烦的事。于是，引入“<strong>文件</strong>”的概念，方便数据的管理与检索。</p>
<p>​	一般来说，一段音频，一段视频，一个可执行程序都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中存储的数据。</p>
<p>​	文件一般可以分为文本文件，视频文件，音频文件，图像文件，可执行文件等多种类别。</p>
<p>​	在日常生活中，文件的操作主要包括打开，关闭，读，写等操作。</p>
<ul>
<li><p>文件的读取</p>
<ul>
<li>open()打开函数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：open(name,mode,encoding)</span></span><br><span class="line"><span class="comment">#name:是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。</span></span><br><span class="line"><span class="comment">#mode:设置打开文件的模式(访问模式):只读、写入、追加等。</span></span><br><span class="line"><span class="comment">#encoding:编码格式(推荐使用UTF-8)</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot; UTF-8)</span></span><br><span class="line"><span class="string">#encoding的顺序不是第三位,所以不能用位置参数,用关键字参数直接指定</span></span><br></pre></td></tr></table></figure>

<p>注意：此时的’f’不是变量，而是open函数的文件对象。</p>
<p>mode常用的三种基础访问模式：</p>
<p><img src="/./../imgs/image-20241107171613416.png" alt="image-20241107171613416"></p>
<ul>
<li><p>读操作相关方法</p>
<p>当open了一个文件对象’f’后，这个文件对象中会内置很多方法</p>
<ul>
<li>read()方法</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.read(num)</span><br><span class="line"><span class="comment">#num表示要从文件中读取的数据长度（以字节为单位），如果没有传入num，那么就代表读取文件中的所有数据。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>readlines()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.readlines()</span><br><span class="line"><span class="comment">#readlines()方法按照的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>readline()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.readline()</span><br><span class="line"><span class="comment">#readline方法每次只读取一行数据，返回内容是字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>for循环读取文件行</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(file_name)</span><br><span class="line">	<span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment">#每一个line临时变量就记录文件的一行数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>close()方法关闭文件对象</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(file_name)</span><br><span class="line">f.close</span><br><span class="line"><span class="comment">#通过close关闭文件对象，也就是关闭对文件的占用</span></span><br><span class="line"><span class="comment">#如果不调用close，且程序一直运行，则该文件将一直被Python占用。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>with open函数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name,mode) <span class="keyword">as</span> f:</span><br><span class="line">    f.method()</span><br><span class="line"><span class="comment">#该函数可以在操作完毕后自动关闭文件，以防忘记使用close。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="/./../imgs/image-20241107173333618.png" alt="image-20241107173333618"></p>
<p>（见test24.py）</p>
<h2 id="3-文件的写入"><a href="#3-文件的写入" class="headerlink" title="3.文件的写入"></a>3.文件的写入</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(file_name,<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>write()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.write(写入的内容)</span><br><span class="line"><span class="comment">#仅仅write方法还并不能将内容写入文件，而是会积攒在程序的内存中，称之为缓冲区。</span></span><br><span class="line"><span class="comment">#这是为了避免频繁操作硬盘，导致效率下降</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flush（）方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.flush()</span><br><span class="line"><span class="comment">#内容刷新，将缓冲区内的数据刷新至文件。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文件的追加"><a href="#4-文件的追加" class="headerlink" title="4.文件的追加"></a>4.文件的追加</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(file_name,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>write()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.write(追加的内容)</span><br><span class="line"><span class="comment">#仅仅write方法还并不能将内容追加至文件，而是会积攒在程序的内存中，称之为缓冲区。</span></span><br><span class="line"><span class="comment">#这是为了避免频繁操作硬盘，导致效率下降</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flush（）方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.flush()</span><br><span class="line"><span class="comment">#内容刷新，将缓冲区内的数据刷新至文件。</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="八-Python异常，模块与包"><a href="#八-Python异常，模块与包" class="headerlink" title="八.Python异常，模块与包"></a>八.Python异常，模块与包</h1><h2 id="1-了解异常"><a href="#1-了解异常" class="headerlink" title="1.了解异常"></a>1.了解异常</h2><p>​	异常是检测到错误时，Python解释器无法继续运行，即为异常，可能是语法错误，如用lambda定义有名称函数，也有可能是逻辑错误，如下标索引超出范围。</p>
<h2 id="2-异常的捕获方式"><a href="#2-异常的捕获方式" class="headerlink" title="2.异常的捕获方式"></a>2.异常的捕获方式</h2><p>​	捕获异常的意义在于提前假设某处会出现异常，提前做好准备，当真的出现异常时可以有后续的手段，以此增强程序的健壮性。</p>
<ul>
<li>捕获常规异常</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    可能发生错误的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常执行的代码</span><br></pre></td></tr></table></figure>

<ul>
<li>捕获指定异常</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> SpecialError <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="comment">#在python中本身内置了很多种类的异常，as e的意思是将这个异常信息赋值给变量e</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>捕获多个异常</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> (SpecialError1,SpecialError2) <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="comment">#注意：这里是满足任意一个异常就会被被捕获，并将异常信息赋值给变量e</span></span><br></pre></td></tr></table></figure>

<ul>
<li>捕获全部异常</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br></pre></td></tr></table></figure>

<ul>
<li>异常的else和finally语法</li>
<li>异常的else：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> (SpecialError1,SpecialError2) <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    stuct</span><br></pre></td></tr></table></figure>

<p>​	也就是说，如果没有异常就会执行else里的语句，同时try中的语句也会执行</p>
<ul>
<li>finally：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> (SpecialError1,SpecialError2) <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    stuct</span><br><span class="line"><span class="keyword">finally</span>：</span><br><span class="line">	do</span><br></pre></td></tr></table></figure>

<p>​	finally的作用在于不管如何都会执行finally中的语句。</p>
<ul>
<li>异常捕获需要注意的点：<ul>
<li>try中的语句如果任意一条触发异常，那么整个try中的语句都不会执行</li>
<li>常规捕获的是指捕获<strong>任何</strong>会造成程序中断的异常，包括系统退出、键盘中断等不属于程序本身的部分，但是全部捕获是指捕获在Exception这个类及其子类的异常</li>
</ul>
</li>
</ul>
<h2 id="3-异常的传递"><a href="#3-异常的传递" class="headerlink" title="3.异常的传递"></a>3.异常的传递</h2><pre><code> 异常是可以传递的。异常会一直传递到执行的最高层级.
</code></pre>
<p>​	也就是说，即使异常存在的结构中没有捕获手段，程序并不会直接报错，而是继续向高层级查找是否会有一个存在于其他结构中的捕获代码对这个异常进行调用，如果没有则报错</p>
<p>​	显然地，我们如果想要处理异常并不需要真正到异常出现的那个语句中去。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例如：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    func = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a())</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-python的模块"><a href="#4-python的模块" class="headerlink" title="4.python的模块"></a>4.python的模块</h2><p>​	python模块(Module)，是一个python文件，以.py结尾。模块能定义函数，类和变量，也包含可执行的代码。</p>
<p>​	模块的作用在于帮助我们<strong>快速实现一些功能</strong>，而不用自己写脚本。我们可以认为：	</p>
<p>​					   	<strong>模块&#x3D;&#x3D;工具包</strong></p>
<p>​					<strong>里面的函数，类和变量&#x3D;&#x3D;工具</strong></p>
<ul>
<li>模块的导入</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">[<span class="keyword">from</span> Moudule_name] <span class="keyword">import</span>[Module|<span class="keyword">class</span>|variable|function|*] [<span class="keyword">as</span> alias]</span><br><span class="line"><span class="comment">#*表示导入模块内的全部内容</span></span><br><span class="line"><span class="comment">#[]在python代码描述语句中表示可选择的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>​	尽管python中有许多内置的模块，但是总不可能所有的场景都适用，于是自定义模块就很重要。</p>
<p>​	前文说到，模块本质上就是.py文件，那么自定义模块就是建立一个自己的.py文件，需要用时，引用文件名即可，自定义模块的引用与内置模块的引用方式并无差别。</p>
<p>​	调用时需要注意的小细节：当调用了不模块的同名内容，后调用的会覆盖先调用的。(事实上，pycharm的提示信息会将没有使用的函数，变量，模块标灰)</p>
<ul>
<li>测试模块</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不妨我们可以设置一个简单的自定义模块如下：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x+y)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#对模块功能进行测试</span></span><br></pre></td></tr></table></figure>

<p>​	当我们写好模块之后难免会对功能进行测试，但是导入模块时会先对模块进行运行，这样一来测试的代码就会被执行，如果不想测试代码被执行呢？</p>
<p>​	<strong>内置变量__name__</strong>:</p>
<p>​	python中存在值固定的内置函数，比如__name__，__name__变量表示当前.py文件在执行的过程中的”地位“，如果当前文件是主函数，那么__name__的值为__main__，如果作为模块，那么__name__的值为模块名。</p>
<p>​	于是，可以使用如下代码来进行模块检测，同时检测代码不会在导入时被运行。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x+y)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	add(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>__all__变量</strong>：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Moudule <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#这个*说是全部内容，事实上是定义在__all__变量中的所有内容</span></span><br><span class="line"><span class="comment">#那么当我们通过重新定义__all__变量就可以将一些其他无关内容排除在外</span></span><br></pre></td></tr></table></figure>

<h2 id="5-安装第三方包"><a href="#5-安装第三方包" class="headerlink" title="5.安装第三方包"></a>5.安装第三方包</h2><p>​	包是模块的集合，安装第三方包只需要通过pip即可安装。但是pip默认是从国外的网站下面下载的，想提高效率可以用国内的镜像站。</p>
<p>​	或者通过pycharm下载。</p>
<h2 id="6-编写并导入自定义的包"><a href="#6-编写并导入自定义的包" class="headerlink" title="6.编写并导入自定义的包"></a>6.编写并导入自定义的包</h2><hr>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="zhouyue&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>