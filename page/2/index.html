<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> zhouyue&#39;s blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">zhouyue&#39;s blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['会当凌绝顶，一览众山小', '且放白鹿青崖间，须行即骑访名山', '不畏浮云遮望眼，自缘身在最高层'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >前端学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2024-12-21T10:06:47.000Z" itemprop="datePublished">2024-12-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端学习笔记"><a href="#前端学习笔记" class="headerlink" title="前端学习笔记"></a>前端学习笔记</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><ul>
<li><p>HTML(Hypertext Markup Language)，通过一系列的**标签(或者说元素)**来定义文本，图像，链接等。HTML标签是由尖括号包围的关键字。</p>
</li>
<li><p>标签通常成对出现，包括开始标签和结束标签，内容位于这两个标签之内，eg:</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是一个超链接。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>除了双标签，也存在单标签，eg:</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>区别：单标签用于没有内容的元素，双标签用于有内容的元素</p>
<h3 id="HTML文件结构"><a href="#HTML文件结构" class="headerlink" title="HTML文件结构"></a>HTML文件结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里放置文档的元信息 -- &gt;</span></span><br><span class="line"><span class="comment">&lt;! DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">    &lt;head&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 这里放置文档的元信息 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;title&gt;文档标题&lt;/title&gt;</span></span><br><span class="line"><span class="comment">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 连接外部样式表或脚本文件等 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;/head&gt;</span></span><br><span class="line"><span class="comment">    &lt;body&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 这里放置页面内容 -- &gt;</span></span><br><span class="line"><span class="comment">        &lt;h1&gt;这是一个标题&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">        &lt;p&gt;这是一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        &lt;a href=&quot;https://www.example.com&quot;&gt;这是一个链接&lt;/a&gt;</span></span><br><span class="line"><span class="comment">        &lt;!-- 其他内容 -- &gt;</span></span><br><span class="line"><span class="comment">    &lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML的常用标签"><a href="#HTML的常用标签" class="headerlink" title="HTML的常用标签"></a>HTML的常用标签</h3><p>详见test01.html</p>
<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><ul>
<li>HTML的属性用于定义元素的行为和外观，以及其他元素的关系</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">start_label</span> <span class="attr">attribute_name</span>=<span class="string">&quot;attribute_value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>每个HTML元素可以具有不同的属性</li>
<li>属性名大小写不敏感，属性值大小写敏感</li>
</ul>
<h3 id="HTML区块"><a href="#HTML区块" class="headerlink" title="HTML区块"></a>HTML区块</h3><ul>
<li><p>块元素</p>
<p>块级元素通常用于组织和布局页面的主要结构内容。它们用于创建页面的主要部分，将内容分割为<strong>逻辑块</strong>。</p>
<ul>
<li>块级元素通常从新行开始，并占据整行的宽度，因此它们会在页面上呈现为一块独立的内容块</li>
<li>可以包含其他块级元素和行内元素</li>
</ul>
</li>
<li><p>行内元素</p>
<ul>
<li>无法包含块级元素，仅能包含行内元素</li>
</ul>
</li>
</ul>
<h4 id="标签"><a href="#标签" class="headerlink" title="&lt;div&gt;标签"></a><code>&lt;div&gt;</code>标签</h4><ul>
<li><strong>块级元素</strong>：<code>&lt;div&gt;</code>是一个块级元素，意味着它会独占一行，前后有换行。</li>
<li><strong>结构性</strong>：通常用于对页面内容进行分组，帮助组织和布局。可以包含其他块级和行内元素。</li>
<li><strong>样式和脚本</strong>：通常与CSS和JavaScript一起使用，以便对特定部分的样式进行控制或添加交互功能。</li>
<li><strong>常见用途</strong>：用于创建页面的布局结构，比如头部、侧边栏、内容区域和页脚等。</li>
</ul>
<h4 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;span&gt;标签"></a><code>&lt;span&gt;</code>标签</h4><ul>
<li><strong>行内元素</strong>：<code>&lt;span&gt;</code>是一个行内元素，意味着它不会独占一行，通常用于对文本或其他行内元素进行样式化。</li>
<li><strong>无语义</strong>：<code>&lt;span&gt;</code>本身没有语义，仅用于样式和布局，通常与CSS一起使用来改变文本的样式。</li>
<li><strong>常见用途</strong>：用于包裹部分文本，应用特定的样式或脚本，比如改变颜色、字体或添加事件监听</li>
</ul>
<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><ul>
<li>HTML表单是用于收集用户输入数据的结构化元素。通过表单，用户可以输入信息并将其提交到服务器进行处理。HTML表单通常包含各种输入元素，例如文本框、单选按钮、复选框、下拉列表等</li>
</ul>
<p>关于表单的创建，有以下需要注意的点：</p>
<ol>
<li>所有表单需要在form标签下</li>
<li>常用于表单的标签有：<ol>
<li>label：用于描述表单控件的标签</li>
<li>input：各种类型的输入控件</li>
</ol>
</li>
</ol>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的三种导入方式"><a href="#CSS的三种导入方式" class="headerlink" title="CSS的三种导入方式"></a>CSS的三种导入方式</h3><p>内联样式&gt;内部样式表&gt;外部样式表</p>
<p>详见test02.html</p>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>选择器是CSS中的关键部分，它允许针对特定元素或一组元素定义样式</p>
<p>ID&gt;类&gt;标签名</p>
<h3 id="CSS网页布局"><a href="#CSS网页布局" class="headerlink" title="CSS网页布局"></a>CSS网页布局</h3><p>略</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>轻量级的解释型脚本语言，常用于网页交互和客户端脚本开发</p>
<h3 id="JS的导入"><a href="#JS的导入" class="headerlink" title="JS的导入"></a>JS的导入</h3><p>同CSS，只不过在<code>&lt;script&gt;&lt;/script&gt;</code>标签中写罢了</p>
<h3 id="JS的变量和数据类型"><a href="#JS的变量和数据类型" class="headerlink" title="JS的变量和数据类型"></a>JS的变量和数据类型</h3><p><strong>在JavaScript中，<code>const</code>用于声明常量，<code>var</code> 和 <code>let</code> 都是用来声明变量的方法，但它们有一些重要的区别：</strong></p>
<h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><ul>
<li>**<code>var</code>**：具有函数作用域（function scope）。这意味着在一个函数内声明的 <code>var</code> 变量在整个函数中都是可见的。</li>
<li>**<code>let</code>**：具有块级作用域（block scope）。这意味着在一个块（例如花括号 <code>&#123;&#125;</code>）内声明的 <code>let</code> 变量只在这个块内部可见。</li>
</ul>
<h3 id="2-变量提升"><a href="#2-变量提升" class="headerlink" title="2. 变量提升"></a>2. 变量提升</h3><ul>
<li>**<code>var</code>**：变量声明会被提升（hoisting）到函数或全局作用域的顶部，但赋值不会提升。因此，可以在声明之前使用，但值为 <code>undefined</code>。</li>
<li>**<code>let</code>**：变量声明不会被提升，或者说会被提升但不会初始化。在声明之前使用 <code>let</code> 变量会导致 ReferenceError 错误。</li>
</ul>
<h3 id="3-重复声明"><a href="#3-重复声明" class="headerlink" title="3. 重复声明"></a>3. 重复声明</h3><ul>
<li>**<code>var</code>**：可以在同一作用域内多次声明同一个变量。</li>
<li>**<code>let</code>**：在同一作用域内不能重复声明同一个变量。</li>
</ul>
<p>现在的代码中尽量使用let而不是var，但是也不是什么要紧的事，由于前端三大件语法的简单，AI已经可以很好地写很漂亮的代码，不需要自己写，仅作了解即可</p>
<h2 id="JS的数据类型与变量"><a href="#JS的数据类型与变量" class="headerlink" title="JS的数据类型与变量"></a>JS的数据类型与变量</h2><p>略，无需在意</p>
<h2 id="JS的控制语句"><a href="#JS的控制语句" class="headerlink" title="JS的控制语句"></a>JS的控制语句</h2><p>和C语言完全一致</p>
<h2 id="JS的函数"><a href="#JS的函数" class="headerlink" title="JS的函数"></a>JS的函数</h2><p>与C几乎相同，唯一的区别事使用function定义而不需要根据函数返回值的类型更改函数头信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">function_name</span>(<span class="params">param1,param2,……</span>)&#123;</span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Python2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/Python2/"
    >Python2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/Python2/" class="article-date">
  <time datetime="2024-12-21T10:04:23.000Z" itemprop="datePublished">2024-12-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一-面向对象"><a href="#一-面向对象" class="headerlink" title="一.面向对象"></a>一.面向对象</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h2><p>​	类(class)是面向对象编程的一个概念，它类似模板或者蓝图，拥有某一类事物共性的特征，比如cat类，那么一定有尾巴，眼睛，四肢等等，至于某一个属性的状态，比如存在或者不存在则是特性的东西。</p>
<p>​	事物可以从两方面来进行描述，属性和行为。相似地，类(class)中也有属性和行为，分别通过定义成员变量和成员方法来描述。</p>
<p>​	既然类是模板或者蓝图，那么想要依据共性的模板创建一个特性的实例就需要创建对象，这个根据类创建对象的过程叫做实例化。</p>
<p>​	面向对象三大特性：封装，继承，多态。</p>
<p>​	面向对象编程就是：设计类，基于类创建对象，让对象干活做具体的工作。</p>
<p>以下是python中面向对象编程的一个具体过程：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设计类，以Dog类为例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    age = <span class="literal">None</span></span><br><span class="line">    <span class="comment">#定义基本行为</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">    <span class="comment">#self是必须的形参，事实上，self只是一个特征，表明这是一个类中的方法，在实际调用方法是并不需要我们真的进行self的传参，IDE会自动传递实参self。</span></span><br><span class="line"><span class="comment">#创建对象</span></span><br><span class="line">xiaohua = Dog()</span><br><span class="line">xiaohua.name = <span class="string">&quot;xiaohua&quot;</span></span><br><span class="line">xiaohua.age = <span class="number">6</span></span><br><span class="line"><span class="comment">#让对象工作</span></span><br><span class="line">xiaohua.bark()</span><br></pre></td></tr></table></figure>

<p>​	这是一种创建类的手段，基于这种类创建对象时需要对属性一个个赋值，无法一次性赋值。</p>
<ul>
<li>__init__构造方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设计类，以Dog类为例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="comment">#__init__是python中的内置方法，用于初始化类的实例</span></span><br><span class="line">    <span class="comment">#定义基本行为</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line"><span class="comment">#创建对象</span></span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">#让对象工作</span></span><br><span class="line">xiaohua.bark()</span><br><span class="line"><span class="built_in">print</span>(xiaohua.age)</span><br></pre></td></tr></table></figure>

<p>​	__init__本身的作用是，在构建类时传入的参数会自动提供给__init__方法，并且__init__方法会自动执行</p>
<h2 id="2-python内置方法"><a href="#2-python内置方法" class="headerlink" title="2.python内置方法"></a>2.python内置方法</h2><p>​	类似上文中的__init__方法，python中有许多内置方法，称为魔术方法。</p>
<p>常见的内置方法：</p>
<h3 id="1-str-字符串方法"><a href="#1-str-字符串方法" class="headerlink" title="1.__str__字符串方法"></a>1.__str__字符串方法</h3><p>​	<code>__str__</code> 方法是 Python 中一个特殊的方法，它用于定义一个对象的“字符串表示”。当你使用 <code>print()</code> 函数或 <code>str()</code> 函数来输出一个对象时，Python 会调用该对象的 <code>__str__</code> 方法。</p>
<p>​	通过实现 <code>__str__</code> 方法，你可以提供一个更友好的、可读性更强的输出格式，方便调试和日志记录。</p>
<p>​	当没有对<code>__str__</code>进行人为定义时，默认会返回类的地址，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua)</span><br><span class="line"><span class="comment">#&lt;__main__.Dog object at 0x000001BD22E85DF0&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>&quot;</span></span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua)</span><br><span class="line"><span class="comment">#&quot;xiaohua&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-lt-方法"><a href="#2-lt-方法" class="headerlink" title="2.__lt__方法"></a>2.<code>__lt__</code>方法</h3><p>​	<code>__it__</code>方法用于比较两个类特定属性进行“&lt;”比较，返回bool值，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line">dahuang = Dog(<span class="string">&quot;dahuang&quot;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua&lt;dahuang)</span><br><span class="line"><span class="comment">#报错，因为在定义类时并没有赋予它可以比较这个属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,another_class</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.age&lt;another_class.age</span><br><span class="line">xiaohua = Dog(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">6</span>)</span><br><span class="line">sangbiao = Dog(<span class="string">&quot;sangbiao&quot;</span>,<span class="number">7</span>)</span><br><span class="line">dahuang = Dog(<span class="string">&quot;dahuang&quot;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(xiaohua&lt;dahuang)</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(xiaohua&lt;sangbiao)</span><br><span class="line"><span class="comment">#True</span></span><br></pre></td></tr></table></figure>

<p>注意：这里的<code>__lt__</code>方法仅限于“&lt;”的比较，也就是说print(xiaohua&gt;sangbiao)会报错。</p>
<ul>
<li><p>其他比较魔术方法：</p>
</li>
<li><p><code>__eq__(self, other)</code>: 实现相等运算符 <code>==</code>。</p>
</li>
<li><p><code>__ne__(self, other)</code>: 实现不等运算符 <code>!=</code>。</p>
</li>
<li><p><code>__lt__(self, other)</code>: 实现小于运算符 <code>&lt;</code>。</p>
</li>
<li><p><code>__le__(self, other)</code>: 实现小于等于运算符 <code>&lt;=</code>。</p>
</li>
<li><p><code>__gt__(self, other)</code>: 实现大于运算符 <code>&gt;</code>。</p>
</li>
<li><p><code>__ge__(self, other)</code>: 实现大于等于运算符 <code>&gt;=</code>。</p>
</li>
</ul>
<h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h2><p>​	封装是面向对象编程的一种思想，它指的是将数据（属性）和操作数据的方法（行为）结合在一起，将数据的实现细节隐藏起来，只暴露出必要的接口给外部使用。这样可以提高代码的安全性和可维护性。</p>
<p>​	<img src="/./../imgs/image-20241120203845991.png" alt="image-20241120203845991"></p>
<p>封装的主要优点包括：</p>
<ol>
<li><strong>数据隐藏</strong>：通过将数据私有化，只允许通过公共方法访问，减少了数据被随意修改的风险。</li>
<li><strong>提高代码的可维护性</strong>：如果需要修改内部实现，只需在类内部进行修改，而不影响使用该类的外部代码。</li>
<li><strong>降低复杂性</strong>：外部代码只需要了解接口，而不需要关心内部实现，简化了使用过程。</li>
</ol>
<ul>
<li>私有成员</li>
</ul>
<p>​	现实生活中的一些事物的部分属性和行为并不对所有人开放，类也是如此。类中提供了私有成员的形式来支持该特性。</p>
<p>​	定义私有成员只需要在私有成员名字前加“__”即可。</p>
<p>​	虽然私有成员无法被通过类访问，但是可以在类中被其他成员访问</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>:</span><br><span class="line">    __current_voltage = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__keep_single_core</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g通话已开启&quot;</span>)</span><br><span class="line">xiaomi = Phone()</span><br><span class="line"><span class="built_in">print</span>(xiaomi.__current_voltage)</span><br><span class="line"><span class="built_in">print</span>(xiaomi.__keep_single_core)</span><br><span class="line"><span class="comment">#报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>:</span><br><span class="line">    __current_voltage = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__keep_single_core</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;CPU以单核模式运行&quot;</span>)</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">def</span> <span class="title function_">call_by_5g</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">if</span> <span class="variable language_">self</span>.__current_voltage&gt;=<span class="number">1</span>:</span><br><span class="line">        	<span class="built_in">print</span>(<span class="string">&quot;5g通话已开启&quot;</span>)</span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">        	<span class="variable language_">self</span>.__keep_single_core()</span><br><span class="line">        	<span class="built_in">print</span>(<span class="string">&quot;电量不足，无法开启5g通信，已设置单核模式省电&quot;</span>)</span><br><span class="line">xiaomi = Phone()</span><br><span class="line">call_by_5g()</span><br><span class="line"><span class="comment">#5g通话已开启</span></span><br></pre></td></tr></table></figure>



<h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h2><p>​	定义一个新的类，新的类的属性与方法继承自一个老的类，并且新的类有独属于自己的属性与方法。</p>
<p>语法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sub_class</span>(<span class="title class_ inherited__">super_class</span>):</span><br><span class="line">    class_stuct</span><br></pre></td></tr></table></figure>

<ul>
<li>单继承：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line">    IMET = <span class="literal">None</span></span><br><span class="line">    producer = <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_4g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4g&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone_new</span>(<span class="title class_ inherited__">phone</span>):</span><br><span class="line">    face_id = <span class="string">&quot;10001&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_5g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>多继承：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NFC</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#pass,占位符，无实际意义，用于定义空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xiaomi</span>(phone_new,NFC):</span><br><span class="line">    class_struct</span><br></pre></td></tr></table></figure>

<p>​	多个父类中,如果有同名的成员,那么默认以继承顺序(从左到右)为优先级。</p>
<p>即:先继承的保留,后继承的被覆盖</p>
<ul>
<li>复写父类成员</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line">    IMET = <span class="literal">None</span></span><br><span class="line">    producer = <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_4g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4g&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone_new</span>(<span class="title class_ inherited__">phone</span>):</span><br><span class="line">    face_id = <span class="string">&quot;10001&quot;</span></span><br><span class="line">    producer = <span class="string">&quot;microsoft&quot;</span> <span class="comment">#复写父类成员变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_by_4g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)	<span class="comment">#复写父类成员方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用父类同名成员</li>
</ul>
<p>​	如果在子类中对父类进行复写，那么在子类中调尝试用父类同名成员时会调用复写后的成员，如果想真正能访问到父类中同名成员，需要用特殊的调用方式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mode1:</span></span><br><span class="line">superclass_name.menber_variable</span><br><span class="line">superclass_name.menber_method(<span class="variable language_">self</span>)</span><br><span class="line"><span class="comment">#mode2:</span></span><br><span class="line"><span class="built_in">super</span>().menber_variable</span><br><span class="line"><span class="built_in">super</span>().menber_method()</span><br></pre></td></tr></table></figure>

<h2 id="5-类型注解"><a href="#5-类型注解" class="headerlink" title="5.类型注解"></a>5.类型注解</h2><p><img src="/./../imgs/image-20241120214610619.png" alt="image-20241120214610619"></p>
<p><strong>为容器作注解</strong></p>
<p><img src="/./../imgs/image-20241120214643703.png" alt="image-20241120214643703"></p>
<p><strong>在注释中作注解</strong></p>
<p><img src="/./../imgs/image-20241120214734372.png" alt="image-20241120214734372"></p>
<p><strong>对函数参数进行注解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">param1:<span class="built_in">type</span>,param2:<span class="built_in">type</span>,……</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>对函数返回值进行注解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">param1:<span class="built_in">type</span>,param2:<span class="built_in">type</span>,……</span>) -&gt; ret_type:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>Union注解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用 Union 来表示值可以是多种类型之一。</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_value</span>(<span class="params">value: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(value)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，注解并<strong>不会</strong>因为注解而改变变量，参数，或者返回值的类型，也就是说，<em><strong>注解仅仅是用于给编写者或者第三方IDE作提示信息</strong></em>。</p>
<h2 id="6-多态"><a href="#6-多态" class="headerlink" title="6.多态"></a>6.多态</h2><p>​	多态，指的是同一个行为，传入不同的对象，得到不同状态</p>
<p><img src="/./../imgs/image-20241120220404547.png" alt="image-20241120220404547"></p>
<p> <strong>抽象类(接口)</strong></p>
<p><img src="/./../imgs/image-20241120221426109.png" alt="image-20241120221426109"></p>
<hr>
<h1 id="二-SQL入门与实战"><a href="#二-SQL入门与实战" class="headerlink" title="二.SQL入门与实战"></a>二.SQL入门与实战</h1><h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><p>​	数据可以分为储存和计算两部分，编程语言可以归纳为数据计算一类，数据库就是用于数据存储一类。</p>
<ul>
<li>数据库如何组织数据</li>
</ul>
<p>​	<img src="/./../imgs/image-20241121124539489.png" alt="image-20241121124539489"></p>
<ul>
<li>数据库管理系统(数据库软件)</li>
</ul>
<p>​	MySQL,SQLSever等</p>
<ul>
<li>数据库和SQL语言的关系</li>
</ul>
<p>​	数据库用于储存数据，那么在这个过程中无法避免地涉及到数据地增删查改和数据库，数据表的管理。SQL语言就是对数据库进行操作，管理，查询的工具。</p>
<p>​	数据库软件可以获得库-&gt;表-&gt;数据，这种数据组织，储存的能力，并借助SQL语言完成对数据的操作，管理，查询。</p>
<h2 id="2-SQL基础与DDL"><a href="#2-SQL基础与DDL" class="headerlink" title="2.SQL基础与DDL"></a>2.SQL基础与DDL</h2><p>​	SQL全称Structured Query Language,结构化查询语言，用于访问和处理数据库的<strong>标准</strong>的计算机语言。</p>
<ul>
<li><p>SQL的基础语法特征：</p>
<ul>
<li><p>大小写不敏感</p>
</li>
<li><p>单行或多行书写，以;结束</p>
</li>
<li><p>支持注释：</p>
<ol>
<li><p>单行注释：– 注释内容</p>
</li>
<li><p>单行注释：# 注释内容</p>
</li>
<li><p>多行注释：<code>/*注释内容*/</code></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>​	DDL是“数据定义语言”（Data Definition Language）的缩写。它用于定义和管理数据库中的<strong>结构和对象</strong>。</p>
<ul>
<li><p>DDL-库管理</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;	<span class="comment">-- 查看数据库</span></span><br><span class="line">use database_name;	<span class="comment">-- 使用数据库</span></span><br><span class="line"><span class="keyword">create</span> database database_name [charset utf8];	<span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">drop</span> database database_name;	<span class="comment">-- 删除库</span></span><br><span class="line"><span class="keyword">select</span> database();	<span class="comment">-- 查看当前数据库</span></span><br></pre></td></tr></table></figure>




<ul>
<li><p>DLL-表管理</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;	<span class="comment">-- 查看表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> table_name;	<span class="comment">-- 删除表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> table_name(</span><br><span class="line">	column_name1 column_type1,</span><br><span class="line">    column_name2 column_type2,</span><br><span class="line">	column_name3 column_type3,</span><br><span class="line">    ……</span><br><span class="line">  );			<span class="comment">-- 创建表</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-SQL-DML"><a href="#3-SQL-DML" class="headerlink" title="3.SQL-DML"></a>3.SQL-DML</h2><p>​	DML是“数据操纵语言”（Data Manipulation Language）的缩写，它是数据库管理系统（DBMS）中用于<strong>管理数据</strong>的子语言。</p>
<ul>
<li>数据插入insert</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> <span class="keyword">table</span>[(column1,column2,……,<span class="keyword">column</span> n)] <span class="keyword">values</span>(data1,data2,……,data n)[,(data1,data2,……,data n),……,(data1,data2,……,data n)]</span><br><span class="line">#示例：</span><br><span class="line"><span class="keyword">create table</span> student(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line">#仅插入一列</span><br><span class="line"><span class="keyword">insert into</span> student(id) <span class="keyword">values</span>(<span class="number">10001</span>),(<span class="number">10002</span>),(<span class="number">10003</span>);</span><br><span class="line">#插入全部列表</span><br><span class="line"><span class="keyword">insert into</span> student(id,name,age) <span class="keyword">values</span>(<span class="number">10001</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>),(<span class="number">10002</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">#快速插入全部列表</span><br><span class="line"><span class="keyword">insert into</span> student <span class="keyword">values</span>(<span class="number">10001</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>),(<span class="number">10002</span>,<span class="string">&#x27;xiaohua&#x27;</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>数据删除delete</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name [while <span class="keyword">condition</span>];</span><br><span class="line">#注意删除数据是删除所匹配数据所在的一整个结构或对象</span><br></pre></td></tr></table></figure>

<ul>
<li>数据更新update</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> <span class="keyword">column</span> <span class="operator">=</span> value1 [<span class="keyword">where</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>



<h2 id="3-SQL-DQL"><a href="#3-SQL-DQL" class="headerlink" title="3.SQL-DQL"></a>3.SQL-DQL</h2><p>​	DQL（Data Query Language）是用于查询数据库中数据的语言，主要用于从数据库中<strong>检索数据</strong>。</p>
<ul>
<li>查询数据select</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column1,column2,……,<span class="keyword">column</span> n <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>];</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name </span><br></pre></td></tr></table></figure>

<ul>
<li>分组聚合</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column1,column2,……,<span class="keyword">column</span> n<span class="operator">|</span>聚合函数 <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>] <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">column</span> x;</span><br><span class="line">#聚合函数：</span><br><span class="line"><span class="operator">-</span> <span class="built_in">sum</span>(<span class="keyword">column</span>)	求和</span><br><span class="line"><span class="operator">-</span> <span class="built_in">avg</span>(<span class="keyword">column</span>)	求平均值</span><br><span class="line"><span class="operator">-</span> <span class="built_in">min</span>(<span class="keyword">column</span>)	求最小值</span><br><span class="line"><span class="operator">-</span> <span class="built_in">max</span>(<span class="keyword">column</span>)	求最大值</span><br><span class="line"><span class="operator">-</span> <span class="built_in">count</span>(<span class="keyword">column</span><span class="operator">|</span><span class="operator">*</span>)	求数量</span><br></pre></td></tr></table></figure>

<ul>
<li>排序分页</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">column</span><span class="operator">|</span>聚合函数<span class="operator">|</span><span class="operator">*</span> <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>] <span class="keyword">group</span> <span class="keyword">by</span> …… <span class="keyword">order</span> <span class="keyword">by</span> [<span class="keyword">asc</span>(升序)<span class="operator">|</span><span class="keyword">desc</span>(降序)];	#排序</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">column</span><span class="operator">|</span>聚合函数<span class="operator">|</span><span class="operator">*</span> <span class="keyword">from</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>] <span class="keyword">group</span> <span class="keyword">by</span> …… <span class="keyword">order</span> <span class="keyword">by</span> [<span class="keyword">asc</span>(升序)<span class="operator">|</span><span class="keyword">desc</span>(降序)] limit n[,m]; #分页</span><br></pre></td></tr></table></figure>



<h2 id="4-python操作MySQL"><a href="#4-python操作MySQL" class="headerlink" title="4.python操作MySQL"></a>4.python操作MySQL</h2><h3 id="1-python执行SQL语句"><a href="#1-python执行SQL语句" class="headerlink" title="1.python执行SQL语句"></a>1.python执行SQL语句</h3><p>​	除了使用图形化工具来执行SQL语句外，还可以使用编程语言来执行SQL从而进行数据操作。  </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql1</span><br><span class="line"><span class="keyword">from</span> pymysql1.cursors <span class="keyword">import</span> Cursor</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建MySQL数据库的链接</span></span><br><span class="line">conn = pymysql1.Connection(</span><br><span class="line">    password=<span class="string">&#x27;xxxxxxxxxxxx&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># print(conn.get_server_info())</span></span><br><span class="line"><span class="comment">#执行非查询性SQL语句</span></span><br><span class="line">cursor = conn.cursor()      <span class="comment">#获取到游标对象</span></span><br><span class="line">conn.select_db(<span class="string">&quot;try&quot;</span>)       <span class="comment">#选择数据库</span></span><br><span class="line">cursor.execute(<span class="string">&quot;create table test_pymysql(id int);&quot;</span>)    <span class="comment">#将SQL语句以字符串的形式作为参数传到execute方法即可</span></span><br><span class="line"><span class="comment">#执行查询性质的SQL语句</span></span><br><span class="line">cursor = conn.cursor()      <span class="comment">#获取到游标对象</span></span><br><span class="line">conn.select_db(<span class="string">&quot;try&quot;</span>)       <span class="comment">#选择数据库</span></span><br><span class="line">cursor.execute(<span class="string">&quot;select * from student;&quot;</span>)</span><br><span class="line"><span class="comment">#查询结果</span></span><br><span class="line">result: <span class="built_in">tuple</span> = cursor.fetchall()      <span class="comment">#获得查询结果并封装进元组</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="2-python数据插入MySQL"><a href="#2-python数据插入MySQL" class="headerlink" title="2.python数据插入MySQL"></a>2.python数据插入MySQL</h3><p>​	当我们在使用pymysql库执行数据插入或者其他可能产生数据更改的语句时，需要<strong>“提交”</strong>，通过链接对象.commit()即可确认此行为</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Python1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/21/Python1/"
    >Python1</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/21/Python1/" class="article-date">
  <time datetime="2024-12-21T09:54:31.000Z" itemprop="datePublished">2024-12-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一-Python基础语法"><a href="#一-Python基础语法" class="headerlink" title="一.Python基础语法"></a>一.Python基础语法</h1><h2 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h2><p>​	被写下来的固定不变的值（常量）。</p>
<p><img src="/./../imgs/image-20241103214206504.png" alt="image-20241103214206504"></p>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.**变量"></a>2.**变量</h2><p>​	在程序运行时，能储存计算结果或能表示值的抽象概念。</p>
<p>​	事实上，说“储存”是有所偏颇的，准确的来说，Python的变量实际上是对象的引用。（可以理解为C中的指针概念）</p>
<p>​	定义格式：</p>
<p>​	变量名称&#x3D;变量的值</p>
<p><img src="/./../imgs/image-20241104141420085.png" alt="image-20241104141420085"></p>
<p>（见test01.py）</p>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><ul>
<li>type语句：查看数据类型。</li>
<li>即使是查看的变量类型，也是数据类型，因为Python不同于C，它没有严格的类型检查，因此，它的变量是没有类型的，查看的变量的类型实际上是其中存储的数据的类型。</li>
</ul>
<h2 id="4-数据类型转换"><a href="#4-数据类型转换" class="headerlink" title="4.数据类型转换"></a>4.数据类型转换</h2><ul>
<li>为什么要转换类型？</li>
</ul>
<p><img src="/./../imgs/image-20241104143045034.png" alt="image-20241104143045034"></p>
<ul>
<li>常见的转换语句。</li>
</ul>
<p><img src="/./../imgs/image-20241104143224284.png" alt="image-20241104143224284"></p>
<p>​	值得注意的是，这里的三个函数同type()一样都是带返回值的，可以直接在print</p>
<p>函数中输出，或者将其存储于变量中。</p>
<ul>
<li>浮点和整型都可以转字符串</li>
<li>字符串不一定能转浮点和整型</li>
<li>浮点转整型会丢失小数部分</li>
</ul>
<h2 id="5-标识符"><a href="#5-标识符" class="headerlink" title="5.标识符"></a>5.标识符</h2><p>​	标识符就是名字，给变量，方法，类等取的名字，用于做内容的标识。</p>
<ul>
<li>标识符的命名规则：</li>
</ul>
<p>​	1.只允许出现英文，中文，数字，下划线。其中，中文不推荐使用，数字<strong>不能</strong>放开头。</p>
<p>​	2.Python大小写是敏感的。</p>
<p>​	3.不可使用关键字。</p>
<ul>
<li>标识符的命名规范：</li>
</ul>
<p>​	1.简洁明了</p>
<p>​	2.下划线命名法:</p>
<p>​		用下划线分隔单词，以免歧义</p>
<p>​	3.英文字母全部小写</p>
<h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h2><ul>
<li>算术运算符</li>
</ul>
<p><img src="/./../imgs/image-20241104145300579.png" alt="image-20241104145300579"></p>
<p>（这里需要注意的是，Python中的除法<strong>一定</strong>得到浮点型结果，且正常除法与整除是分别由一个运算符来运算的，不像C中是同一个运算符，结果由除数和被除数的类型决定。）</p>
<ul>
<li>赋值运算符：</li>
</ul>
<p>​	右赋左。</p>
<ul>
<li>复合赋值运算符：</li>
</ul>
<p>​	与C中一样由算数运算符+赋值运算符构成，功能也一样。</p>
<h2 id="7-字符串扩展内容"><a href="#7-字符串扩展内容" class="headerlink" title="7.字符串扩展内容"></a>7.字符串扩展内容</h2><h3 id="1-字符串的三种定义方式："><a href="#1-字符串的三种定义方式：" class="headerlink" title="1.字符串的三种定义方式："></a>1.字符串的三种定义方式：</h3><p><img src="/./../imgs/image-20241104150951471.png" alt="image-20241104150951471"></p>
<ul>
<li>字符串的引号嵌套</li>
</ul>
<p><img src="/./../imgs/image-20241104151310495.png" alt="image-20241104151310495"></p>
<h3 id="2-字符串的拼接"><a href="#2-字符串的拼接" class="headerlink" title="2.字符串的拼接"></a>2.字符串的拼接</h3><p> <img src="/./../imgs/image-20241104151724889.png" alt="image-20241104151724889"></p>
<p>（值得注意的是，通过”+“号对字符串的拼接仅限于<strong>字符串</strong>类型，浮点和整型会报错。）</p>
<h3 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3.字符串格式化"></a>3.字符串格式化</h3><ul>
<li>占位符%，和C基本一样。</li>
</ul>
<p><img src="/./../imgs/image-20241104152533368.png" alt="image-20241104152533368"></p>
<p>（当然，也可以使用%d，%f对整型和浮点型进行原封不动的输出，这里只用%s是因为进行了隐式转换。）</p>
<ul>
<li>快速格式化字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;name&#125;</span>，年龄<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125; and I am &#123;&#125; years old&quot;</span>.<span class="built_in">format</span>(name, age))</span><br></pre></td></tr></table></figure>

<p>（不关心类型和精度控制。）</p>
<p>事实上格式化并不是变量的专属，常量和表达式仍然可以直接格式化输出。</p>
<h3 id="4-格式化的精度控制"><a href="#4-格式化的精度控制" class="headerlink" title="4.格式化的精度控制"></a>4.格式化的精度控制</h3><p><img src="/./../imgs/image-20241104155646837.png" alt="image-20241104155646837"></p>
<p>(注意：这里的四舍五入就是最常见的四舍五入，而不是C中的四舍六入五成双。)</p>
<p><img src="/./../imgs/image-20241104161216428.png" alt="image-20241104161216428"></p>
<p>（见test02.py）</p>
<hr>
<h2 id="8-数据输入"><a href="#8-数据输入" class="headerlink" title="8.数据输入"></a>8.数据输入</h2><ul>
<li><p>input语句：从stdin获取输入数据。</p>
</li>
<li><p>input函数有返回值，也就是说可以赋值进变量。</p>
</li>
<li><p>input默认接收的数据都是字符串，输出其他类型需要强制转换。</p>
</li>
</ul>
<p><img src="/./../imgs/image-20241104164623296.png" alt="image-20241104164623296"></p>
<p>（见test03.py）</p>
<h1 id="二-Python判断语句"><a href="#二-Python判断语句" class="headerlink" title="二.Python判断语句"></a>二.Python判断语句</h1><h2 id="1-bool类型与比较运算符"><a href="#1-bool类型与比较运算符" class="headerlink" title="1.bool类型与比较运算符"></a>1.bool类型与比较运算符</h2><ul>
<li>bool类型：与C中相同，略</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = <span class="literal">True</span>/<span class="literal">False</span></span><br></pre></td></tr></table></figure>



<ul>
<li>比较运算符：同C</li>
</ul>
<h2 id="2-if语句的基本格式"><a href="#2-if语句的基本格式" class="headerlink" title="2.if语句的基本格式"></a>2.if语句的基本格式</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;this place isn&#x27;t for you&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get out!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>(与C不同，Python中判断一条语句是否从属于判断语句并不是用{}括起来进行分区，而是看是否有一个制表符的缩进。)</p>
<p><img src="/./../imgs/image-20241104194734905.png" alt="image-20241104194734905"></p>
<p>（见test04.py）</p>
<h2 id="3-if……else语句"><a href="#3-if……else语句" class="headerlink" title="3.if……else语句"></a>3.if……else语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    do1</span><br><span class="line">    do2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    do3</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241104200017292.png" alt="image-20241104200017292"></p>
<p>(见test05.py)</p>
<h2 id="4-if……elif……else语句"><a href="#4-if……elif……else语句" class="headerlink" title="4.if……elif……else语句"></a>4.if……elif……else语句</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1：</span><br><span class="line">	do1</span><br><span class="line"><span class="keyword">elif</span> condition2：</span><br><span class="line">	do2</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">	do3</span><br></pre></td></tr></table></figure>

<p>![屏幕截图 2024-11-04 201953](C:\Users\zhouyue\Pictures\Screenshots\屏幕截图 2024-11-04 201953.png)</p>
<p>（见test06.py）</p>
<h2 id="5-判断语句的嵌套"><a href="#5-判断语句的嵌套" class="headerlink" title="5.判断语句的嵌套"></a>5.判断语句的嵌套</h2><p>思想和C相同的，略</p>
<h2 id="6-实操案例"><a href="#6-实操案例" class="headerlink" title="6.实操案例"></a>6.实操案例</h2><p><img src="/./../imgs/image-20241104203624249.png" alt="image-20241104203624249"></p>
<p>（见test07.py）</p>
<h1 id="三-Python循环语句"><a href="#三-Python循环语句" class="headerlink" title="三.Python循环语句"></a>三.Python循环语句</h1><h2 id="1-while基础语法"><a href="#1-while基础语法" class="headerlink" title="1.while基础语法"></a>1.while基础语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    do1</span><br><span class="line">    do2</span><br><span class="line">    do3</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>

<p>（与C几乎一样，唯一需要注意的就是字符缩进）</p>
<p>![屏幕截图 2024-11-04 205556](C:\Users\zhouyue\Pictures\Screenshots\屏幕截图 2024-11-04 205556.png)</p>
<p>（见test08.py）</p>
<h2 id="2-while基础案例"><a href="#2-while基础案例" class="headerlink" title="2.while基础案例"></a>2.while基础案例</h2><p><img src="/./../imgs/image-20241104210331358.png" alt="image-20241104210331358"></p>
<p>（见test09.py）</p>
<h2 id="3-while嵌套循环"><a href="#3-while嵌套循环" class="headerlink" title="3.while嵌套循环"></a>3.while嵌套循环</h2><p>同C，唯一要注意的是，多个循环嵌套及条件分支时，没有了{}的明显区分，需要格外注意缩进来正确分块。</p>
<h2 id="4-while嵌套循环实操"><a href="#4-while嵌套循环实操" class="headerlink" title="4.while嵌套循环实操"></a>4.while嵌套循环实操</h2><p>补充：print输出不换行的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dfshjfs0&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sdjgsgsd&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241104212220936.png" alt="image-20241104212220936">（见test10.py)</p>
<h2 id="5-for循环基础语法"><a href="#5-for循环基础语法" class="headerlink" title="5.for循环基础语法"></a>5.for循环基础语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 数据集:</span><br><span class="line">    do</span><br></pre></td></tr></table></figure>

<p>(<strong>需要格外注意地是，Python中的for循环与C中的for循环的不同，C中的for循环可以等价写成while循环，但Python中无法定义循环条件</strong>)</p>
<p>理论上将Python中的for循环无法构建无限循环，因为不可能存在一个数据集中的元素个数无限。</p>
<p>临时变量x不一定要打印，也可以仅仅将其当作计数器使用。</p>
<p><img src="/./../imgs/image-20241105125840899.png" alt="image-20241105125840899"></p>
<p>（见test11.py）</p>
<h2 id="6-range语句"><a href="#6-range语句" class="headerlink" title="6.range语句"></a>6.range语句</h2><p>​	for循环语法中的带处理数据集事实上应该叫做“序列”，是一种特殊的类型。</p>
<p>​	序列类型是指，其中的内容可以一个个依次取出的一种类型，包括：</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>……</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(num)	</span><br><span class="line">	<span class="comment">#获取一个从0开始到num(不含num)的数字序列</span></span><br><span class="line"><span class="built_in">range</span>(num1, num2)</span><br><span class="line">	<span class="comment">#获取一个从num1开始到num2(不含num2)的数字序列</span></span><br><span class="line"><span class="built_in">range</span>(num1, num2, step)</span><br><span class="line">	<span class="comment">#获取一个从num1开始到num2(不含num2)的数字序列</span></span><br><span class="line">    <span class="comment">#数字间的步长以step为准(step默认为1)</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241105131141873.png" alt="image-20241105131141873"></p>
<p>（见test12.py）</p>
<h2 id="7-变量作用域"><a href="#7-变量作用域" class="headerlink" title="7.*变量作用域"></a>7.*变量作用域</h2><ul>
<li><p>同C</p>
</li>
<li><p>虽然在Python中可以尝试访问一个异域的变量，但是保不齐会出问题，尤其是在写大项目时。</p>
</li>
<li><p>如果真的想访问，可以先在大的域中定义一个变量名相同的变量，在for循环中对临时变量进行覆盖</p>
</li>
</ul>
<h2 id="8-for循环的嵌套循环"><a href="#8-for循环的嵌套循环" class="headerlink" title="8.for循环的嵌套循环"></a>8.for循环的嵌套循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range1:</span><br><span class="line">    do</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range2:</span><br><span class="line">        do</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">for</span> ……：</span><br><span class="line">	do</span><br><span class="line">    <span class="keyword">while</span> ……：</span><br><span class="line">    	do</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241105132606549.png" alt="image-20241105132606549"></p>
<p>(见test13.py)</p>
<h2 id="9-循环中断"><a href="#9-循环中断" class="headerlink" title="9.循环中断"></a>9.循环中断</h2><ul>
<li>continue：中断本次循环，<strong>直接</strong>进入下一次循环。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>:</span><br><span class="line">    do1</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    do2</span><br><span class="line">	<span class="comment">#上述代码不会执行do2</span></span><br></pre></td></tr></table></figure>

<p>（continue能且<strong>仅</strong>能中断离他<strong>最近</strong>的循环）</p>
<ul>
<li>break：直接结束循环</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>:</span><br><span class="line">    do1</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    do2</span><br><span class="line">do3</span><br><span class="line">	<span class="comment">#上述代码直接结束循环，do1后直接do3，不再进入循环</span></span><br></pre></td></tr></table></figure>

<p>（同样地，break也仅能跳过离他最近的循环）</p>
<h2 id="10-综合案例"><a href="#10-综合案例" class="headerlink" title="10.综合案例"></a>10.综合案例</h2><p><img src="/./../imgs/image-20241105134205905.png" alt="image-20241105134205905"></p>
<p>（见test14.py）</p>
<h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四.函数"></a>四.函数</h1><p>​	函数，是<strong>组织好</strong>的，<strong>可重复使用</strong>的，用来实现特定功能的代码段。同样的，Python除了自身有庞大的函数库外，也支持自己定义函数。</p>
<h2 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1.函数的定义"></a>1.函数的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">parameter1, parameter2, ……</span>):</span><br><span class="line">    function_struct</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>调用：function_name(parameter1, parameter2, ……)即可。</p>
<h2 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2.*函数的参数"></a>2.*函数的参数</h2><p>​	与C基本相同，唯一要注意的是在一些情况下，对函数的形参进行修改是会导致实参的改变的。</p>
<p><img src="/./../imgs/image-20241105152009847.png" alt="image-20241105152009847"></p>
<p>（见test15.py）</p>
<h2 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3.函数的返回值"></a>3.函数的返回值</h2><p>​	 与C基本相同，唯一要注意的是，无论有没有人为定义一个返回值，最终函数都会产生返回值，当没有人为定义的返回值时，此时返回值是“None”</p>
<p>​	<strong>None</strong>在Python中是一种类型’NoneType’，代表“无，空的，无意义”。</p>
<p>None的实际应用：</p>
<ul>
<li>无函数返回值</li>
<li>if条件判断：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">if</span> age &gt; <span class="number">18</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sucess&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">result = check_age(age)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Forbid child to enter there!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>声明无内容的变量：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line"><span class="comment">#仅声明，不赋值</span></span><br></pre></td></tr></table></figure>

<h2 id="4-函数的嵌套"><a href="#4-函数的嵌套" class="headerlink" title="4.函数的嵌套"></a>4.函数的嵌套</h2><p>​	在一个函数的里面再调用函数。</p>
<h2 id="5-变量的作用域"><a href="#5-变量的作用域" class="headerlink" title="5.*变量的作用域"></a>5.*变量的作用域</h2><ul>
<li><p>变量分为两类：局部变量，全局变量。</p>
</li>
<li><p>局部变量是指在函数内部定义的变量，它的作用域和生存周期和函数相同，也就意味着无法在函数外对其进行访问。</p>
</li>
<li><p>全局变量，至少对于Python来说，是指定义在函数外的变量。作用域和生存周期和程序相同。</p>
</li>
<li><p>如何在使在函数内定义的局部变量的值能“映射”到函数外的相同变量名的变量？</p>
</li>
</ul>
<p>​	1.golobal关键字</p>
<p>​		可以理解为强制将变量类型转化为全局变量。</p>
<p>​	2.引用特殊类型对象的<a href="##2.**%E5%8F%98%E9%87%8F">变量</a></p>
<p>​		修改一个<strong>可变对象</strong>（如列表、字典等）作为函数的形参时，会改变	实参的值。</p>
<h2 id="6-综合案例"><a href="#6-综合案例" class="headerlink" title="6.综合案例"></a>6.综合案例</h2><p><img src="/./../imgs/image-20241105193025908.png" alt="image-20241105193025908"></p>
<p>（见test16.py）</p>
<h1 id="五-Python数据容器"><a href="#五-Python数据容器" class="headerlink" title="五.Python数据容器"></a>五.Python数据容器</h1><h1 id="1-数据容器入门"><a href="#1-数据容器入门" class="headerlink" title="1.数据容器入门"></a>1.数据容器入门</h1><p>​	一种可以容纳多份数据的<strong>数据类型</strong>，容纳的每一份数据称为一个元素，<strong>每一个</strong>元素可以是<strong>任意类型</strong>的数据，如字符串，bool……（类似于C中的结构体）。</p>
<p>数据容器根据某些特征可以分为5类：</p>
<ul>
<li>是否支持重复元素</li>
<li>是否可以修改</li>
<li>是否有序</li>
</ul>
<p>列表（list），元组（tuple），字符串（str），集合（set），字典（dict）</p>
<h2 id="2-数据容器：list（列表）"><a href="#2-数据容器：list（列表）" class="headerlink" title="2.数据容器：list（列表）"></a>2.数据容器：list（列表）</h2><h3 id="1-list（列表）的定义"><a href="#1-list（列表）的定义" class="headerlink" title="1.list（列表）的定义"></a>1.list（列表）的定义</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字面量列表</span></span><br><span class="line">[element1,element2,……]</span><br><span class="line"><span class="comment">#变量列表</span></span><br><span class="line">variable_name = [element1,element2,……]</span><br><span class="line"><span class="comment">#空列表：</span></span><br><span class="line">variable_name = []</span><br><span class="line">variable_name = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure>

<p>注意：列表可以一次性存储多个数据，且可以为<strong>不同</strong>的数据类型</p>
<h3 id="2-list（列表）的索引"><a href="#2-list（列表）的索引" class="headerlink" title="2.list（列表）的索引"></a>2.list（列表）的索引</h3><p>​	类似于数组，不同的是，这里的元素下标可以从后往前定义，eg：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [element1,element2,elemrnt3]</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>] = element1</span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>] = elemrnt2</span><br><span class="line"><span class="built_in">list</span>[<span class="number">3</span>] = element3</span><br><span class="line">also</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] = element3</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">2</span>] = element2</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">3</span>] = element1</span><br></pre></td></tr></table></figure>

<p>对于list的嵌套，可以像二维数组一样进行下标索引。</p>
<h3 id="3-list（列表）的方法与特点"><a href="#3-list（列表）的方法与特点" class="headerlink" title="3.*list（列表）的方法与特点"></a>3.*list（列表）的方法与特点</h3><h4 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h4><p>​	本质上就是函数，只不过当函数被定义为在<a href="">class</a>（类）的成员，那么此时的函数就称之为方法。</p>
<pre><code> 函数和方法的参数，返回值，定义方式都一样，唯一值得注意的是，当我们调用一个class中的方法时与调用函数不太一样，eg：
</code></pre>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class_name</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">param</span>):</span><br><span class="line">        do</span><br><span class="line"><span class="comment">#调用方法</span></span><br><span class="line">variable = Class_name.method(param)</span><br></pre></td></tr></table></figure>

<pre><code> 那么对于列表（list）来说，它是由Python内置的list类实现的。也就是说，列表是一个list类的实例。
</code></pre>
<h4 id="2-list列表的常用操作"><a href="#2-list列表的常用操作" class="headerlink" title="2.list列表的常用操作"></a>2.list列表的常用操作</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义列表</span></span><br><span class="line">mylist = [elem1, elem2, elem3]</span><br></pre></td></tr></table></figure>

<ul>
<li>查找某元素在列表的下标索引</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.index(elem)</span></span><br><span class="line">number = mylist.index(elem1)</span><br><span class="line"><span class="built_in">print</span>(number)	<span class="comment">#结果输出elem1的下标</span></span><br><span class="line"><span class="built_in">print</span>(mylist.index(elem))</span><br><span class="line"><span class="comment">#结果为：ValueError</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改特定下标索引值</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#本质就是赋值操作</span></span><br><span class="line">mylist[<span class="number">0</span>] = element</span><br></pre></td></tr></table></figure>

<ul>
<li>插入元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.insert(index, elem)</span></span><br><span class="line">mylist.insert(<span class="number">1</span>, elem)</span><br><span class="line"><span class="comment">#结果：[elem1, elem, elem2, elem3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>追加元素</li>
</ul>
<ol>
<li>单个追加</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.append(elem)</span></span><br><span class="line">mylist.append(elem)</span><br><span class="line"><span class="comment">#结果：[elem1, elem2, elem3, elem]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>批量追加</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.extend(another data container)</span></span><br><span class="line">mylist.extend([elem4, elem5, elem6])</span><br><span class="line"><span class="comment">#结果：mylist = [elem1,elem2,elem3,elem4,elem5,elem6]</span></span><br></pre></td></tr></table></figure>

<p>​	注意：list.extend()接受任何可迭代对象（iterable），也就是说，这里的其他数据容器不仅仅指list。</p>
<ul>
<li>删除指定下标索引的元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法1：del list[index]</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">2</span>]</span><br><span class="line"><span class="comment">#结果为：mylist = [elem1,elem2]</span></span><br><span class="line">或者</span><br><span class="line"><span class="comment">#语法2：list.pop(index)</span></span><br><span class="line">name = mylist.pop(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#结果为：mylist = [elem1,elem2]</span></span><br></pre></td></tr></table></figure>

<p>​	注意：list.pop(index)方法有返回值，本质上它是将下标为index的值“取出”作为返回值，同时，list里下标为 index的值被删除。</p>
<ul>
<li>删除指定元素在list中从前向后数的第一个匹配项</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.remove(elem)</span></span><br><span class="line"><span class="built_in">list</span>.remove(elem1)</span><br><span class="line"><span class="comment">#结果为：mylist = [elem2,elem3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>清空列表内容</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.clear()</span></span><br><span class="line">mylist.clear()</span><br><span class="line"><span class="comment">#结果：mylist = []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计某元素在列表中的数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：list.count(elem)</span></span><br><span class="line"><span class="built_in">print</span>(mylist.conut(elem1))</span><br><span class="line"><span class="comment">#结果为：1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计列表中全部元素的数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：len(list)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mylist))</span><br><span class="line"><span class="comment">#结果为3</span></span><br></pre></td></tr></table></figure>

<p>​	注意：这里的len不是方法，是函数。</p>
<p>![ ](C:\Users\zhouyue\Pictures\Screenshots\屏幕截图 2024-11-06 134119.png)（见test17.py)</p>
<h2 id="3-列表的遍历"><a href="#3-列表的遍历" class="headerlink" title="3.列表的遍历"></a>3.列表的遍历</h2><p>​	对一个数据结构中的每一个元素进行访问和操作称之为遍历或迭代</p>
<p>​	尽管同样是对数据结构每一个元素的访问，但是遍历强调的是访问数据结构中每一个元素的<strong>过程</strong>，而迭代则更强调实现这个过程的<strong>代码段的重复</strong>过程，因此我们可以说遍历<strong>通常</strong>可以通过迭代实现。</p>
<p><img src="/./../imgs/image-20241106150243092.png" alt="image-20241106150243092"></p>
<p>（见test18.py）</p>
<h2 id="4-数据容器：元组（tuple）"><a href="#4-数据容器：元组（tuple）" class="headerlink" title="4.数据容器：元组（tuple）"></a>4.数据容器：元组（tuple）</h2><h3 id="1-元组（tuple）的定义"><a href="#1-元组（tuple）的定义" class="headerlink" title="1.元组（tuple）的定义"></a>1.元组（tuple）的定义</h3><p>​	元组同列表一样可以封装多个，不同类型的元素在内。但是它们最大的不同点在于元组一旦定义完成就<strong>无法修改</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义元组字面量</span></span><br><span class="line">(elem1,elem2,elem3)</span><br><span class="line"><span class="comment">#定义元组变量</span></span><br><span class="line">variable_name = (elem1,elem2,elem3)</span><br><span class="line"><span class="comment">#定义空元组</span></span><br><span class="line">variable_name = ()</span><br><span class="line">或者</span><br><span class="line">variable_name = <span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure>

<p>​	需要强调的是，当定义元组时，元组元素只有一个时，元素后须接逗号。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name = (elem,)</span><br></pre></td></tr></table></figure>

<h3 id="2-元组（tuple）的下标索引"><a href="#2-元组（tuple）的下标索引" class="headerlink" title="2.元组（tuple）的下标索引"></a>2.元组（tuple）的下标索引</h3><p>​	与列表相同，不过多赘述。</p>
<p>​	但是值得注意的是，在 Python 中，无论是列表、元组还是字符串，都使用方括号 <code>[]</code> 来索引或切片。这是一个通用的规则，适用于所有序列类型的数据。</p>
<h3 id="3-元组（tuple）的常用操作"><a href="#3-元组（tuple）的常用操作" class="headerlink" title="3.元组（tuple）的常用操作"></a>3.元组（tuple）的常用操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义列表</span></span><br><span class="line">mytuple = [elem1, elem2, elem3]</span><br></pre></td></tr></table></figure>

<ul>
<li>查找某个元素的下标</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：tuple.index(elem)</span></span><br><span class="line">number = mytuple.index(elem1)</span><br><span class="line"><span class="built_in">print</span>(number)	<span class="comment">#结果输出elem1的下标</span></span><br><span class="line"><span class="built_in">print</span>(mytuple.index(elem))</span><br><span class="line"><span class="comment">#结果为：ValueError</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计某元素在元组中的数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：tuple.count(elem)</span></span><br><span class="line"><span class="built_in">print</span>(mytuple.conut(elem1))</span><br><span class="line"><span class="comment">#结果为：1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计元组内元素个数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：len(tuple)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mytuple))</span><br><span class="line"><span class="comment">#结果为3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-元组的读写性"><a href="#4-元组的读写性" class="headerlink" title="4.元组的读写性"></a>4.元组的读写性</h3><p>​	元组本身没有写的权限，但是元组中嵌套的可变数据结构中的元素是可以修改的。</p>
<p><img src="/./../imgs/image-20241106154915684.png" alt="image-20241106154915684"></p>
<p>（见test19.py）</p>
<h2 id="5-数据容器：字符串（str）"><a href="#5-数据容器：字符串（str）" class="headerlink" title="5.数据容器：字符串（str）"></a>5.数据容器：字符串（str）</h2><h3 id="1-字符串的定义"><a href="#1-字符串的定义" class="headerlink" title="1.字符串的定义"></a>1.字符串的定义</h3><p>​	字符串是只含有字符类型的数据容器，它与元组一样不可修改。</p>
<h3 id="2-字符串的常用操作"><a href="#2-字符串的常用操作" class="headerlink" title="2.字符串的常用操作"></a>2.字符串的常用操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义字符串</span></span><br><span class="line">mystr = <span class="string">&quot;fsudygfusgf&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查询元素下标</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.index(elem)</span></span><br><span class="line"><span class="built_in">print</span>(mystr.index(<span class="string">&#x27;f&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的替换</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.replace(str1,str2)</span></span><br><span class="line"><span class="built_in">print</span>(mystr.replace(<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为&quot;fsudygfusgf&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr)</span><br><span class="line"><span class="comment">#结果为&quot;asudygfusgf&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：这里并不是将mystr中的值给覆盖了再输出mystr，而是相当于一个返回值。</p>
<ul>
<li>字符串的分割</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.split(分隔符字符串)</span></span><br><span class="line">mystr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="comment">#结果为：[&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>正如上面的结果所示，mystr.split()也不是对mystr进行分割，而是根据分割字符串将分割的结果以列表的形式返回。</p>
<ul>
<li>字符串的规整操作</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#去前后空格</span></span><br><span class="line">mtstr = <span class="string">&quot;   hello world   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.strip())</span><br><span class="line"><span class="comment">#结果为：&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去前后指定字符串</span></span><br><span class="line">mystr = <span class="string">&quot;12hello world21&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.strip(<span class="string">&quot;12&quot;</span>))</span><br><span class="line"><span class="comment">#结果为：&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>同样的，mystr.strip也不会更改mystr的值，也是将新字符串作为返回值返回。</p>
<ul>
<li>统计某字符串出现的次数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：str.count(string)</span></span><br><span class="line">mystr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mystr.count(<span class="string">&quot;l&quot;</span>))</span><br><span class="line"><span class="comment">#结果为：3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计字符串长度</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mystr))</span><br><span class="line"><span class="comment">#结果为：11</span></span><br></pre></td></tr></table></figure>

<p>值得<strong>特别</strong>注意的是，Python中的字符串并不以’\0’结尾。</p>
<p><img src="/./../imgs/image-20241106173427119.png" alt="image-20241106173427119"></p>
<p>（见test20.py）</p>
<h2 id="6-数据容器（序列）的切片"><a href="#6-数据容器（序列）的切片" class="headerlink" title="6.数据容器（序列）的切片"></a>6.数据容器（序列）的切片</h2><ul>
<li><p>序列：内容连续，有序，可使用下标索引的一类数据容器。元组，列表，字符串都是序列的一种。</p>
</li>
<li><p>序列的切片：从一个序列中取出一个子序列</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：sequence[start_subscript:end_subscript:step]</span></span><br><span class="line"><span class="comment">#表示从序列中，指定位置开始，依次取出元素，到指定位置结束，得到一个新序列</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>起始下标表示从何处开始</p>
</li>
<li><p>结束下标（不含）表示何处结束，可以留空，留空视作取到结尾</p>
</li>
<li><p>步长表示依次取元素的间隔</p>
</li>
<li><p>步长n表示，每次跳过n-1个元素取</p>
</li>
<li><p>当n&lt;0时，表示反向取（此时，起始下标和结束下标也要反向标记 ）</p>
</li>
<li><p>步长为n(n&lt;0),每次反向跳过n-1个元素取</p>
</li>
<li><p>切片操作并不会更改原有序列，而是会产生新的序列</p>
</li>
</ul>
<p><img src="/./../imgs/image-20241106200121706.png" alt="image-20241106200121706"></p>
<p>(见test21.py)</p>
<h2 id="7-数据容器：集合（set）"><a href="#7-数据容器：集合（set）" class="headerlink" title="7.数据容器：集合（set）"></a>7.数据容器：集合（set）</h2><h3 id="1-集合的定义"><a href="#1-集合的定义" class="headerlink" title="1.集合的定义"></a>1.集合的定义</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义集合字面量</span></span><br><span class="line">&#123;elem1,elem2,elem3&#125;</span><br><span class="line"><span class="comment">#定义集合变量</span></span><br><span class="line">set_name = &#123;elem1,elem2,elem3&#125;</span><br><span class="line"><span class="comment">#定义空集合</span></span><br><span class="line">set_name = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>之所以这里只能使用set()而不是set{}的原因是，set是python的内置函数，用于创建集合对象,eg:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">myset = <span class="built_in">set</span>(mylist)</span><br><span class="line"><span class="comment">#myset = &#123;1,2,3,4&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以通过set函数创建空集合或者从其他可迭代数据结构中获取元素来创建集合。</p>
<h3 id="2-集合的常用操作"><a href="#2-集合的常用操作" class="headerlink" title="2.集合的常用操作"></a>2.集合的常用操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个集合</span></span><br><span class="line">myset = &#123;elem1, elem2, elem3&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加新元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.add(elem)</span></span><br><span class="line">myset.add(elem)</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果：myset = &#123;elem1,elem2,elem3,elem&#125;</span></span><br><span class="line">myset.add(elem1)</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果为：myset = &#123;elem1, elem2, elem3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：set集合不支持重复元素。</p>
<ul>
<li>移除元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.remove(elem)</span></span><br><span class="line">myset.remove(elem1)</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果：myset = &#123;elem2, elem3&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>随机取出一个元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.pop()</span></span><br><span class="line">myset.pop()</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment">#结果：不定，因为集合没有下标，所以pop会随机取出一个元素，并把这个元素作为返回值返回</span></span><br></pre></td></tr></table></figure>

<ul>
<li>清空集合</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set.clear()</span></span><br><span class="line">myset.clear()</span><br><span class="line"><span class="built_in">print</span>(myset)</span><br><span class="line"><span class="comment">#结果：set()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>取两个集合的差值</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set1.difference(set2)</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span><br><span class="line">set3 = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"><span class="comment">#结果：set3 = &#123;2，3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：difference方法会创建一个新的集合作为返回值返回，而不是修改set1或set2。并且，新集合的元素是set1有而set2没有的元素。</p>
<ul>
<li>消除两个集合的差值</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set1.difference_updata(set2)</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span><br><span class="line">set1.difference_updata(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)		<span class="comment">#结果为：&#123;2，3&#125;</span></span><br><span class="line"><span class="built_in">print</span>(set2)		<span class="comment">#结果为：&#123;1，4&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：difference_updata方法直接在set1上修改，删除set1中与set2中相同的元素，而不修改set2。</p>
<ul>
<li>合并两个集合</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：set1.union(set2)</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)		<span class="comment">#&#123;1,2,3,4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(set2)		<span class="comment">#&#123;1,4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(set1)		<span class="comment">#&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：union方法不会修改set1和set2的值，而是合并集合后创建一个新的集合，并将新集合作为返回值返回。</p>
<ul>
<li>统计元素个数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>集合的遍历</li>
</ul>
<p>​	不支持while循环，因为没有下标。但是支持for循环。</p>
<p><img src="/./../imgs/image-20241106210245574.png" alt="image-20241106210245574"></p>
<p>（见test22.py）</p>
<h2 id="8-数据容器：dict-字典"><a href="#8-数据容器：dict-字典" class="headerlink" title="8.数据容器：dict(字典)"></a>8.数据容器：dict(字典)</h2><h3 id="1-dict-字典-的定义"><a href="#1-dict-字典-的定义" class="headerlink" title="1.dict(字典)的定义"></a>1.dict(字典)的定义</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义字典字面量</span></span><br><span class="line">&#123;key1:value1,key2:value2,key3:value3&#125;</span><br><span class="line"><span class="comment">#定义字典变量</span></span><br><span class="line">mydict = &#123;key1:value1,key2:value2,key3:value3&#125;</span><br><span class="line"><span class="comment">#定义空字典</span></span><br><span class="line">mydict = &#123;&#125;</span><br><span class="line">或</span><br><span class="line">mydict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>键值对，像key:value这样可以将关键信息与值匹配起来称为一个元素的称之为键值对。</p>
</li>
<li><p>重复定义字典：</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;key1:value1,key1:value2,key3:value3&#125;</span><br><span class="line"><span class="built_in">print</span>(mydict)</span><br><span class="line"><span class="comment">#结果：mydict = &#123;key1:value2,key3:value3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：重复定义字典（即key值相同），后定义的键值对会将先定义的键值对</p>
<p>覆盖。</p>
<ul>
<li>字典数据的获取</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;key1:value1,key1:value2,key3:value3&#125;</span><br><span class="line"><span class="built_in">print</span>(mydict[key1])</span><br><span class="line"><span class="built_in">print</span>(mydict[key2])</span><br><span class="line"><span class="built_in">print</span>(mydict[key3])</span><br></pre></td></tr></table></figure>

<p>注:字典没有下标，但是可以通过key取到value。</p>
<ul>
<li><p>嵌套字典<br>  字典的key和value类型不受限制（key不能为字典），这就意味着字典可以嵌套。</p>
</li>
<li><p>嵌套字典的索引</p>
</li>
</ul>
<p>​	类似二维数组的索引</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>[key_surface][key_inner]</span><br></pre></td></tr></table></figure>



<h3 id="2-字典的常用操作"><a href="#2-字典的常用操作" class="headerlink" title="2.字典的常用操作"></a>2.字典的常用操作</h3><ul>
<li>新增元素和更改元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在字典中我们可以对键值对中的value进行修改，eg:</span></span><br><span class="line"><span class="built_in">dict</span>[key] = value_new</span><br><span class="line"><span class="comment">#当key不存在时就是新增了一个键值对</span></span><br><span class="line"><span class="comment">#当key存在时就是对键值对key:value的value进行了修改，相当于更新元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：dict.pop(key)</span></span><br><span class="line">mydict = &#123;key1:value1,key2:value2,key3:value3&#125;</span><br><span class="line"><span class="built_in">print</span>(mydict.pop(key1))</span><br><span class="line"><span class="comment">#结果为：value2</span></span><br><span class="line"><span class="built_in">print</span>(mydict)</span><br><span class="line"><span class="comment">#结果为：mydict = &#123;key1:value2,key3:value3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：pop（key）方法可以取到键值对key:value的value，并且将该键值对从字典中删除。</p>
<ul>
<li>清除字典</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：dict.clear()</span></span><br><span class="line">mydict.clear()</span><br><span class="line"><span class="comment">#结果为：&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取全部key和遍历字典</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：dict.keys()</span></span><br><span class="line">keys= = mydict.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br><span class="line"><span class="comment">#结果：mydict = &#123;key1,key2,key3&#125;</span></span><br></pre></td></tr></table></figure>

<p>获取key之后就可以进行遍历了</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> mydict:</span><br></pre></td></tr></table></figure>

<p>注：上述两者的key值是完全等价的</p>
<ul>
<li>统计字典中的元素数量</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(mydict)</span><br></pre></td></tr></table></figure>

<p><img src="/./../imgs/image-20241106220318867.png" alt="image-20241106220318867"></p>
<p>(见test23.py)</p>
<h2 id="9-数据容器总结"><a href="#9-数据容器总结" class="headerlink" title="9.数据容器总结"></a>9.数据容器总结</h2><ul>
<li><p>是否支持下标索引：</p>
<ul>
<li>支持：列表，元组，字符串—序列类型</li>
<li>不支持：集合，字典—非序列类型</li>
</ul>
</li>
<li><p>是否支持重复元素：</p>
<ul>
<li>支持：列表，元组，字符串—序列类型</li>
<li>不支持：集合，字典—非序列类型</li>
</ul>
</li>
<li><p>是否可以修改：</p>
<ul>
<li>支持：列表，集合，字典</li>
<li>元组，字符串</li>
</ul>
</li>
</ul>
<p><img src="/./../imgs/image-20241106221513743.png" alt="image-20241106221513743"></p>
<h2 id="10-数据容器的通用操作"><a href="#10-数据容器的通用操作" class="headerlink" title="10.数据容器的通用操作"></a>10.数据容器的通用操作</h2><ul>
<li><p>都支持遍历操作</p>
<ul>
<li>序列支持while</li>
<li>非序列不支持while</li>
</ul>
</li>
<li><p>通用方法：</p>
<ul>
<li>len()    （计算元素个数）</li>
<li>max()    (取最大元素)</li>
<li>min()    (取最小元素)</li>
<li>字符串也支持ASCII码</li>
</ul>
</li>
<li><p>强制转换：</p>
<ul>
<li>list(data_container)</li>
<li>str(data_container)</li>
<li>tuple(data_container)</li>
<li>set(data_container)</li>
</ul>
</li>
<li><p>通用排序函数：</p>
<p>sorted(data_container, [reverse&#x3D;True])</p>
<p>[reverse]默认是False，如果想让排序反转，[reverse&#x3D;Ture]</p>
</li>
</ul>
<h1 id="六-函数进阶"><a href="#六-函数进阶" class="headerlink" title="六.函数进阶"></a>六.函数进阶</h1><ul>
<li>函数的多返回值：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">param</span>):</span><br><span class="line">    <span class="keyword">return</span> ret1, ret2</span><br><span class="line">a, b = function</span><br><span class="line"><span class="built_in">print</span>(a)	<span class="comment">#ret1</span></span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#ret2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数的多种传参方式：</li>
</ul>
<ol>
<li><p><strong>位置参数</strong>：</p>
<ul>
<li>通过位置传递参数，参数的值根据其位置来匹配。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">result = func(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># a=1, b=2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关键字参数</strong>：</p>
<ul>
<li>使用关键字（参数名）传递参数，可以不按顺序传递。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = func(b=<span class="number">2</span>, a=<span class="number">1</span>)  <span class="comment"># a=1, b=2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>默认参数</strong>：</p>
<ul>
<li>在定义函数时为参数设置默认值，如果调用时不传递该参数，则使用默认值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">result1 = func(<span class="number">1</span>)    <span class="comment"># b使用默认值2</span></span><br><span class="line">result2 = func(<span class="number">1</span>, <span class="number">3</span>) <span class="comment"># b=3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>可变位置参数（*args）</strong>：</p>
<ul>
<li>使用星号（<code>*</code>）可以接收任意数量的位置参数，这些参数会被存储在一个元组中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line">result = func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># args=(1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>可变关键字参数（</strong>kwargs）**：</p>
<ul>
<li>使用双星号（<code>**</code>）可以接收任意数量的关键字参数，这些参数会被存储在一个字典中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> kwargs</span><br><span class="line"></span><br><span class="line">result = func(a=<span class="number">1</span>, b=<span class="number">2</span>)  <span class="comment"># kwargs=&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>命名关键字参数</strong>：</p>
<ul>
<li>在函数定义中可以限制关键字参数的名称，使用<code>*</code>来分隔位置参数与命名关键字参数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *, c, d</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d</span><br><span class="line"></span><br><span class="line">result = func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)  <span class="comment"># c=3, d=4</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>参数类型提示</strong>：</p>
<ul>
<li>使用类型提示来指明参数的预期类型，增加代码的可读性和可维护性。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些方法各自有其使用场景，可以根据需要选择适合的传参方式。</p>
<ul>
<li>**匿名函数<ul>
<li>def 可以定义一个带<strong>有名称</strong>的函数，lambda可以定义一个<strong>匿名</strong>函数</li>
<li>有名称的函数可以基于名称重复调用，匿名函数仅作临时使用</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义语法</span></span><br><span class="line"><span class="keyword">lambda</span> (parameter1,……):function_struct</span><br><span class="line"><span class="comment">#值得注意的是，函数体中仅能写一行代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实操</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">com</span>):</span><br><span class="line">    ret = com(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="built_in">print</span>(test_func(<span class="keyword">lambda</span> x,y: x*y))</span><br><span class="line"><span class="comment">#结果为：2</span></span><br><span class="line"><span class="comment">#等价于：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">add</span>):</span><br><span class="line">    ret = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="built_in">print</span>(test_func(add))</span><br></pre></td></tr></table></figure>

<h1 id="七-Pyhton文件操作"><a href="#七-Pyhton文件操作" class="headerlink" title="七.Pyhton文件操作"></a>七.Pyhton文件操作</h1><h2 id="1-文件编码"><a href="#1-文件编码" class="headerlink" title="1.文件编码"></a>1.文件编码</h2><p>​	编码技术：翻译的规则，记录了如何将内容翻译为二进制机器语言，以及如何将二进制文本转换为可识别内容。</p>
<p>​	但是编码的规则多种多样，但是现在一般都使用UTF-8编码规则。 </p>
<h2 id="2-文件的读取"><a href="#2-文件的读取" class="headerlink" title="2.文件的读取"></a>2.文件的读取</h2><ul>
<li>文件操作的作用</li>
</ul>
<p>​	内存中存放的数据在计算机关机后就会被重置，也就是说要长久地保存文件就得使用硬盘，光盘，U盘等设备。</p>
<p>​	但是很显然地，如果仅仅是这样，对于保存数据地再访问是麻烦的事。于是，引入“<strong>文件</strong>”的概念，方便数据的管理与检索。</p>
<p>​	一般来说，一段音频，一段视频，一个可执行程序都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中存储的数据。</p>
<p>​	文件一般可以分为文本文件，视频文件，音频文件，图像文件，可执行文件等多种类别。</p>
<p>​	在日常生活中，文件的操作主要包括打开，关闭，读，写等操作。</p>
<ul>
<li><p>文件的读取</p>
<ul>
<li>open()打开函数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：open(name,mode,encoding)</span></span><br><span class="line"><span class="comment">#name:是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。</span></span><br><span class="line"><span class="comment">#mode:设置打开文件的模式(访问模式):只读、写入、追加等。</span></span><br><span class="line"><span class="comment">#encoding:编码格式(推荐使用UTF-8)</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot; UTF-8)</span></span><br><span class="line"><span class="string">#encoding的顺序不是第三位,所以不能用位置参数,用关键字参数直接指定</span></span><br></pre></td></tr></table></figure>

<p>注意：此时的’f’不是变量，而是open函数的文件对象。</p>
<p>mode常用的三种基础访问模式：</p>
<p><img src="/./../imgs/image-20241107171613416.png" alt="image-20241107171613416"></p>
<ul>
<li><p>读操作相关方法</p>
<p>当open了一个文件对象’f’后，这个文件对象中会内置很多方法</p>
<ul>
<li>read()方法</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.read(num)</span><br><span class="line"><span class="comment">#num表示要从文件中读取的数据长度（以字节为单位），如果没有传入num，那么就代表读取文件中的所有数据。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>readlines()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.readlines()</span><br><span class="line"><span class="comment">#readlines()方法按照的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>readline()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.readline()</span><br><span class="line"><span class="comment">#readline方法每次只读取一行数据，返回内容是字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>for循环读取文件行</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(file_name)</span><br><span class="line">	<span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment">#每一个line临时变量就记录文件的一行数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>close()方法关闭文件对象</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(file_name)</span><br><span class="line">f.close</span><br><span class="line"><span class="comment">#通过close关闭文件对象，也就是关闭对文件的占用</span></span><br><span class="line"><span class="comment">#如果不调用close，且程序一直运行，则该文件将一直被Python占用。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>with open函数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name,mode) <span class="keyword">as</span> f:</span><br><span class="line">    f.method()</span><br><span class="line"><span class="comment">#该函数可以在操作完毕后自动关闭文件，以防忘记使用close。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="/./../imgs/image-20241107173333618.png" alt="image-20241107173333618"></p>
<p>（见test24.py）</p>
<h2 id="3-文件的写入"><a href="#3-文件的写入" class="headerlink" title="3.文件的写入"></a>3.文件的写入</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(file_name,<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>write()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.write(写入的内容)</span><br><span class="line"><span class="comment">#仅仅write方法还并不能将内容写入文件，而是会积攒在程序的内存中，称之为缓冲区。</span></span><br><span class="line"><span class="comment">#这是为了避免频繁操作硬盘，导致效率下降</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flush（）方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.flush()</span><br><span class="line"><span class="comment">#内容刷新，将缓冲区内的数据刷新至文件。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文件的追加"><a href="#4-文件的追加" class="headerlink" title="4.文件的追加"></a>4.文件的追加</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(file_name,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>write()方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.write(追加的内容)</span><br><span class="line"><span class="comment">#仅仅write方法还并不能将内容追加至文件，而是会积攒在程序的内存中，称之为缓冲区。</span></span><br><span class="line"><span class="comment">#这是为了避免频繁操作硬盘，导致效率下降</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flush（）方法：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.flush()</span><br><span class="line"><span class="comment">#内容刷新，将缓冲区内的数据刷新至文件。</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="八-Python异常，模块与包"><a href="#八-Python异常，模块与包" class="headerlink" title="八.Python异常，模块与包"></a>八.Python异常，模块与包</h1><h2 id="1-了解异常"><a href="#1-了解异常" class="headerlink" title="1.了解异常"></a>1.了解异常</h2><p>​	异常是检测到错误时，Python解释器无法继续运行，即为异常，可能是语法错误，如用lambda定义有名称函数，也有可能是逻辑错误，如下标索引超出范围。</p>
<h2 id="2-异常的捕获方式"><a href="#2-异常的捕获方式" class="headerlink" title="2.异常的捕获方式"></a>2.异常的捕获方式</h2><p>​	捕获异常的意义在于提前假设某处会出现异常，提前做好准备，当真的出现异常时可以有后续的手段，以此增强程序的健壮性。</p>
<ul>
<li>捕获常规异常</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    可能发生错误的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常执行的代码</span><br></pre></td></tr></table></figure>

<ul>
<li>捕获指定异常</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> SpecialError <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="comment">#在python中本身内置了很多种类的异常，as e的意思是将这个异常信息赋值给变量e</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>捕获多个异常</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> (SpecialError1,SpecialError2) <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="comment">#注意：这里是满足任意一个异常就会被被捕获，并将异常信息赋值给变量e</span></span><br></pre></td></tr></table></figure>

<ul>
<li>捕获全部异常</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br></pre></td></tr></table></figure>

<ul>
<li>异常的else和finally语法</li>
<li>异常的else：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> (SpecialError1,SpecialError2) <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    stuct</span><br></pre></td></tr></table></figure>

<p>​	也就是说，如果没有异常就会执行else里的语句，同时try中的语句也会执行</p>
<ul>
<li>finally：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法：</span></span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	可能导致异常的代码</span><br><span class="line"><span class="keyword">except</span> (SpecialError1,SpecialError2) <span class="keyword">as</span>  e:</span><br><span class="line">    如果出现特定异常，执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    stuct</span><br><span class="line"><span class="keyword">finally</span>：</span><br><span class="line">	do</span><br></pre></td></tr></table></figure>

<p>​	finally的作用在于不管如何都会执行finally中的语句。</p>
<ul>
<li>异常捕获需要注意的点：<ul>
<li>try中的语句如果任意一条触发异常，那么整个try中的语句都不会执行</li>
<li>常规捕获的是指捕获<strong>任何</strong>会造成程序中断的异常，包括系统退出、键盘中断等不属于程序本身的部分，但是全部捕获是指捕获在Exception这个类及其子类的异常</li>
</ul>
</li>
</ul>
<h2 id="3-异常的传递"><a href="#3-异常的传递" class="headerlink" title="3.异常的传递"></a>3.异常的传递</h2><pre><code> 异常是可以传递的。异常会一直传递到执行的最高层级.
</code></pre>
<p>​	也就是说，即使异常存在的结构中没有捕获手段，程序并不会直接报错，而是继续向高层级查找是否会有一个存在于其他结构中的捕获代码对这个异常进行调用，如果没有则报错</p>
<p>​	显然地，我们如果想要处理异常并不需要真正到异常出现的那个语句中去。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例如：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    func = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a())</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-python的模块"><a href="#4-python的模块" class="headerlink" title="4.python的模块"></a>4.python的模块</h2><p>​	python模块(Module)，是一个python文件，以.py结尾。模块能定义函数，类和变量，也包含可执行的代码。</p>
<p>​	模块的作用在于帮助我们<strong>快速实现一些功能</strong>，而不用自己写脚本。我们可以认为：	</p>
<p>​					   	<strong>模块&#x3D;&#x3D;工具包</strong></p>
<p>​					<strong>里面的函数，类和变量&#x3D;&#x3D;工具</strong></p>
<ul>
<li>模块的导入</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">[<span class="keyword">from</span> Moudule_name] <span class="keyword">import</span>[Module|<span class="keyword">class</span>|variable|function|*] [<span class="keyword">as</span> alias]</span><br><span class="line"><span class="comment">#*表示导入模块内的全部内容</span></span><br><span class="line"><span class="comment">#[]在python代码描述语句中表示可选择的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>​	尽管python中有许多内置的模块，但是总不可能所有的场景都适用，于是自定义模块就很重要。</p>
<p>​	前文说到，模块本质上就是.py文件，那么自定义模块就是建立一个自己的.py文件，需要用时，引用文件名即可，自定义模块的引用与内置模块的引用方式并无差别。</p>
<p>​	调用时需要注意的小细节：当调用了不模块的同名内容，后调用的会覆盖先调用的。(事实上，pycharm的提示信息会将没有使用的函数，变量，模块标灰)</p>
<ul>
<li>测试模块</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不妨我们可以设置一个简单的自定义模块如下：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x+y)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#对模块功能进行测试</span></span><br></pre></td></tr></table></figure>

<p>​	当我们写好模块之后难免会对功能进行测试，但是导入模块时会先对模块进行运行，这样一来测试的代码就会被执行，如果不想测试代码被执行呢？</p>
<p>​	<strong>内置变量__name__</strong>:</p>
<p>​	python中存在值固定的内置函数，比如__name__，__name__变量表示当前.py文件在执行的过程中的”地位“，如果当前文件是主函数，那么__name__的值为__main__，如果作为模块，那么__name__的值为模块名。</p>
<p>​	于是，可以使用如下代码来进行模块检测，同时检测代码不会在导入时被运行。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x+y)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	add(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>__all__变量</strong>：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Moudule <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#这个*说是全部内容，事实上是定义在__all__变量中的所有内容</span></span><br><span class="line"><span class="comment">#那么当我们通过重新定义__all__变量就可以将一些其他无关内容排除在外</span></span><br></pre></td></tr></table></figure>

<h2 id="5-安装第三方包"><a href="#5-安装第三方包" class="headerlink" title="5.安装第三方包"></a>5.安装第三方包</h2><p>​	包是模块的集合，安装第三方包只需要通过pip即可安装。但是pip默认是从国外的网站下面下载的，想提高效率可以用国内的镜像站。</p>
<p>​	或者通过pycharm下载。</p>
<h2 id="6-编写并导入自定义的包"><a href="#6-编写并导入自定义的包" class="headerlink" title="6.编写并导入自定义的包"></a>6.编写并导入自定义的包</h2><hr>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="zhouyue&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>